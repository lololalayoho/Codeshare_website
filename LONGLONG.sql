-- MySQL dump 10.13  Distrib 5.7.17, for Linux (x86_64)
--
-- Host: localhost    Database: LONGLONG
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `COMMENT`
--

DROP TABLE IF EXISTS `COMMENT`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `COMMENT` (
  `num` int(11) NOT NULL AUTO_INCREMENT,
  `content` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `id` int(11) DEFAULT NULL,
  `seq` int(11) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  PRIMARY KEY (`num`),
  KEY `id` (`id`),
  KEY `seq` (`seq`),
  CONSTRAINT `COMMENT_ibfk_1` FOREIGN KEY (`id`) REFERENCES `USER` (`id`),
  CONSTRAINT `COMMENT_ibfk_2` FOREIGN KEY (`seq`) REFERENCES `SOLVE` (`seq`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `COMMENT`
--

LOCK TABLES `COMMENT` WRITE;
/*!40000 ALTER TABLE `COMMENT` DISABLE KEYS */;
INSERT INTO `COMMENT` VALUES (3,'댓글 테스트 중입니다1',12151601,297,'2021-01-06 12:07:59'),(5,'댓글 테스트 중입니다 3',12151601,298,'2021-01-06 12:09:14'),(6,'댓글 신기하당',12181751,298,'2021-01-08 18:31:22'),(7,'\"에라토스테네스의 체\"를 이용하였습니다',12151601,348,'2021-01-25 19:15:04');
/*!40000 ALTER TABLE `COMMENT` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `GIVE`
--

DROP TABLE IF EXISTS `GIVE`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `GIVE` (
  `class` int(11) NOT NULL,
  `origin` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `no` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `GIVE`
--

LOCK TABLES `GIVE` WRITE;
/*!40000 ALTER TABLE `GIVE` DISABLE KEYS */;
INSERT INTO `GIVE` VALUES (2,'BJ',11726),(2,'BJ',1495),(2,'BJ',9184),(2,'BJ',16236),(2,'BJ',14719);
/*!40000 ALTER TABLE `GIVE` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `PROBLEM`
--

DROP TABLE IF EXISTS `PROBLEM`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `PROBLEM` (
  `origin` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `no` int(11) NOT NULL,
  `title` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `address` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`origin`,`no`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `PROBLEM`
--

LOCK TABLES `PROBLEM` WRITE;
/*!40000 ALTER TABLE `PROBLEM` DISABLE KEYS */;
INSERT INTO `PROBLEM` VALUES ('BJ',1013,'Contact','https://www.acmicpc.net/problem/1013'),('BJ',1021,'회전하는 큐','https://www.acmicpc.net/problem/1021'),('BJ',1043,'거짓말','https://www.acmicpc.net/problem/1043'),('BJ',1074,'z','https://www.acmicpc.net/problem/1074'),('BJ',1106,'호텔','https://www.acmicpc.net/problem/1106'),('BJ',1182,'부분수열의 합','https://www.acmicpc.net/problem/1182'),('BJ',1301,'비즈 공예','https://www.acmicpc.net/problem/1301'),('BJ',1309,'동물원','https://www.acmicpc.net/problem/1309'),('BJ',1463,'1로 만들기','https://www.acmicpc.net/problem/1463'),('BJ',1495,'기타리스트','https://www.acmicpc.net/problem/1495'),('BJ',1535,'안녕','https://www.acmicpc.net/problem/1535'),('BJ',1600,'말이 되고픈 원숭이','https://www.acmicpc.net/problem/1600'),('BJ',1644,'소수의 연속합','https://www.acmicpc.net/problem/1644'),('BJ',1660,'캡틴 이다솜','https://www.acmicpc.net/problem/1660'),('BJ',1695,'팰린드롬 만들기','https://www.acmicpc.net/problem/1695'),('BJ',1759,'암호 만들기','https://www.acmicpc.net/problem/1759'),('BJ',1806,'부분합','https://www.acmicpc.net/problem/1806'),('BJ',1904,'01 타일','https://www.acmicpc.net/problem/1904'),('BJ',1912,'연속합','https://www.acmicpc.net/problem/1912'),('BJ',1914,'하노이 탑','https://www.acmicpc.net/problem/1914'),('BJ',1915,'가장 큰 정사각형','https://www.acmicpc.net/problem/1915'),('BJ',1987,'알파벳','https://www.acmicpc.net/problem/1987'),('BJ',2156,'포도주','https://www.acmicpc.net/problem/2156'),('BJ',2164,'카드2','https://www.acmicpc.net/problem/2164'),('BJ',2174,'로봇 시뮬레이션','https://www.acmicpc.net/problem/2174'),('BJ',2468,'안전 영역','https://www.acmicpc.net/problem/2468'),('BJ',2470,'두 용액','https://www.acmicpc.net/problem/2470'),('BJ',2565,'전깃줄','https://www.acmicpc.net/problem/2565'),('BJ',2579,'계단오르기','https://www.acmicpc.net/problem/2579'),('BJ',2688,'줄어들지 않아','https://www.acmicpc.net/problem/2688'),('BJ',3055,'탈출','https://www.acmicpc.net/problem/3055'),('BJ',3190,'뱀','https://www.acmicpc.net/problem/3190'),('BJ',3273,'두 수의 합','https://www.acmicpc.net/problem/3273'),('BJ',6603,'로또','https://www.acmicpc.net/problem/6603'),('BJ',9095,'1, 2, 3 더하기','https://www.acmicpc.net/problem/9095'),('BJ',9184,'신나는 함수 실행','https://www.acmicpc.net/problem/9184'),('BJ',9251,'LCS','https://www.acmicpc.net/problem/9251'),('BJ',10164,'격자상의 경로','https://www.acmicpc.net/problem/10164'),('BJ',10828,'스택 (자바)','https://www.acmicpc.net/problem/10828'),('BJ',10844,'쉬운 계단수','https://www.acmicpc.net/problem/10844'),('BJ',10845,'큐 (자바)','https://www.acmicpc.net/problem/10845'),('BJ',11051,'이항계수 2','https://www.acmicpc.net/problem/11051'),('BJ',11053,'가장 긴 증가하는 부분 수열','https://www.acmicpc.net/problem/11053'),('BJ',11054,'가장 긴 바이토닉 부분 수열','https://www.acmicpc.net/problem/11054'),('BJ',11057,'오르막 수','https://www.acmicpc.net/problem/11057'),('BJ',11724,'연결 요소의 개수','https://www.acmicpc.net/problem/11724'),('BJ',11726,'2xn 타일링','https://www.acmicpc.net/problem/11726'),('BJ',12205,'주유소','https://www.acmicpc.net/problem/13305'),('BJ',12865,'평범한 배낭','https://www.acmicpc.net/problem/12865'),('BJ',14500,'테트로미노','https://www.acmicpc.net/problem/14500'),('BJ',14502,'연구소','https://www.acmicpc.net/problem/14502'),('BJ',14719,'빗물','https://www.acmicpc.net/problem/14719'),('BJ',14889,'스타트와 링크','https://www.acmicpc.net/problem/14889'),('BJ',14890,'경사로','https://www.acmicpc.net/problem/14890'),('BJ',14891,'톱니바퀴','https://www.acmicpc.net/problem/14891'),('BJ',15683,'감시','https://www.acmicpc.net/problem/15683'),('BJ',15684,'사다리 조작','https://www.acmicpc.net/problem/15684'),('BJ',15686,'치킨 배달','https://www.acmicpc.net/problem/15686'),('BJ',16234,'인구 이동','https://www.acmicpc.net/problem/16234'),('BJ',16236,'아기 상어','https://www.acmicpc.net/problem/16236'),('BJ',17263,'Sort 마스터 배지훈','https://www.acmicpc.net/problem/17263'),('BJ',17264,'I AM IRONMAN','https://www.acmicpc.net/problem/17264'),('BJ',17265,'나의 인생에는 수학과 함께','https://www.acmicpc.net/problem/17265'),('BJ',17266,'어두운 굴다리','https://www.acmicpc.net/problem/17266'),('BJ',17267,'상남자','https://www.acmicpc.net/problem/17267'),('SW',1952,'수영장','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq'),('SW',2112,'보호 필름','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V1SYKAaUDFAWu'),('SW',2115,'벌꿀채취','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V4A46AdIDFAWu'),('SW',2382,'미생물 격리','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV597vbqAH0DFAVl'),('SW',2383,'점심 식사시간','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl'),('SW',4012,'요리사','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeUtVakTMDFAVH'),('SW',5644,'무선 충전','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRDL1aeugDFAUo'),('SW',5648,'원자 소멸 시뮬레이션','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRFInKex8DFAUo'),('SW',5650,'핀볼','https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRF8s6ezEDFAUo&');
/*!40000 ALTER TABLE `PROBLEM` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `PROBLEM_DATE`
--

DROP TABLE IF EXISTS `PROBLEM_DATE`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `PROBLEM_DATE` (
  `origin` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `no` int(11) NOT NULL,
  `date` date NOT NULL,
  KEY `probdate_prob` (`origin`,`no`),
  CONSTRAINT `probdate_prob` FOREIGN KEY (`origin`, `no`) REFERENCES `PROBLEM` (`origin`, `no`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `PROBLEM_DATE`
--

LOCK TABLES `PROBLEM_DATE` WRITE;
/*!40000 ALTER TABLE `PROBLEM_DATE` DISABLE KEYS */;
INSERT INTO `PROBLEM_DATE` VALUES ('SW',5650,'2020-03-03'),('SW',5648,'2020-03-03'),('SW',2382,'2020-03-03'),('BJ',9251,'2020-03-03'),('BJ',2579,'2020-03-03'),('BJ',2156,'2020-03-03'),('BJ',1463,'2020-03-03'),('BJ',6603,'2020-03-03'),('BJ',11724,'2020-03-03'),('BJ',10844,'2020-03-06'),('BJ',11054,'2020-03-06'),('BJ',2565,'2020-03-10'),('BJ',1912,'2020-03-10'),('BJ',12865,'2020-03-10'),('BJ',14891,'2020-03-10'),('SW',5644,'2020-03-10'),('BJ',11053,'2020-03-11'),('BJ',1904,'2020-03-15'),('BJ',1021,'2020-03-15'),('BJ',10828,'2020-03-16'),('BJ',10845,'2020-03-16'),('SW',1952,'2020-03-16'),('BJ',1309,'2020-03-16'),('BJ',15686,'2020-03-16'),('SW',4012,'2020-03-16'),('SW',2112,'2020-03-16'),('BJ',14890,'2020-03-22'),('BJ',14502,'2020-03-23'),('BJ',1495,'2020-03-23'),('BJ',1535,'2020-03-23'),('BJ',2174,'2020-03-28'),('BJ',1106,'2020-03-30'),('BJ',1013,'2020-03-30'),('BJ',14500,'2020-03-30'),('BJ',16236,'2020-04-04'),('BJ',15684,'2020-04-06'),('BJ',1301,'2020-04-06'),('BJ',1660,'2020-04-06'),('BJ',1695,'2020-04-13'),('SW',2115,'2020-04-13'),('SW',2383,'2020-04-13'),('BJ',1759,'2020-04-14'),('BJ',11057,'2020-04-23'),('BJ',1915,'2020-04-23'),('BJ',1043,'2020-05-19'),('BJ',10164,'2020-05-19'),('BJ',2688,'2020-05-29'),('BJ',11051,'2020-05-29'),('BJ',3190,'2020-10-10'),('BJ',2164,'2020-11-07'),('BJ',1074,'2020-11-07'),('BJ',16234,'2020-11-15'),('BJ',14889,'2020-11-15'),('BJ',17263,'2020-12-28'),('BJ',17264,'2020-12-28'),('BJ',17265,'2020-12-28'),('BJ',17266,'2020-12-28'),('BJ',17267,'2020-12-28'),('BJ',1914,'2021-01-04'),('BJ',1182,'2021-01-04'),('BJ',1987,'2021-01-04'),('BJ',9095,'2021-01-04'),('BJ',12205,'2021-01-04'),('BJ',3273,'2021-01-12'),('BJ',2470,'2021-01-12'),('BJ',15683,'2021-01-12'),('BJ',3055,'2021-01-12'),('BJ',1600,'2021-01-12'),('BJ',1806,'2021-01-20'),('BJ',1644,'2021-01-20'),('BJ',2468,'2021-01-20'),('BJ',11726,'2021-01-25'),('BJ',9184,'2021-01-25'),('BJ',14719,'2021-01-25');
/*!40000 ALTER TABLE `PROBLEM_DATE` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `SOLVE`
--

DROP TABLE IF EXISTS `SOLVE`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `SOLVE` (
  `id` int(11) NOT NULL,
  `origin` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `no` int(11) NOT NULL,
  `code` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `date` datetime NOT NULL,
  `seq` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`seq`),
  KEY `solve_id` (`id`),
  KEY `solve_prob` (`origin`,`no`),
  CONSTRAINT `solve_id` FOREIGN KEY (`id`) REFERENCES `USER` (`id`) ON DELETE CASCADE,
  CONSTRAINT `solve_prob` FOREIGN KEY (`origin`, `no`) REFERENCES `PROBLEM` (`origin`, `no`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=351 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `SOLVE`
--

LOCK TABLES `SOLVE` WRITE;
/*!40000 ALTER TABLE `SOLVE` DISABLE KEYS */;
INSERT INTO `SOLVE` VALUES (12151601,'SW',5650,'#include &lt;iostream&gt;<br />#include &lt;vector&gt;<br />using namespace std;<br /><br />int map[100][100];<br />pair&lt;int, int&gt; wormhole[5][100][100];<br />int N, ans, cnt;<br />int dx[] = { 0,-1,0,1 };<br />int dy[] = { -1,0,1,0 };<br /><br />void dfs(int x, int y, int i) {<br />    int nx = x + dx[i];<br />    int ny = y + dy[i];<br />    if (nx == -1 || nx == N || ny == -1 || ny == N) {<br />        cnt++;<br />        if (map[x][y] == -1) return;<br />        dfs(nx, ny, (i + 2) % 4);<br />    }<br />    else {<br />        switch (map[nx][ny]) {<br />        case 0:<br />            dfs(nx, ny, i);<br />            break;<br />        case 1:<br />            cnt++;<br />            switch (i) {<br />            case 0: i = 1; break;<br />            case 1:    i = 3; break;<br />            case 2: i = 0; break;<br />            case 3: i = 2; break;<br />            }<br />            dfs(nx, ny, i);<br />            break;<br />        case 2:<br />            cnt++;<br />            switch (i) {<br />            case 0: i = 3; break;<br />            case 1: i = 2; break;<br />            case 2: i = 0; break;<br />            case 3: i = 1; break;<br />            }<br />            dfs(nx, ny, i);<br />            break;<br />        case 3:<br />            cnt++;<br />            switch (i) {<br />            case 0: i = 2; break;<br />            case 1: i = 0; break;<br />            case 2: i = 3; break;<br />            case 3: i = 1; break;<br />            }<br />            dfs(nx, ny, i);<br />            break;<br />        case 4:<br />            cnt++;<br />            switch (i) {<br />            case 0: i = 2; break;<br />            case 1: i = 3; break;<br />            case 2: i = 1; break;<br />            case 3: i = 0; break;<br />            }<br />            dfs(nx, ny, i);<br />            break;<br />        case 5:<br />            cnt++;<br />            switch (i) {<br />            case 0: i = 2; break;<br />            case 1: i = 3; break;<br />            case 2: i = 0; break;<br />            case 3: i = 1; break;<br />            }<br />            dfs(nx, ny, i);<br />            break;<br />        case 6:<br />            dfs(wormhole[0][nx][ny].first, wormhole[0][nx][ny].second, i);<br />            break;<br />        case 7:<br />            dfs(wormhole[1][nx][ny].first, wormhole[1][nx][ny].second, i);<br />            break;<br />        case 8:<br />            dfs(wormhole[2][nx][ny].first, wormhole[2][nx][ny].second, i);<br />            break;<br />        case 9:<br />            dfs(wormhole[3][nx][ny].first, wormhole[3][nx][ny].second, i);<br />            break;<br />        case 10:<br />            dfs(wormhole[4][nx][ny].first, wormhole[4][nx][ny].second, i);<br />            break;<br />        case -1:<br />            if (ans &lt; cnt) {<br />                ans = cnt;<br />                return;<br />            }<br />            break;<br />        }<br />    }<br />}<br /><br />int main() {<br />    int T;<br />    cin &gt;&gt; T;<br />    for (int t = 1; t &lt;= T; t++) {<br />        ans = 0;<br />        cin &gt;&gt; N;<br />        vector&lt;pair&lt;int, int&gt;&gt; wh[5];<br />        for (int i = 0; i &lt; N; i++) {<br />            for (int j = 0; j &lt; N; j++) {<br />                cin &gt;&gt; map[i][j];<br />                if (map[i][j] &gt;= 6) {<br />                    wh[map[i][j] - 6].push_back({ i,j });<br />                }<br />            }<br />        }<br />        for (int i = 0; i &lt; 5; i++) {<br />            if (wh[i].size()) {<br />                wormhole[i][wh[i][0].first][wh[i][0].second] = { wh[i][1].first, wh[i][1].second };<br />                wormhole[i][wh[i][1].first][wh[i][1].second] = { wh[i][0].first, wh[i][0].second };<br />            }<br />        }<br />        for (int x = 0; x &lt; N; x++) {<br />            for (int y = 0; y &lt; N; y++) {<br />                if (map[x][y]) continue;<br />                map[x][y] = -1;<br />                for (int i = 0; i &lt; 4; i++) {<br />                    dfs(x, y, i);<br />                    cnt = 0;<br />                }<br />                map[x][y] = 0;<br />            }<br />        }<br />        <br />        cout &lt;&lt; &#39;#&#39; &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;<br />    }<br />}','2020-03-09 16:52:20',1),(12151636,'BJ',9251,'#include &lt;iostream&gt;<br />#include &lt;string&gt;<br />using namespace std;<br /><br />string value1;<br />string value2;<br /><br />long long value1_arr[1001];<br />long long value2_arr[1001];<br /><br />int main() {<br />   cin &gt;&gt; value1 &gt;&gt; value2;<br />   for (int i = 0; i &lt; value1.size(); i++) {<br />      long long max_value = 0;<br />      for (int j = 0; j &lt; value2.size(); j++) {<br />         if (value1[i] == value2[j]) {<br />            if (max_value &lt; value2_arr[j]) {<br />               max_value = value2_arr[j];<br />               value2_arr[j] = max_value;<br />               value1_arr[i] = max_value;<br />            }<br />            else {<br />               value2_arr[j] = max_value + 1;<br />               value1_arr[i] = max_value + 1;<br />            }<br />         }<br />         else if (max_value &lt; value2_arr[j])<br />            max_value = value2_arr[j];<br />      }<br />   }<br />   int max = 0;<br />   for (int i = 0; i &lt; value1.size(); i++) {<br />      if (max &lt; value1_arr[i])<br />         max = value1_arr[i];<br />   }<br />   cout &lt;&lt; max &lt;&lt; endl;<br />}','2020-03-09 17:38:15',2),(12151601,'BJ',11054,'#include &lt;iostream&gt;<br />#include &lt;algorithm&gt;<br />using namespace std;<br />int A[1000], dl[1000], dr[1000], d[1000];<br /><br />int main() {<br />    int N, ans, mxr, mxl;<br />    ans = 0;<br />    cin &gt;&gt; N;<br />    for (int i = 0; i &lt; N; i++)<br />        cin &gt;&gt; A[i];<br />    for (int i = 0; i &lt; N; i++) {<br />        dl[i] = 1;<br />        mxl = 1;<br />        for (int j = 0; j &lt; i; j++)<br />            if (A[j] &lt; A[i])<br />                mxl = max(mxl, dl[i] + dl[j]);<br />        dl[i] = mxl;<br />    }<br /><br />    for (int i = N - 1; i &gt;= 0; i--) {<br />        dr[i] = 1;<br />        mxr = 1;<br />        for (int j = N - 1; j &gt;= 0; j--)<br />            if (A[j] &lt; A[i])<br />                mxr = max(mxr, dr[i] + dr[j]);<br />        dr[i] = mxr;<br />        d[i] = dr[i] + dl[i] - 1;<br />        ans = max(ans, d[i]);<br />    }<br />    cout &lt;&lt; ans;<br /><br />}','2020-03-09 15:27:55',3),(12181853,'BJ',1463,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint N; // 1보다 크거나 같고 10^6보다 작거나 같은 정수\r\nint X; // 나누려는 정수\r\nint cnt; // 연산을 하는 최솟값\r\n\r\n\r\nint BFS(int N)\r\n{\r\n    queue&lt;pair&lt;int, int&gt;&gt; Q;\r\n    \r\n    Q.push(make_pair(N, 0)); // 맨 처음 나누려는 정수를 N으로 넣고, 그 떄의 연산의 최솟값은 0\r\n    \r\n    while (!Q.empty())\r\n    {\r\n        int X = Q.front().first;\r\n        int cnt = Q.front().second;\r\n\r\n        Q.pop();\r\n\r\n        if (X == 1) // 정수가 1이면\r\n            return cnt; // 연산을 사용하며 1을 만들었으므로 CNT 출력\r\n        if (X % 3 == 0) // 정수가 3으로 나누어떨어지면\r\n            Q.push(make_pair(X / 3, cnt + 1)); // 정수를 3으로 나눈 값을 넣고, 연산을 1번 했음으로 CNT 증가\r\n        else if (X % 2 == 0) // 정수가 2로 나누어떨어지면\r\n            Q.push(make_pair(X / 2, cnt + 1)); // 정수를 2로 나눈 값을 넣고, 연산을 1번 했으므로 CNT 증가\r\n        Q.push(make_pair(X - 1, cnt + 1)); // 마지막 연산은 1로 만들어주는 것이므로 정수 - 1을 넣어주고 CNT를 증가\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    cout &lt;&lt; BFS(N);\r\n    \r\n    return 0;\r\n}\r\n\r\n','2020-03-10 15:16:29',4),(12181853,'BJ',2579,'#include &lt;iostream&gt;<br />#include &lt;algorithm&gt;<br />using namespace std;<br />#define MAX 301<br /><br />int N;<br />int STAIR[MAX];<br />int STEP[MAX]; <br /><br />int MAXSum()<br />{<br />    STEP[1] = STAIR[1];<br />    STEP[2] = STAIR[1] + STAIR[2];<br />    STEP[3] = max(STAIR[1] + STAIR[3], STAIR[2] + STAIR[3]);<br /><br />    for (int i = 4; i &lt;= N; i++)<br />    {<br />        STEP[i] = max(STEP[i - 2] + STAIR[i], STEP[i - 3] + STAIR[i - 1] + STAIR[i]);<br />    }<br /><br />    return STEP[N];<br />}<br /><br />int main(void)<br />{<br />    cin &gt;&gt; N;<br /><br />    for (int i = 1; i &lt;= N; i++)<br />    {<br />        cin &gt;&gt; STAIR[i];<br />    }<br />    <br />    cout &lt;&lt; MAXSum() &lt;&lt; endl;<br /><br />    return 0;<br />}<br /><br />','2020-03-09 19:48:59',5),(12151636,'SW',2382,'#include &lt;iostream&gt;<br />#include &lt;vector&gt;<br />using namespace std;<br /><br />struct object {<br />    int value;<br />    int dir;<br />};<br />vector&lt;object&gt; map[101][101];<br />object map_result[101][101];<br />int visit[101][101];<br />int dx[] = { 0,-1,1,0,0 };<br />int dy[] = { 0,0,0,-1,1 };<br />int K, N, M;<br /><br />void move_object() {<br />    for (int i = 0; i &lt; N; i++) {<br />        for (int j = 0; j &lt; N; j++) {<br />            if (map_result[i][j].value &gt; 0) {<br />                int nextx = i + dx[map_result[i][j].dir];<br />                int nexty = j + dy[map_result[i][j].dir];<br /><br />                if (nextx==0 || nextx==N-1 || nexty==0 || nexty==N-1) {<br />                    object obj;<br />                    <br />                    obj.value = map_result[i][j].value / 2;<br />                    obj.dir = map_result[i][j].dir;<br />                    <br />                    if (obj.dir == 1)<br />                        obj.dir = 2;<br />                    else if (obj.dir == 2)<br />                        obj.dir = 1;<br />                    else if (obj.dir == 3)<br />                        obj.dir = 4;<br />                    else if (obj.dir == 4)<br />                        obj.dir = 3;<br />                    <br />                    map[nextx][nexty].push_back(obj);<br />                }<br />                else {<br />                    object obj;<br />                    obj.value = map_result[i][j].value;<br />                    obj.dir = map_result[i][j].dir;<br />                    map[nextx][nexty].push_back(obj);<br />                }<br />            }<br />        }<br />    }<br />}<br />void visit_init() {<br />    for (int i = 0; i &lt; N; i++)<br />        for (int j = 0; j &lt; N; j++) {<br />            visit[i][j] = 0;<br />            map_result[i][j].value = 0;<br />            map_result[i][j].dir = 0;<br />        }<br />}<br />void value_init() {<br />    for (int i = 0; i &lt; N; i++) {<br />        for (int j = 0; j &lt; N; j++) {<br />            int value = 0; int max_value = 0; int m_dir = 0;<br />            for (int k = 0; k &lt; map[i][j].size(); k++) {<br />                value = value + map[i][j][k].value;<br />                if (max_value &lt; map[i][j][k].value) {<br />                    max_value = map[i][j][k].value;<br />                    m_dir = map[i][j][k].dir;<br />                }<br />            }<br />            map_result[i][j].dir = m_dir;<br />            map_result[i][j].value = value;<br />            map[i][j].clear();<br />        }<br />    }<br />}<br /><br />int main() {<br />    int testcase, row, col;<br />    cin &gt;&gt; testcase;<br />    for (int t = 0; t &lt; testcase; t++) {<br />        cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;<br />        for (int i = 0; i &lt; N; i++)<br />            for (int j = 0; j &lt; N; j++)<br />                map[i][j].clear();<br />        for (int i = 0; i &lt; K; i++) {<br />            object obj;<br />            cin &gt;&gt; row &gt;&gt; col &gt;&gt; obj.value &gt;&gt; obj.dir;<br />            map[row][col].push_back(obj);<br />        }<br />        for (int m = 0; m &lt;= M; m++) {<br />            visit_init();<br />            value_init();<br />            move_object();<br />        }<br />        int cnt = 0;<br />        for (int i = 0; i &lt; N; i++) {<br />            for (int j = 0; j &lt; N; j++) {<br />                if (map_result[i][j].value &gt; 0) {<br />                    cnt = cnt + map_result[i][j].value;<br />                }<br />            }<br />        }<br />        cout&lt;&lt;&quot;#&quot;&lt;&lt;t+1&lt;&lt;&quot; &quot; &lt;&lt; cnt &lt;&lt; endl;<br />    }<br />}','2020-03-09 21:13:21',6),(12151636,'BJ',10844,'#include &lt;iostream&gt;<br />using namespace std;<br /><br />long long arr1[10];<br />long long dp[101][10];<br /><br />int main() {<br />    int N;<br />    cin &gt;&gt; N;<br />    for (int i = 0; i &lt; 10; i++)<br />        dp[1][i] = 1;<br />    for (int i = 2; i &lt;=N; i++) {<br />        dp[i][0] = dp[i - 1][1] % 1000000000;<br />        for (int j = 1; j &lt; 9; j++) {<br />            dp[i][j] = (dp[i - 1][j + 1] + dp[i - 1][j - 1]) % 1000000000;<br />        }<br />        dp[i][9] = dp[i - 1][8] % 1000000000;<br />    }<br />    int cnt = 0;<br />    for (int i = 1; i &lt; 10; i++) {<br />        cnt = (cnt + dp[N][i]) % 1000000000;<br />    }<br />    cout &lt;&lt; cnt&lt;&lt; endl;<br />}<br /> ','2020-03-09 21:14:16',7),(12151636,'BJ',11054,'#include &lt;iostream&gt;<br />#include &lt;algorithm&gt;<br />using namespace std;<br /><br />long long arr[2][1001];<br />long long arr1[2][1001];<br /><br />int main() {<br />    int N;<br />    cin &gt;&gt; N;<br />    for (int i = 0; i &lt; N; i++)<br />        cin &gt;&gt; arr[0][i];<br />    arr[1][0] = 1;<br />    for (int i = 1; i &lt; N; i++) {<br />        for (int j = i; j &gt;= 0; j--) {<br />            if (arr[0][i] &gt; arr[0][j]) {<br />                arr[1][i] = max(arr[1][i],arr[1][j] + 1);<br />            }<br />            else if (arr[0][i] == arr[0][j]) {<br />                arr[1][i] = max(arr[1][i], arr[1][j]);<br />            }<br />        }<br />        if (arr[1][i] == 0)<br />            arr[1][i] = 1;<br />    }<br />    <br />    arr1[1][N - 1] = 1;<br />    for (int i = N - 1; i &gt;= 0; i--) {<br />        for (int j = i; j &lt; N; j++) {<br />            if (arr[0][i] &gt; arr[0][j]) {<br />                arr1[1][i] = max(arr1[1][i], arr1[1][j] + 1);<br />            }<br />            else if (arr[0][i] == arr[0][j]) {<br />                arr1[1][i] = max(arr1[1][i], arr1[1][j]);<br />            }<br />        }<br />        if (arr1[1][i] == 0)<br />            arr1[1][i] = 1;<br />        arr1[0][i] = arr[1][i] + arr1[1][i];<br />    }<br /><br />    int max_value = 0;<br />    for (int i = 0; i &lt; N; i++) {<br />        if (max_value &lt; arr1[0][i])<br />            max_value = arr1[0][i];<br />    }<br />    cout &lt;&lt; max_value-1 &lt;&lt; endl;<br />}','2020-03-09 21:14:42',8),(12151526,'BJ',11054,'#include&lt;iostream&gt;<br />#include&lt;vector&gt;<br />#include&lt;math.h&gt;<br />#include&lt;algorithm&gt;<br />#include&lt;queue&gt;<br />using namespace std;<br /><br />priority_queue&lt;int&gt; answer;<br />int N;<br />int A[1000] = { 0, };<br />int MX = 0;<br />int MX2 = 0;<br />int res = 0;<br />int res2 = 0;<br /><br />int main() {<br />    cin &gt;&gt; N;<br />    int b = 0;<br />    for (int i = 0; i &lt; N; i++) {<br />        cin &gt;&gt; A[i];<br />    }<br />    for (int k = 0; k &lt; N; k++) {<br />        int dp[1000] = { 0, };<br />        int dp2[1000] = { 0, };<br />        for (int i = 0; i &lt;= k; i++) {<br />            dp[i] = 1;<br />            MX = 1;<br />            for (int j = 0; j &lt; i; j++) {<br />                if (A[i] &gt; A[j]) {<br />                    res = dp[j] + dp[i];<br />                    MX = max(res, MX);<br />                }<br />            }<br />            dp[i] = MX;<br />        }<br />        for (int i = N - 1; i &gt;= k; i--) {<br />            dp2[i] = 1;<br />            MX2 = 1;<br />            for (int j = N - 1; j &gt; i; j--) {<br />                if (A[i] &gt; A[j]) {<br />                    res2 = dp2[j] + dp2[i];<br />                    MX2 = max(res2, MX2);<br />                }<br />            }<br />            dp2[i] = MX2;<br />            answer.push(MX + MX2);<br />        }<br />    }<br />    cout &lt;&lt; answer.top() - 1;<br />}','2020-03-09 21:36:02',9),(12151526,'BJ',10844,'#include &lt;iostream&gt;<br />using namespace std;<br /><br />int N;<br />long long answer = 0;<br />long long dp[101][10] = { 0, };<br /><br />int main() {<br />    cin &gt;&gt; N;<br />    for (int i = 0; i &lt; 10; i++) {<br />        dp[1][i] = 1;<br />    }<br />    for (int i = 2; i &lt;= N; i++) {<br />        dp[i][0] = (dp[i - 1][1]) % 1000000000;<br />        for (int j = 1; j &lt;= 8; j++) {<br />            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000000;<br />        }<br />        dp[i][9] = (dp[i - 1][8]) % 1000000000;<br />    }<br />    for (int i = 1; i &lt;= 9; i++) {<br />        answer = (answer + dp[N][i]) % 1000000000;<br />    }<br />    cout &lt;&lt; answer;<br />}','2020-03-09 21:36:30',10),(12151526,'SW',5648,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nstruct dc {\r\n    int num;\r\n    int discr;\r\n};\r\nstruct lo2 {\r\n    int x;\r\n    int y;\r\n    int d;\r\n    int energy;\r\n};\r\nbool operator&lt;(dc t, dc u) {\r\n    return t.num &lt; u.num;\r\n}\r\nvector&lt;lo2&gt; atom;\r\npriority_queue &lt;dc&gt; trash;\r\nvector&lt;int&gt;answer;\r\nint map[4001][4001] = { 0, };\r\nint dx[4] = { 0, 0, -1, 1 };\r\nint dy[4] = { 1, -1, 0, 0 };\r\nint va1, va2, va3, va4;\r\nint N, T;\r\nint cnt = 0;\r\n\r\nvoid go() {\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        if (atom[i].x + dx[atom[i].d] &gt;= 0 && atom[i].x + dx[atom[i].d] &lt;= 4000 && atom[i].y + dy[atom[i].d] &gt;= 0 && atom[i].y + dy[atom[i].d] &lt;= 4000) {\r\n            if (map[atom[i].x + dx[atom[i].d]][atom[i].y + dy[atom[i].d]] != 0) {\r\n                dc dc2; dc dc3;\r\n                dc2.num = i;\r\n                dc3.num = map[atom[i].x + dx[atom[i].d]][atom[i].y + dy[atom[i].d]];\r\n                dc2.discr = 1;\r\n                dc3.discr = 1;\r\n                trash.push(dc2);\r\n                trash.push(dc3);\r\n                map[atom[i].x][atom[i].y] = 0;\r\n                map[atom[i].x + dx[atom[i].d]][atom[i].y + dy[atom[i].d]] = i;\r\n                atom[i].x = atom[i].x + dx[atom[i].d];\r\n                atom[i].y = atom[i].y + dy[atom[i].d];\r\n            }\r\n            else {\r\n                map[atom[i].x + dx[atom[i].d]][atom[i].y + dy[atom[i].d]] = i;\r\n                map[atom[i].x][atom[i].y] = 0;\r\n                atom[i].x = atom[i].x + dx[atom[i].d];\r\n                atom[i].y = atom[i].y + dy[atom[i].d];\r\n            }\r\n        }\r\n        else {\r\n            map[atom[i].x][atom[i].y] = 0;\r\n            dc dc2;\r\n            dc2.num = i;\r\n            dc2.discr = 0;\r\n            trash.push(dc2);\r\n        }\r\n    }\r\n}\r\nvoid explo() {\r\n    int MX = 999;\r\n    while (!trash.empty()) {\r\n        if (trash.top().discr == 1) {\r\n            if (MX &gt; trash.top().num) {\r\n                MX = trash.top().num;\r\n                cnt += atom[trash.top().num].energy;\r\n                map[atom[trash.top().num].x][atom[trash.top().num].y] = 0;\r\n                atom.erase(atom.begin() + trash.top().num);\r\n                trash.pop();\r\n                N--;\r\n            }\r\n            else {\r\n                trash.pop();\r\n            }\r\n        }\r\n        else {\r\n            atom.erase(atom.begin() + trash.top().num);\r\n            trash.pop();\r\n            N--;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    scanf(&quot;%d&quot;, &T);\r\n    for (int o = 0; o &lt; T; o++) {\r\n        cnt = 0; atom.clear();\r\n        scanf(&quot;%d&quot;, &N);\r\n        lo2 lolo2;\r\n        lolo2.d = 0; lolo2.energy = 0; lolo2.x = 9999; lolo2.y = 9999;\r\n        atom.push_back(lolo2);\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            lo2 lolo;\r\n            scanf(&quot;%d %d %d %d&quot;, &lolo.x, &lolo.y, &lolo.d, &lolo.energy);\r\n            lolo.x = lolo.x * 2 + 2000; lolo.y = 2 * lolo.y + 2000;\r\n            map[lolo.x][lolo.y] = i;\r\n            atom.push_back(lolo);\r\n        }\r\n        for (int i = 0; i &lt; 4002; i++) {\r\n            go();\r\n            explo();\r\n        }\r\n        answer.push_back(cnt);\r\n    }\r\n    for (int i = 0; i &lt; T; i++) {\r\n        printf(&quot;#%d %dinha_univ&quot;, i + 1, answer[i]);\r\n    }\r\n}','2020-03-10 13:59:59',11),(12151526,'BJ',2579,'#include &lt;iostream&gt;<br />#include &lt;algorithm&gt;<br />using namespace std;<br />int N;<br />int map[301] = { 0, };<br />int dp[301][2] = { 0, };<br />int main() {<br />    cin &gt;&gt; N;<br />    for (int i = 1; i &lt;= N; i++) {<br />        cin &gt;&gt; map[i];<br />    }<br />    dp[1][0] = map[1];<br />    for (int i = 2; i &lt;= N; i++) {<br />        dp[i][1] = dp[i - 1][0] + map[i];<br />        dp[i][0] = max(dp[i - 2][1], dp[i-2][0]) + map[i];<br />    }<br />    cout &lt;&lt; max(dp[N][0], dp[N][1]);<br />}','2020-03-09 21:37:07',12),(12151526,'SW',5650,'#include&lt;iostream&gt;<br />#include&lt;queue&gt;<br />#include&lt;math.h&gt;<br />#include&lt;algorithm&gt;<br /><br />using namespace std;<br />int N = 0;<br />int map[100][100] = { 0, };<br />int T = 0;<br /><br />struct lo2 {<br />    int x;<br />    int y;<br />};<br /><br />queue&lt;lo2&gt; start;<br />vector&lt;lo2&gt; white6;<br />vector&lt;lo2&gt; white7;<br />vector&lt;lo2&gt; white8;<br />vector&lt;lo2&gt; white9;<br />vector&lt;lo2&gt; white10;<br />priority_queue&lt;int&gt; answer;<br />vector&lt;int&gt; answer2;<br /><br />int dx[4] = { -1,0,1,0 };<br />int dy[4] = { 0,1,0,-1 };<br />int cnt = 0;<br />int va_x = 0;<br />int va_y = 0;<br />int va2_x = 0;<br />int va2_y = 0;<br /><br />int go(int va) {<br />    int vava = 0;<br />    for (int i = 0; i &lt; 100; i++) {<br />        if (va2_x + dx[va] &gt;= 0 && va2_x + dx[va] &lt; N&&va2_y + dy[va] &gt;= 0 && va2_y + dy[va] &lt; N) {<br />            va2_x = va2_x + dx[va];<br />            va2_y = va2_y + dy[va];<br />            if (map[va2_x][va2_y] == 0) {<br />                if (va2_x == va_x && va2_y == va_y) {<br />                    vava = -1;<br />                    break;<br />                }<br />            }<br />            else {<br />                vava = map[va2_x][va2_y];<br />                if (vava &gt;= 1 && vava &lt;= 5) {<br />                    cnt++;<br />                }<br />                break;<br />            }<br />        }<br />        else if (va2_x+dx[va] == -1 || va2_y+dy[va] == -1 || va2_x+dx[va] == N || va2_y+dy[va] == N) {<br />            va2_x = va2_x + dx[va];<br />            va2_y = va2_y + dy[va];<br />            vava = 11;<br />            cnt++;<br />            break;<br />        }<br />    }<br />    return vava;<br />}<br /><br />int b1(int a) {<br />    if (a == 0)a = 2;<br />    else if (a == 1)a = 3;<br />    else if (a == 2)a = 1;<br />    else if (a == 3)a = 0;<br />    return a;<br />}<br />int b2(int a) {<br />    if (a == 0)a = 1;<br />    else if (a == 1)a = 3;<br />    else if (a == 2)a = 0;<br />    else if (a == 3)a = 2;<br />    return a;<br />}<br />int b3(int a) {<br />    if (a == 0)a = 3;<br />    else if (a == 1)a = 2;<br />    else if (a == 2)a = 0;<br />    else if (a == 3)a = 1;<br />    return a;<br />}<br />int b4(int a) {<br />    if (a == 0)a = 2;<br />    else if (a == 1)a = 0;<br />    else if (a == 2)a = 3;<br />    else if (a == 3)a = 1;<br />    return a;<br />}<br />int b5(int a) {<br />    if (a == 0)a = 2;<br />    else if (a == 1)a = 3;<br />    else if (a == 2)a = 0;<br />    else if (a == 3)a = 1;<br />    return a;<br />}<br />void white_whole(int a) {<br />    if (a == 6) {<br />        if (white6[0].x == va2_x && white6[0].y == va2_y) {<br />            va2_x = white6[1].x;<br />            va2_y = white6[1].y;<br />        }<br />        else {<br />            va2_x = white6[0].x;<br />            va2_y = white6[0].y;<br />        }<br />    }<br />    else if (a == 7) {<br />        if (white7[0].x == va2_x && white7[0].y == va2_y) {<br />            va2_x = white7[1].x;<br />            va2_y = white7[1].y;<br />        }<br />        else {<br />            va2_x = white7[0].x;<br />            va2_y = white7[0].y;<br />        }<br />    }<br />    else if (a == 8) {<br />        if (white8[0].x == va2_x && white8[0].y == va2_y) {<br />            va2_x = white8[1].x;<br />            va2_y = white8[1].y;<br />        }<br />        else {<br />            va2_x = white8[0].x;<br />            va2_y = white8[0].y;<br />        }<br />    }<br />    else if (a == 9) {<br />        if (white9[0].x == va2_x && white9[0].y == va2_y) {<br />            va2_x = white9[1].x;<br />            va2_y = white9[1].y;<br />        }<br />        else {<br />            va2_x = white9[0].x;<br />            va2_y = white9[0].y;<br />        }<br />    }<br />    else if (a == 10) {<br />        if (white10[0].x == va2_x && white10[0].y == va2_y) {<br />            va2_x = white10[1].x;<br />            va2_y = white10[1].y;<br />        }<br />        else {<br />            va2_x = white10[0].x;<br />            va2_y = white10[0].y;<br />        }<br />    }<br />}<br /><br />void pinball() {<br />    while (!start.empty()) {<br />        va_x = start.front().x;<br />        va_y = start.front().y;<br />        start.pop();<br />        for (int l = 0; l &lt; 4; l++) {<br />            int k = l;<br />            cnt = 0;<br />            va2_x = va_x;<br />            va2_y = va_y;<br />            int finish = 0;<br />            while (!(finish == -1)) {<br />                finish = go(k);<br />                if (finish == 1) {<br />                    k = b1(k);<br />                }<br />                else if (finish == 2) {<br />                    k = b2(k);<br />                }<br />                else if (finish == 3) {<br />                    k = b3(k);<br />                }<br />                else if (finish == 4) {<br />                    k = b4(k);<br />                }<br />                else if (finish == 5) {<br />                    k = b5(k);<br />                }<br />                else if (finish &gt; 5 && finish &lt; 11) {<br />                    white_whole(finish);<br />                }<br />                else if (finish == 11) {<br />                    k = b5(k);<br />                }<br />            }<br />            answer.push(cnt);<br />        }<br />    }<br />}<br /><br />int main() {<br />    cin &gt;&gt; T;<br />    for (int w = 0; w &lt; T; w++) {<br />        white6.clear();<br />        white7.clear();<br />        white8.clear();<br />        white9.clear();<br />        white10.clear();<br />        cnt = 0;<br />        va_x = 0;<br />        va_y = 0;<br />        va2_x = 0;<br />        va2_y = 0;<br />        N = 0;<br />        cin &gt;&gt; N;<br />        for (int i = 0; i &lt; N; i++) {<br />            for (int j = 0; j &lt; N; j++) {<br />                cin &gt;&gt; map[i][j];<br />                if (map[i][j] == 0) {<br />                    lo2 aaa;<br />                    aaa.x = i;<br />                    aaa.y = j;<br />                    start.push(aaa);<br />                }<br />                else if (map[i][j] == 6) {<br />                    lo2 aaa;<br />                    aaa.x = i;<br />                    aaa.y = j;<br />                    white6.push_back(aaa);<br />                }<br />                else if (map[i][j] == 7) {<br />                    lo2 aaa;<br />                    aaa.x = i;<br />                    aaa.y = j;<br />                    white7.push_back(aaa);<br />                }<br />                else if (map[i][j] == 8) {<br />                    lo2 aaa;<br />                    aaa.x = i;<br />                    aaa.y = j;<br />                    white8.push_back(aaa);<br />                }<br />                else if (map[i][j] == 9) {<br />                    lo2 aaa;<br />                    aaa.x = i;<br />                    aaa.y = j;<br />                    white9.push_back(aaa);<br />                }<br />                else if (map[i][j] == 10) {<br />                    lo2 aaa;<br />                    aaa.x = i;<br />                    aaa.y = j;<br />                    white10.push_back(aaa);<br />                }<br />            }<br />        }<br />        pinball();<br />        answer2.push_back(answer.top());<br />        while (!answer.empty()) {<br />            answer.pop();<br />        }<br />    }<br />    for (int i = 0; i &lt; T; i++) {<br />        cout &lt;&lt; &quot;#&quot; &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; answer2[i] &lt;&lt; endl;<br />    }<br />}','2020-03-09 21:37:26',13),(12151636,'SW',5650,'#include &lt;iostream&gt;<br />#include &lt;queue&gt;<br />#include &lt;vector&gt;<br />using namespace std;<br /><br />int N;<br />int map[101][101];<br />int first_i, first_j;<br /><br />int dy[] = { -1,1,0,0 };<br />int dx[] = { 0,0,1,-1 };<br />//좌측, 우측, 아래,위<br /><br />int cnt;<br />priority_queue&lt;int&gt; pq;<br />vector&lt;pair&lt;int, int&gt;&gt; v[11];<br /><br />void detect(int x, int y, int flow);<br /><br />/*<br />void change_position(int nextx, int nexty, int flow) {<br />    if (v[map[nextx][nexty]][0].first == nextx && v[map[nextx][nexty]][0].second == nexty)<br />        detect(v[map[nextx][nexty]][1].first, v[map[nextx][nexty]][1].second, flow);<br />    else <br />        detect(v[map[nextx][nexty]][0].first, v[map[nextx][nexty]][0].second, flow);<br />}<br />*/<br /><br />void change_position(int nextx, int nexty, int flow) {<br />    for (int i = 0; i &lt; N; i++) {<br />        for (int j = 0; j &lt; N; j++) {<br />            if (map[nextx][nexty] == map[i][j]) {<br />                if (nextx == i && nexty == j)<br />                    continue;<br />                else<br />                    detect(i, j, flow);<br />            }<br />        }<br />    }<br />}<br /><br />int change_flow(int value,int flow) {<br />    if (value == 0) {<br />        if (flow == 0)<br />            return 1;<br />        else if (flow == 1)<br />            return 0;<br />        else if (flow == 2)<br />            return 3;<br />        else if (flow == 3)<br />            return 2;<br />    }<br />    else if (value == 1) {<br />        if (flow == 0)<br />            return 3;<br />        else if (flow == 1)<br />            return 0;<br />        else if (flow == 2)<br />            return 1;<br />        else if (flow == 3)<br />            return 2;<br />    }<br />    else if (value == 2) {<br />        if (flow == 0)<br />            return 2;<br />        else if (flow == 1)<br />            return 0;<br />        else if (flow == 2)<br />            return 3;<br />        else if (flow == 3)<br />            return 1;<br />    }<br />    else if (value == 3) {<br />        if (flow == 0)<br />            return 1;<br />        else if (flow == 1)<br />            return 2;<br />        else if (flow == 2)<br />            return 3;<br />        else if (flow == 3)<br />            return 0;<br />    }<br />    else if (value == 4) {<br />        if (flow == 0)<br />            return 1;<br />        else if (flow == 1)<br />            return 3;<br />        else if (flow == 2)<br />            return 0;<br />        else if (flow == 3)<br />            return 2;<br />    }<br />    else if (value == 5) {<br />        if (flow == 0)<br />            return 1;<br />        else if (flow == 1)<br />            return 0;<br />        else if (flow == 2)<br />            return 3;<br />        else if (flow == 3)<br />            return 2;<br />    }<br />}<br /><br />void detect(int x, int y,int flow) {<br />    int nextx = dx[flow] + x;<br />    int nexty = dy[flow] + y;<br /><br />    if (nextx &gt;= 0 && nexty &gt;= 0 && nextx &lt; N && nexty &lt; N) {<br />        if (map[nextx][nexty] == 0) {<br />            if (nextx == first_i && nexty == first_j)<br />                return;<br />            else {<br />                    detect(nextx, nexty, flow);<br />            }<br />        }<br />        else if ((1 &lt;= map[nextx][nexty]) && (map[nextx][nexty] &lt;= 5)) {<br />            if (nextx == first_i && nexty == first_j)<br />                return;<br />            else {<br />                cnt = cnt + 1;<br />                int flows = change_flow(map[nextx][nexty], flow);<br />                detect(nextx, nexty, flows);<br />            }<br />        }<br />        else if ((6 &lt;= map[nextx][nexty]) && (map[nextx][nexty] &lt;= 10)) {<br />            if (nextx == first_i && nexty == first_j)<br />                return;<br />            else<br />                change_position(nextx, nexty, flow);<br />        }<br />        else if (map[nextx][nexty] == -1)<br />            return;<br />    }<br />    else{<br />        cnt = cnt + 1;<br />        if (flow == 0)<br />            detect(nextx, nexty, 1);<br />        else if (flow == 1)<br />            detect(nextx, nexty, 0);<br />        else if (flow == 2)<br />            detect(nextx, nexty, 3);<br />        else if (flow == 3)<br />            detect(nextx, nexty, 2);<br />    }<br />}<br /><br />void start(int x,int y) {<br />    for (int i = 0; i &lt; 4; i++) {<br />        cnt = 0;<br />        detect(x,y, i);<br />        pq.push(cnt);<br />    }<br />}<br /><br />int main() {<br />    int testcase;<br />    int value;<br />    cin &gt;&gt; testcase;<br />    for (int t = 0; t &lt; testcase; t++) {<br />        cin &gt;&gt; N;<br />        for (int i = 0; i &lt; 11; i++)<br />            v[i].clear();<br />        while (!pq.empty())<br />            pq.pop();<br />        for (int i = 0; i &lt; N; i++)<br />            for (int j = 0; j &lt; N; j++)<br />                map[i][j] = 0;<br /><br />        for (int i = 0; i &lt; N; i++)<br />            for (int j = 0; j &lt; N; j++) {<br />                cin &gt;&gt; value;<br />                map[i][j] = value;<br />                if ((6 &lt;= map[i][j]) && (map[i][j] &lt;= 10))<br />                    v[map[i][j]].push_back(make_pair(i, j));<br />            }<br />        for (int i = 0; i &lt; N; i++)<br />            for (int j = 0; j &lt; N; j++) {<br />                if (map[i][j] == 0) {<br />                    first_i = i;<br />                    first_j = j;<br />                    start(i,j);<br />                }<br />            }<br />        cout &lt;&lt;&quot;#&quot;&lt;&lt;t+1&lt;&lt;&quot; &quot;&lt;&lt; pq.top() &lt;&lt; endl;<br />    }<br />}','2020-03-09 21:37:48',14),(12151526,'BJ',9251,'#include&lt;iostream&gt;<br />#include&lt;vector&gt;<br />#include&lt;queue&gt;<br />#include&lt;math.h&gt;<br />#include&lt;algorithm&gt;<br />#include&lt;string&gt;<br />using namespace std;<br /><br />struct lo {<br />    int num;<br />    int cnt;<br />};<br />lo dp[1000];<br />string st, st2, st3;<br />int main() {<br />    st3 = &quot;a&quot;;<br />    cin &gt;&gt; st;<br />    cin &gt;&gt; st2;<br />    st = st3 + st;<br />    st2 = st3 + st2;<br />    for (int i = 1; i &lt; st.size(); i++) {<br />        int va = 0, va2 = 0;<br />        for (int j = 1; j &lt; st2.size(); j++) {<br />            if (st[i] == st2[j] && va != i) {<br />                if (dp[j].cnt &lt;= va2) {<br />                    dp[j].num = i; dp[j].cnt = va2 + 1;<br />                    va = dp[j].num; va2 = dp[j].cnt;<br />                }<br />                else {<br />                    va = dp[j].num; va2 = dp[j].cnt;<br />                }<br />            }<br />            else {<br />                if (dp[j].cnt &gt;= va2) {<br />                    va = dp[j].num; va2 = dp[j].cnt;<br />                }<br />                else {<br />                    dp[j].num = va; dp[j].cnt = va2;<br />                }<br />            }<br />        }<br />    }<br />    cout &lt;&lt; dp[st2.size() - 1].cnt;<br />}','2020-03-09 21:38:00',15),(12151526,'BJ',1463,'#include &lt;iostream&gt;<br />#include &lt;queue&gt;<br />using namespace std;<br /><br />int co[1000001] = { 0, };<br />int N;<br />int va = 0;<br />int change = 0;<br />queue&lt;int&gt; vava;<br />void test() {<br />    int MAX = vava.size();<br />    va++;<br />    for (int i = 0; i &lt; MAX; i++) {<br />        int b = vava.front() * 3;<br />        int c = vava.front() * 2;<br />        int d = vava.front() + 1;<br />        if (b == N || c == N || d == N) {<br />            change = 1;<br />            break;<br />        }<br />        if (b &lt;= 1000000) {<br />            if (co[b] == 0) {<br />                co[b] = 1;<br />                vava.push(b);<br />            }<br />        }<br />        if (c &lt;= 1000000) {<br />            if (co[c] == 0) {<br />                co[c] = 1;<br />                vava.push(c);<br />            }<br />        }<br />        if (d &lt;= 1000000) {<br />            if (co[d] == 0) {<br />                co[d] = 1;<br />                vava.push(d);<br />            }<br />        }<br />        vava.pop();<br />    }<br />    if (change == 0) {<br />        test();<br />    }<br />}<br /><br /><br />int main() {<br />    cin &gt;&gt; N;<br />    vava.push(1);<br />    if (N != 1) {<br />        test();<br />    }<br />    cout &lt;&lt; va;<br />}','2020-03-09 21:38:22',16),(12151636,'BJ',1463,'#include &lt;iostream&gt;<br />#include &lt;queue&gt;<br />#include &lt;algorithm&gt;<br />using namespace std;<br /><br />struct value {<br />    int x;<br />    int count;<br />};<br />queue&lt;value&gt; q; value v;<br />void first(value x) {<br />    value v1;<br />    if (x.x % 3 == 0) {<br />        v1.x = x.x / 3;<br />        v1.count = x.count + 1;<br />        q.push(v1);<br />    }<br />}<br />void second(value x) {<br />    value v2;<br />    if (x.x % 2 == 0) {<br />        v2.x = x.x / 2;<br />        v2.count = x.count + 1;<br />        q.push(v2);<br />    }<br />}<br />void third(value x) {<br />    value v3;<br />    if (x.x - 1 &gt; 0) {<br />        v3.x = x.x - 1;<br />        v3.count = x.count + 1;<br />        q.push(v3);<br />    }<br />}<br /><br />int main() {<br />    int N;<br />    cin &gt;&gt; N;<br />    v.x = N;<br />    v.count = 0;<br />    q.push(v);<br />    int mini = 999999999;<br />    while (!q.empty()) {<br />        int x = q.front().x;<br /><br />        if (x==1) {<br />            //cout &lt;&lt; mini &lt;&lt; endl;<br />            mini = min(q.front().count, mini);<br />            break;<br />        }<br />        first(q.front());<br />        second(q.front());<br />        third(q.front());<br />        q.pop();<br />    }<br />    cout &lt;&lt; mini &lt;&lt; endl;<br />}','2020-03-09 21:40:57',17),(12151601,'BJ',10844,'#include &lt;iostream&gt;<br />using namespace std;<br /><br />#define mod 1000000000<br />int d[100][11];<br /><br />int main() {<br />    int N;<br />    cin &gt;&gt; N;<br />    for (int i = 1; i &lt; 10; i++)<br />        d[0][i] = 1;<br />    d[0][10] = 9;<br />    for (int i = 1; i &lt; N; i++) {<br />        for (int j = 0; j &lt; 10; j++) {<br />            if (j == 0)<br />                d[i][j] = d[i - 1][1];<br />            else if (j == 9)<br />                d[i][j] = d[i - 1][8];<br />            else<br />                d[i][j] = (d[i - 1][j - 1] + d[i - 1][j + 1]) % mod;<br />            d[i][10] += d[i][j];<br />            d[i][10] %= mod;<br />        }<br />    }<br />    cout &lt;&lt; d[N - 1][10];<br />}','2020-03-09 21:53:33',18),(12151636,'BJ',2579,'#include &lt;iostream&gt;<br />#include &lt;algorithm&gt;<br />using namespace std;<br /><br />long long arr[400];<br />long long arr1[400];<br />int N;<br /><br />void start() {<br />    arr1[0] = arr[0];<br />    arr1[1] = arr[0] + arr[1];<br />    arr1[2] = max(arr[0] + arr[2], arr[1] + arr[2]);<br />    for (int i = 3; i &lt; N; i++)<br />        arr1[i] = max(arr1[i - 2] + arr[i], arr1[i - 3] + arr[i - 1] + arr[i]);<br />}<br /><br />int main() {<br />    int value;<br />    cin &gt;&gt; N;<br />    for (int i = 0; i &lt; N; i++) {<br />        cin &gt;&gt; value;<br />        arr[i] = value;<br />    }<br />    start();<br />    cout &lt;&lt; arr1[N - 1] &lt;&lt; endl;<br />}<br />','2020-03-09 21:55:21',19),(12151526,'BJ',6603,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nstruct lo {\r\n    int num;\r\n    vector&lt;int&gt; ve;\r\n};\r\n\r\nvector&lt;lo&gt; va;\r\n\r\nvoid lotto(int a, vector&lt;int&gt; num, vector&lt;int&gt; num2) {\r\n    vector&lt;int&gt; num3 = num;\r\n    vector&lt;int&gt; num4 = num2;\r\n    if (a == 6) {\r\n        for (int i = 0; i &lt; 6; i++) {\r\n            printf(&quot;%d &quot;, num2[i]);\r\n        }\r\n        printf(&quot;*&quot;);\r\n    }\r\n    else {\r\n        while (num3.size() &gt; 0) {\r\n            num4 = num2;\r\n            num4.push_back(num3[0]);\r\n            num3.erase(num3.begin() + 0);\r\n            lotto(a + 1, num3, num4);\r\n        }\r\n    }\r\n}\r\n\r\nint  main() {\r\n    for (;;) {\r\n        lo lo2;\r\n        scanf(&quot;%d&quot;, &lo2.num);\r\n        if (lo2.num == 0) break;\r\n        for (int i = 0; i &lt; lo2.num; i++) {\r\n            int a;\r\n            scanf(&quot;%d&quot;, &a);\r\n            lo2.ve.push_back(a);\r\n        }\r\n        va.push_back(lo2);\r\n    }\r\n    for (int i = 0; i &lt; va.size(); i++) {\r\n        lo lolo3; vector&lt;int&gt; res;\r\n        lotto(0, va[i].ve, res);\r\n        printf(&quot;*&quot;);\r\n    }\r\n}','2020-03-09 23:28:21',20),(12181853,'BJ',2156,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n#define MAX 10001\r\n\r\nint N; // 포도잔의 개수\r\nint GRAPE[MAX];\r\nint GLASS[MAX];\r\n\r\nint MAXgrape()\r\n{\r\n    GLASS[1] = GRAPE[1];\r\n    GLASS[2] = GRAPE[1] + GRAPE[2];\r\n\r\n    if (N == 1)\r\n        return GLASS[1];\r\n    else if (N == 2)\r\n        return GLASS[2];\r\n    else\r\n    {\r\n        for (int i = 3; i &lt;= N; i++)\r\n        {\r\n            GLASS[i] = max(GLASS[i - 1], max(GLASS[i - 2] + GRAPE[i], GLASS[i - 3] + GRAPE[i - 1] + GRAPE[i]));\r\n        }\r\n    }\r\n\r\n    return GLASS[N];\r\n}\r\n\r\nint main(void)\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; GRAPE[i];\r\n    }\r\n\r\n    cout &lt;&lt; MAXgrape() &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-03-09 23:28:24',21),(12181853,'BJ',6603,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\n#define MAX 6\r\n\r\nint k; // K개의 수를 고르기 위한 수\r\nint LOTTO[MAX]; // K개의 선택된 숫자들 중 출력될 수 있는 경우의 수를 담는 배열\r\nint S[13]; // K개의 선택된 숫자들을 오름차순으로 담아놓은 배열\r\n\r\n// 선택된 숫자들을 오름차순으로 담아놓은 배열 -&gt; index1\r\n// 선택된 숫자들을 통해 경우의 수를 담는 배열 -&gt; index2\r\nvoid LOTTO_ASSIGN(int index1, int index2)\r\n{\r\n    if (index2 == MAX) // 경우의 수를 담는 배열의 index가 모두 차게 되었다면\r\n    {\r\n        for (int i = 0; i &lt; MAX; i++)\r\n        {\r\n            cout &lt;&lt; LOTTO[i] &lt;&lt; &quot; &quot;; // 모든 경우의 수를 출력해버리자!\r\n        }\r\n        cout &lt;&lt; endl;\r\n        return;\r\n    }\r\n\r\n    for (int i = index1; i &lt; k; i++) \r\n    {\r\n        LOTTO[index2] = S[i];\r\n        LOTTO_ASSIGN(i + 1, index2 + 1);\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n    while (1)\r\n    {\r\n        cin &gt;&gt; k;\r\n        if (k == 0)\r\n            break;\r\n\r\n        for (int i = 0; i &lt; k; i++)\r\n        {\r\n            cin &gt;&gt; S[i]; // 49개의 숫자 중 집합 S를 고르기 위해 선택된 수\r\n        }\r\n\r\n        LOTTO_ASSIGN(0, 0);\r\n        cout &lt;&lt; endl;\r\n    }\r\n    return 0;\r\n}','2020-03-09 23:34:04',22),(12181853,'BJ',11724,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\n#define MAX 1001\r\n\r\nint N;\r\nint M;\r\nint U;\r\nint V;\r\n\r\nvector&lt;int&gt; GRAPH[MAX];\r\nbool visited[MAX];\r\n\r\nvoid DFS(int node)\r\n{\r\n    visited[node] = true;\r\n\r\n    for (int i = 0; i &lt; GRAPH[node].size(); i++)\r\n    {\r\n        int next = GRAPH[node][i];\r\n\r\n        if (!visited[next])\r\n            DFS(next);\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n\r\n    for (int i = 0; i &lt; M; i++)\r\n    {\r\n        cin &gt;&gt; U &gt;&gt; V;\r\n    \r\n        GRAPH[U].push_back(V);\r\n        GRAPH[V].push_back(U);\r\n    }\r\n\r\n    int cnt = 0;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        if (!visited[i])\r\n        {\r\n            DFS(i);\r\n            cnt++;\r\n        }\r\n    }\r\n    cout &lt;&lt; cnt &lt;&lt; endl;\r\n    return 0;\r\n}','2020-03-09 23:34:26',23),(12151551,'SW',5648,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;stdlib.h&gt;\r\nusing namespace std;\r\n\r\ntypedef struct in {\r\n    int x;\r\n    int y;\r\n    int direction;\r\n    int k;\r\n    bool l;\r\n}info;\r\n\r\nint dx[] = { 0,0,-1,1 };\r\nint dy[] = { 1,-1,0,0 };\r\nint arr[4001][4001] = { 0 };\r\n\r\nvector&lt;info&gt; v;\r\nin inner;\r\nint result = 0;\r\n\r\nbool die() {\r\n    for (int i = 0; i &lt; v.size(); i++) {\r\n        if (v[i].l == true)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid move() {\r\n    while (die() != true) {\r\n        for (int i = 0; i &lt; v.size(); i++) {\r\n            if (v[i].l == false)\r\n                continue;\r\n            int nextx = v[i].x + dx[v[i].direction];\r\n            int nexty = v[i].y + dy[v[i].direction];\r\n            if (nextx &gt;= 0 && nextx &lt;= 4000 && nexty &gt;= 0 && nexty &lt;= 4000) {\r\n                arr[v[i].x][v[i].y] = 0;\r\n                arr[nextx][nexty]++;\r\n                v[i].x = nextx;\r\n                v[i].y = nexty;\r\n            }\r\n            else {\r\n                arr[v[i].x][v[i].y] = 0;\r\n                v[i].l = false;\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; v.size(); i++) {\r\n            if (v[i].l == false)\r\n                continue;\r\n            if (arr[v[i].x][v[i].y] &gt;= 2) {\r\n                for (int j = i + 1; j &lt; v.size(); j++) {\r\n                    if (v[j].l == false)\r\n                        continue;\r\n                    if (v[i].l == true && v[j].l == true && v[i].x == v[j].x && v[i].y==v[j].y) {\r\n                        result = result + v[j].k;\r\n                        v[j].l = false;\r\n                    }\r\n                }\r\n                if (v[i].l == true) {\r\n                    result = result + v[i].k;\r\n                    v[i].l = false;\r\n                    arr[v[i].x][v[i].y] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int q = 0; q &lt; T; q++) {\r\n        int N;\r\n        cin &gt;&gt; N;\r\n        for (int i = 0; i &lt; N; i++) {\r\n            int a, b, c, d;\r\n            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\r\n            inner.x = (a + 1000) * 2;\r\n            inner.y = (b + 1000) * 2;\r\n            inner.direction = c;\r\n            inner.k = d;\r\n            inner.l = true;\r\n            arr[(a + 1000) * 2][(b + 1000) * 2]++;\r\n            v.push_back(inner);\r\n        }\r\n        move();\r\n        cout &lt;&lt; &quot;#&quot;&lt;&lt;q+1&lt;&lt;&quot; &quot;&lt;&lt; result &lt;&lt; endl;\r\n        result = 0;\r\n        while (!v.empty())\r\n            v.pop_back();\r\n    }\r\n\r\n}','2020-03-10 00:49:26',24),(12151551,'SW',2382,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\ntypedef struct in {\r\n    int x;\r\n    int y;\r\n    int num;\r\n    int dir;\r\n}info;\r\n\r\npair&lt;int, int&gt; arr[101][101];\r\nvector&lt;info&gt; v;\r\nint N, M, K;\r\n\r\nint dx[] = { -1,1,0,0 };\r\nint dy[] = { 0,0,-1,1 };\r\n\r\nvoid move() {\r\n    for (int q = 0; q &lt; M; q++) {\r\n        for (int i = 0; i &lt; v.size(); i++) {\r\n            if (v[i].num == 0) continue;\r\n            int nextx = v[i].x + dx[v[i].dir];\r\n            int nexty = v[i].y + dy[v[i].dir];\r\n            if (nextx &gt;= 1 && nextx &lt;= N - 2 && nexty &gt;= 1 && nexty &lt;= N - 2) {\r\n                arr[v[i].x][v[i].y].first--;\r\n                if (arr[v[i].x][v[i].y].first &lt;= 0)\r\n                    arr[v[i].x][v[i].y].first = 0;\r\n                v[i].x = nextx;\r\n                v[i].y = nexty;\r\n                arr[nextx][nexty].first++;\r\n            }\r\n            else {\r\n                //v[i].x = v[i].x + dx[v[i].dir];\r\n                //v[i].y = v[i].y + dy[v[i].dir];\r\n                arr[v[i].x][v[i].y].first--;\r\n                if (arr[v[i].x][v[i].y].first &lt;= 0)\r\n                    arr[v[i].x][v[i].y].first = 0;\r\n                v[i].x = nextx;\r\n                v[i].y = nexty;\r\n                arr[nextx][nexty].first++;\r\n                if (v[i].dir == 0) v[i].dir = 1;\r\n                else if (v[i].dir == 1) v[i].dir = 0;\r\n                else if (v[i].dir == 2) v[i].dir = 3;\r\n                else if (v[i].dir == 3) v[i].dir = 2;\r\n                v[i].num = v[i].num / 2;\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; v.size(); i++) {\r\n            if (v[i].num == 0) continue;\r\n            int x = v[i].x;\r\n            int y = v[i].y;\r\n            if (arr[x][y].first &gt;=2) {\r\n                int sum = 0;\r\n                int di = 0;\r\n                int check = 0;\r\n                int m = 0;\r\n                for (int j = 0; j &lt; v.size(); j++) {\r\n                    if (v[j].x == x && v[j].y == y) {\r\n                        sum = sum + v[j].num;\r\n                        if (m &lt;= v[j].num) {\r\n                            m = v[j].num;\r\n                            di = v[j].dir;\r\n                        }\r\n                    }\r\n                }\r\n                for (int j = 0; j &lt; v.size(); j++) {\r\n                    if (v[j].x == x && v[j].y == y && check == 0) {\r\n                        v[j].num = sum;\r\n                        v[j].dir = di;\r\n                        check = 1;\r\n                    }\r\n                    else if (v[j].x == x && v[j].y == y && check == 1)\r\n                        v[j].num = 0;\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int q = 0; q &lt; T; q++) {\r\n        cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n        for (int i = 0; i &lt;= N; i++) {\r\n            for (int j = 0; j &lt;= N; j++) {\r\n                arr[i][j].first = 0;\r\n            }\r\n        }\r\n        while (!v.empty())\r\n            v.pop_back();\r\n        for (int i = 0; i &lt; K; i++) {\r\n            int a, b, c, d;\r\n            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\r\n            in information;\r\n            arr[a][b].first++;\r\n            information.x = a;\r\n            information.y = b;\r\n            information.num = c;\r\n            information.dir = d - 1;\r\n            v.push_back(information);\r\n        }\r\n        move();\r\n        int result = 0;\r\n        for (int i = 0; i &lt; v.size(); i++)\r\n            result = result + v[i].num;\r\n        cout &lt;&lt; &quot;#&quot;&lt;&lt;q+1&lt;&lt;&quot; &quot;&lt;&lt;result &lt;&lt; endl;\r\n    }\r\n}','2020-03-10 00:52:26',25),(12151636,'BJ',2156,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nlong long grape[10001];\r\nlong long dp[10001];\r\n\r\nvoid start() {\r\n    dp[0] = grape[0];\r\n    dp[1] = grape[0] + grape[1];\r\n    dp[2] = max(grape[0] + grape[2], grape[1] + grape[2]);\r\n    dp[2] = max(dp[2], dp[1]);\r\n    for (int i = 3; i &lt; N; i++) {\r\n        dp[i] = max(dp[i - 2] + grape[i], dp[i - 3] + grape[i-1] + grape[i]);\r\n        dp[i] = max(dp[i], dp[i - 1]);\r\n    }\r\n}\r\n\r\nint main() {\r\n    int value;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; value;\r\n        grape[i] = value;\r\n    }\r\n    start();\r\n    cout &lt;&lt; dp[N-1] &lt;&lt; endl;\r\n}','2020-03-10 00:52:39',26),(12151551,'BJ',9251,'#include &lt;iostream&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;cstdio&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;string.h&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nchar s1[1002] = { 0 }; \r\nchar s2[1002] = { 0 };\r\nint result[1002][1002] = { 0 };\r\nvector&lt;char&gt; v;\r\n\r\nint checksize(char * check) {\r\n    int s = 0;\r\n    for (int i = 1; i &lt; 1000; i++) {\r\n        if (check[i] == 0)\r\n            break;\r\n        s++;\r\n    }\r\n    return s;\r\n}\r\n\r\nint main() {\r\n    int ma = 0;\r\n    scanf(&quot;%s %s&quot;, s1+1, s2+1);\r\n    int size1 = checksize(s1);\r\n    int size2 = checksize(s2);\r\n    for (int i = 1; i &lt;= size1; i++) {\r\n        for (int j = 1; j &lt;= size2; j++) {\r\n            if (s1[i] == s2[j]) {\r\n                result[i][j] = result[i - 1][j - 1] + 1;\r\n            }\r\n            else\r\n                result[i][j] = max(result[i][j - 1],result[i-1][j]);\r\n        }\r\n    }\r\n    int ou = 0;\r\n    for (int i = 0; i &lt;= size1; i++) {\r\n        for (int j = 0; j &lt;= size2; j++) {\r\n            ou = max(ou, result[i][j]);\r\n        }\r\n    }\r\n    cout &lt;&lt; ou &lt;&lt; endl;\r\n}\r\n','2020-03-10 00:53:30',27),(12151551,'BJ',10844,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint arr[101][10] = { 0 };\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;10; i++)\r\n        arr[1][i] = 1;\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        for (int j = 0; j &lt; 10; j++) {\r\n            if (j == 0)\r\n                arr[i][j] = arr[i - 1][j + 1] % 1000000000;\r\n            else if (j == 9)\r\n                arr[i][j] = arr[i - 1][j - 1] % 1000000000;\r\n            else\r\n                arr[i][j] = (arr[i - 1][j - 1] + arr[i - 1][j + 1]) % 1000000000;\r\n        }\r\n    }\r\n    int sum = 0;\r\n    for (int i = 0; i &lt;10; i++) {\r\n        sum = (sum+arr[N][i]) % 1000000000;\r\n    }\r\n    cout &lt;&lt; sum &lt;&lt; endl;\r\n}','2020-03-10 00:54:33',28),(12151551,'BJ',11054,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr1[4][1000] = { 0 };\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int a;\r\n        cin &gt;&gt; a;\r\n        arr1[0][i] = a;\r\n    }\r\n    arr1[1][0] = 1;\r\n    arr1[2][N - 1] = 1;\r\n    for (int i = 1; i &lt; N; i++) {\r\n        for (int j = i - 1; j &gt;= 0; j--) {\r\n            if (arr1[0][i] &gt; arr1[0][j]) {\r\n                arr1[1][i] = max(arr1[1][i], arr1[1][j] + 1);\r\n            }\r\n            else if (arr1[0][i] == arr1[0][j]) {\r\n                arr1[1][i] = max(arr1[1][i], arr1[1][j]);\r\n            }\r\n        }\r\n        if (arr1[1][i] == 0)\r\n            arr1[1][i] = 1;\r\n    }\r\n    for (int i = N-2; i &gt;= 0; i--) {\r\n        for (int j = i + 1; j &lt;N; j++) {\r\n            if (arr1[0][i] &gt; arr1[0][j]) {\r\n                arr1[2][i] = max(arr1[2][i], arr1[2][j] + 1);\r\n            }\r\n            else if (arr1[0][i] == arr1[0][j]) {\r\n                arr1[2][i] = max(arr1[2][i], arr1[2][j]);\r\n            }\r\n        }\r\n        if (arr1[2][i] == 0)\r\n            arr1[2][i] = 1;\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        arr1[3][i] = arr1[1][i] + arr1[2][i] -1;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        result = max(result, arr1[3][i]);\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}','2020-03-10 00:55:19',29),(12151526,'SW',2382,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n\r\nusing namespace std;\r\nstruct lo {\r\n    int x;\r\n    int y;\r\n    int num;\r\n    int d;\r\n    int max_num;\r\n};\r\nint N, M, K;\r\nint map[100][100];\r\npriority_queue&lt;int&gt; trash;\r\nvector&lt;lo&gt; loca;\r\nint dx[4] = { -1,1,0,0 };\r\nint dy[4] = { 0,0,-1,1 };\r\nint cha(int a) {\r\n    if (a == 0) a = 1;\r\n    else if (a == 1) a = 0;\r\n    else if (a == 2) a = 3;\r\n    else if (a == 3) a = 2;\r\n    return a;\r\n}\r\nvoid micro() {\r\n    for (int i = 1; i &lt; loca.size(); i++) {\r\n        map[loca[i].x][loca[i].y] = i;\r\n        loca[i].max_num = loca[i].num;\r\n    }\r\n    for (int i = 1; i &lt; loca.size(); i++) {\r\n        int va = loca[i].x + dx[loca[i].d];\r\n        int va2 = loca[i].y + dy[loca[i].d];\r\n        if (va == 0 || va == N - 1 || va2 == 0 || va2 == N - 1) {\r\n            loca[i].num = loca[i].num / 2;\r\n            loca[i].max_num = loca[i].num;\r\n            if (map[loca[i].x][loca[i].y] == i) {\r\n                map[loca[i].x][loca[i].y] = 0;\r\n            }\r\n            loca[i].x = va; loca[i].y = va2;\r\n            map[loca[i].x][loca[i].y] = i;\r\n            loca[i].d = cha(loca[i].d);\r\n            if (loca[i].num == 0)trash.push(i);\r\n        }\r\n        else {\r\n            if (map[va][va2] == 0) {\r\n                if (map[loca[i].x][loca[i].y] == i) {\r\n                    map[loca[i].x][loca[i].y] = 0;\r\n                }\r\n                loca[i].x = va; loca[i].y = va2;\r\n                map[loca[i].x][loca[i].y] = i;\r\n            }\r\n            else {\r\n                if (map[va][va2] &lt; i) {\r\n                    if (loca[map[va][va2]].max_num &lt; loca[i].max_num) {\r\n                        trash.push(map[va][va2]);\r\n                        loca[i].num += loca[map[va][va2]].num;\r\n                        if (map[loca[i].x][loca[i].y] == i) {\r\n                            map[loca[i].x][loca[i].y] = 0;\r\n                        }\r\n                        loca[i].x = va; loca[i].y = va2;\r\n                        map[loca[i].x][loca[i].y] = i;\r\n                    }\r\n                    else if (loca[map[va][va2]].max_num &gt; loca[i].max_num) {\r\n                        trash.push(i);\r\n                        if (map[loca[i].x][loca[i].y] == i) {\r\n                            map[loca[i].x][loca[i].y] = 0;\r\n                        }\r\n                        loca[map[va][va2]].num += loca[i].num;\r\n                    }\r\n                }\r\n                else {\r\n                    if (map[loca[i].x][loca[i].y] == i) {\r\n                        map[loca[i].x][loca[i].y] = 0;\r\n                    }\r\n                    loca[i].x = va; loca[i].y = va2;\r\n                    map[loca[i].x][loca[i].y] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    while (!trash.empty()) {\r\n        loca.erase(loca.begin() + trash.top());\r\n        trash.pop();\r\n    }\r\n}\r\n\r\nint main() {\r\n    int T = 0;\r\n    cin &gt;&gt; T;\r\n    for (int p = 0; p &lt; T; p++) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            for (int j = 0; j &lt; 100; j++) {\r\n                map[i][j] = 0;\r\n            }\r\n        }\r\n        N = 0; M = 0; K = 0;\r\n        loca.clear();\r\n        cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n        lo lo3;\r\n        lo3.x = 0; lo3.y = 0; lo3.num = 0; lo3.d = 0; lo3.max_num = 0;\r\n        loca.push_back(lo3);\r\n        for (int i = 1; i &lt;= K; i++) {\r\n            lo lo2;\r\n            cin &gt;&gt; lo2.x &gt;&gt; lo2.y &gt;&gt; lo2.num &gt;&gt; lo2.d;\r\n            lo2.d--;\r\n            lo2.max_num = lo2.num;\r\n            loca.push_back(lo2);\r\n            map[lo2.x][lo2.y] = i;\r\n        }\r\n        for (int i = 0; i &lt; M; i++) {\r\n            micro();\r\n        }\r\n        int cnt = 0;\r\n        for (int i = 1; i &lt; loca.size(); i++) {\r\n            cnt += loca[i].num;\r\n        }\r\n        cout &lt;&lt; &quot;#&quot; &lt;&lt; p + 1 &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl;\r\n    }\r\n}','2020-03-10 14:01:00',30),(12151526,'BJ',2156,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint N;\r\nint map[10001] = { 0, };\r\nint dp[10001][3] = { 0, };\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; map[i];\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        dp[i + 1][1] = dp[i][0] + map[i + 1];\r\n        dp[i + 1][2] = dp[i][1] + map[i + 1];\r\n        dp[i + 1][0] = max(dp[i][0], max(dp[i][1], dp[i][2]));\r\n    }\r\n    cout &lt;&lt; max(dp[N][0], max(dp[N][1], dp[N][2]));\r\n}','2020-03-10 14:03:14',31),(12161783,'BJ',1463,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#include &lt;algorithm&gt;\r\n\r\nint Dp[1000001];\r\n \r\n\r\nint main() {\r\n\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n\r\n    Dp[1] = 0;\r\n\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        Dp[i] = Dp[i - 1] + 1;\r\n        if (i % 2 == 0) {\r\n            Dp[i] = min(Dp[i], Dp[i / 2] + 1);\r\n        }\r\n        if (i % 3 == 0) {\r\n            Dp[i] = min(Dp[i], Dp[i / 3] + 1);\r\n        }\r\n    }\r\n     cout&lt;&lt; Dp[N];\r\n     return 0;\r\n}','2020-03-10 15:35:08',32),(12161783,'BJ',2156,'#include &lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n\r\n    int N;\r\n    int arr[10001] ;\r\n    int Dp[10001];\r\n\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; arr[i];\r\n    }\r\n\r\n    for (int i = 1; i &lt; 3 && i &lt;= N; i++) {\r\n        if (i==1)\r\n            Dp[i] = arr[i];\r\n        else\r\n            Dp[i] = arr[i]+ arr[i - 1];\r\n    }\r\n\r\n    for (int i = 3; i &lt;= N; i++) {\r\n    Dp[i] = max(arr[i] + Dp[i - 2], Dp[i-1]);\r\n    Dp[i] = max(Dp[i], arr[i] + arr[i - 1] +Dp[i - 3]);\r\n}\r\n    cout &lt;&lt; Dp[N];\r\n\r\n    return 0;\r\n}','2020-03-10 15:35:45',33),(12161783,'BJ',2579,'#include &lt; iostream &gt;\r\n#include&lt; algorithm &gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n\r\n    int N;\r\n    int arr[301] ;\r\n    int Dp[301];\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; arr[i];\r\n    }\r\n\r\n    for (int i = 1; i &lt;= 3 && i &lt;= N; i++) {\r\n        if (i != 3)\r\n            Dp[i] = Dp[i - 1] + arr[i];\r\n        else\r\n            Dp[i] = max(arr[i] + Dp[i - 2], arr[i] + arr[i - 1]);\r\n    }\r\n    for (int i = 4; i &lt;= N; i++) {\r\n    Dp[i] = max(arr[i] + Dp[i - 2], arr[i] + arr[i - 1] + Dp[i - 3]);\r\n}\r\n    cout &lt;&lt; Dp[N];\r\n\r\n}','2020-03-10 15:36:19',34),(12161783,'BJ',6603,'#include &lt; iostream &gt;\r\nusing namespace std;\r\n\r\n\r\n\r\nint lotto[13];\r\nint arr[13];\r\nint k;\r\n\r\nvoid Cout() {\r\n   for (int i = 0; i &lt; 6; i++) {\r\n      cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\r\n   }\r\n   cout &lt;&lt; endl;\r\n}\r\n\r\nvoid dfs(int start,int count) {\r\n   if (count == 6) {\r\n      Cout();\r\n      return;\r\n   }\r\n   for (int i = start; i &lt; k; i++) {\r\n      arr[count] = lotto[i];\r\n      dfs(i + 1, count + 1);\r\n   }\r\n}\r\n\r\n\r\nint main() {\r\n\r\n   for (;;) {\r\n      cin &gt;&gt; k;\r\n      if (k==0) {\r\n         break;\r\n      }\r\n      \r\n      for (int i = 0; i &lt; k; i++) {\r\n         cin &gt;&gt; lotto[i];\r\n      }\r\n      dfs(0, 0);\r\n      cout &lt;&lt; endl;\r\n\r\n   }\r\n\r\n}','2020-03-10 15:36:34',35),(12161783,'BJ',11724,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n#define MAX 1001\r\nint N, M;\r\nint arr[MAX][MAX];\r\nint visit[MAX] = { 0, };\r\nint cnt=0;\r\n\r\nvoid dfs(int a) {\r\n   if (visit[a]==1) {\r\n      \r\n      return;\r\n   }\r\n\r\n   visit[a] = 1;\r\n\r\n   for (int i = 1; i &lt;= N; i++)\r\n   {\r\n      if (visit[i] == 0 && arr[a][i] == 1) {\r\n         dfs(i);\r\n      }\r\n   }\r\n\r\n}\r\n\r\nint main() {\r\n   cin &gt;&gt; N &gt;&gt; M;\r\n   int u, v;\r\n   for (int i = 0; i &lt; M; i++) {\r\n      cin &gt;&gt; u &gt;&gt; v;\r\n      arr[u][v] = 1;\r\n      arr[v][u] = 1;\r\n   }\r\n\r\n   for (int i = 1; i &lt;= N; i++)\r\n   {\r\n      if (visit[i] == 0)\r\n      {\r\n         cnt++;\r\n         dfs(i);            \r\n      }\r\n   }\r\n   cout &lt;&lt; cnt;\r\n   return 0;\r\n\r\n}','2020-03-10 15:36:53',36),(12181751,'BJ',2156,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint stairs[10001] = { 0 };\r\nlong long answer[10001] = { 0 };\r\n\r\nint max(int a, int b)\r\n{\r\n    if (a &gt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nint main()\r\n{\r\n    int N;\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &stairs[i]);\r\n        if (i == 1)\r\n            answer[i] = stairs[1];\r\n        else if (i == 2)\r\n            answer[i] = stairs[1] + stairs[2];\r\n        else\r\n            answer[i] = max(max(answer[i - 2] + stairs[i], answer[i - 3] + stairs[i - 1] + stairs[i]), answer[i - 1]);\r\n        //지금까지의 최댓값인 거랑 나까지 오는데의 최댓값이랑 비교해서 나까지 오는데의 최댓값을 갱신한다\r\n    }\r\n    cout &lt;&lt; answer[N] &lt;&lt; endl;\r\n}','2020-03-10 15:47:44',37),(12151601,'BJ',1463,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nstruct s {\r\n    int num;\r\n    int cnt;\r\n};\r\n\r\nint bfs(int N) {\r\n    queue&lt;s&gt; q;\r\n    q.push({ N, 0 });\r\n    while (!q.empty()) {\r\n        int num = q.front().num;\r\n        int cnt = q.front().cnt;\r\n        q.pop();\r\n        if (num == 1)\r\n            return cnt;\r\n        if (num % 3 == 0)\r\n            q.push({ num / 3, cnt + 1 });\r\n        else if (num % 2 == 0)\r\n            q.push({ num / 2, cnt + 1 });\r\n        q.push({ num - 1, cnt + 1 });\r\n    }\r\n}\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    cout &lt;&lt; bfs(N);\r\n}','2020-03-10 15:47:49',38),(12181751,'BJ',11724,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint N, M;\r\nbool dijkstra[1001][1001] = { 0 };\r\nbool visit[1001] = { 0 };\r\nint answer = 0;\r\nqueue&lt;int&gt; q;\r\nint check()\r\n{\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        if (visit[i] == false)\r\n            return i;\r\n    }\r\n    return 0;\r\n}\r\nvoid connected(int dot)\r\n{\r\n    answer++;\r\n    q.push(dot);\r\n    visit[dot] = true;\r\n    while (!q.empty())\r\n    {\r\n        int start = q.front();\r\n        q.pop();\r\n        for (int i = 1; i &lt;= N; i++)\r\n        {\r\n            if (visit[i]==false && dijkstra[start][i] == true)\r\n            {\r\n                visit[i] = true;\r\n                q.push(i);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    scanf(&quot;%d&quot;, &M);\r\n    for (int i = 0; i &lt; M; i++)\r\n    {\r\n        int c1, c2;\r\n        scanf(&quot;%d %d&quot;, &c1, &c2);\r\n        dijkstra[c1][c2] = dijkstra[c2][c1] = true;\r\n    }\r\n    connected(1);\r\n    int c = check();\r\n    while (c != 0)\r\n    {\r\n        connected(c);\r\n        c = check();\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2020-03-10 15:48:05',39),(12181751,'BJ',1463,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint one[1000001] = { 0 };\r\n\r\nint min(int a, int b)\r\n{\r\n    if (a &lt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nint main()\r\n{\r\n    int N;\r\n    int cnt = 0;\r\n    scanf(&quot;%d&quot;, &N);\r\n    one[2] = 1;\r\n    one[3] = 1;\r\n    for (int i = 4; i &lt;= N; i++)\r\n    {\r\n        if (i % 6 == 0)\r\n            one[i] = min(min(one[i / 2], one[i / 3]), one[i - 1]) + 1;\r\n        else if (i % 2 == 0)\r\n            one[i] = min(one[i / 2], one[i - 1]) + 1;\r\n        else if (i % 3 == 0)\r\n            one[i] = min(one[i / 3], one[i - 1]) + 1;\r\n        else\r\n            one[i] = one[i - 1] + 1;\r\n    }\r\n    cout &lt;&lt; one[N] &lt;&lt; endl;\r\n}','2020-03-10 15:48:37',40),(12181751,'BJ',2579,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint stairs[10001] = { 0 };\r\nlong long answer[10001] = { 0 };\r\n\r\nint max(int a, int b)\r\n{\r\n    if (a &gt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nint main()\r\n{\r\n    int N;\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &stairs[i]);\r\n        if (i == 1)\r\n            answer[i] = stairs[1];\r\n        else if (i == 2)\r\n            answer[i] = stairs[1] + stairs[2];\r\n        else\r\n            answer[i] = max(answer[i - 2] + stairs[i], answer[i - 3] + stairs[i - 1] + stairs[i]);\r\n        //지금까지의 최댓값인 거랑 나까지 오는데의 최댓값이랑 비교해서 나까지 오는데의 최댓값을 갱신한다\r\n    }\r\n    cout &lt;&lt; answer[N] &lt;&lt; endl;\r\n}','2020-03-10 15:48:56',41),(12181751,'BJ',6603,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint rotto[51] = { 0 };\r\nint answer[51] = { 0 };\r\n\r\n\r\nvoid german(int start, int N, int cnt)\r\n{\r\n    if (cnt == 6)\r\n    {\r\n        for (int i = 0; i &lt; 6; i++)\r\n            cout &lt;&lt; answer[i] &lt;&lt; &quot; &quot;;\r\n        cout &lt;&lt; endl;\r\n        return;\r\n    }\r\n\r\n    for (int i = start; i &lt;= N; i++)\r\n    {\r\n        if (rotto[i] &gt; answer[cnt - 1])//내 전의 값보다 크기만 하면 갱신\r\n        {\r\n            answer[cnt] = rotto[i];\r\n            german(start + 1, N, cnt + 1);\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int zero;\r\n    scanf(&quot;%d&quot;, &zero);\r\n    while (zero != 0)\r\n    {\r\n        for(int i=1;i&lt;=zero;i++)\r\n            scanf(&quot;%d&quot;, &rotto[i]);\r\n        german(1, zero, 0);\r\n        cout &lt;&lt; endl;\r\n        scanf(&quot;%d&quot;, &zero);\r\n    }\r\n}','2020-03-10 15:49:11',42),(12151601,'SW',5648,'#include &lt;iostream&gt;\r\n#include &lt;memory.h&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nstruct at {\r\n    int x, y, d, K, n;\r\n};\r\n\r\nvector&lt;at&gt; atom;\r\nint N, ans;\r\nint map[4001][4001];\r\nint dx[] = { 1,-1,0,0 };\r\nint dy[] = { 0,0,-1,1 };\r\n\r\nvoid simul(int n) {\r\n    if (n &lt;= 0)\r\n        return;\r\n    else {\r\n        vector&lt;int&gt; crash;\r\n        for (int t = 1; t &lt;= N; t++) {\r\n            int i = atom[t].d;\r\n            if (i == -1)\r\n                continue;\r\n            int x = atom[t].x;\r\n            int y = atom[t].y;\r\n\r\n            int nx = x + dx[i];\r\n            int ny = y + dy[i];\r\n            if (nx == -1 || nx == 4001 || ny == -1 || ny == 4001) {\r\n                n--;\r\n                atom[t].d = -1;\r\n                map[x][y] = 0;\r\n                continue;\r\n            }\r\n            if (map[nx][ny]) {\r\n                if (atom[map[nx][ny]].n == atom[t].n + 1) {\r\n                    crash.push_back(t);\r\n                    crash.push_back(map[nx][ny]);\r\n                    atom[t].d = -1;\r\n                    atom[map[nx][ny]].d = -1;\r\n                    map[nx][ny] = t;\r\n                    atom[map[nx][ny]].n += 1;\r\n                    map[x][y] = 0;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            atom[t].x = nx;\r\n            atom[t].y = ny;\r\n            atom[t].n += 1;\r\n            map[nx][ny] = t;\r\n            map[x][y] = 0;\r\n        }\r\n        sort(crash.begin(), crash.end());\r\n        crash.erase(unique(crash.begin(), crash.end()), crash.end());\r\n\r\n        for (int i = 0; i &lt; crash.size(); i++) {\r\n            \r\n            ans += atom[crash[i]].K;\r\n            map[atom[crash[i]].x][atom[crash[i]].y] = 0;\r\n            n--;\r\n        }\r\n        simul(n);\r\n    }\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int t = 1; t &lt;= T; t++) {\r\n        int x, y, d, K;\r\n        cin &gt;&gt; N;\r\n        atom.push_back({ 0,0,0,0,0 });\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            cin &gt;&gt; y &gt;&gt; x &gt;&gt; d &gt;&gt; K;\r\n            x += 1000;\r\n            y += 1000;\r\n            x *= 2;\r\n            y *= 2;\r\n            map[x][y] = i;\r\n            atom.push_back({ x,y,d,K,0 });\r\n        }\r\n        simul(N);\r\n        cout &lt;&lt; &quot;#&quot; &lt;&lt; t &lt;&lt; &#39; &#39; &lt;&lt; ans &lt;&lt; endl;\r\n        atom.clear();\r\n        ans = 0;\r\n    }\r\n\r\n}','2020-03-10 15:59:31',43),(12151629,'SW',2382,'def move_cell():\r\n    global cell_list\r\n    global N\r\n    for idx, cell in enumerate(cell_list):\r\n        # 죽은 미생물 제외\r\n        if cell[2] &gt; 0:\r\n            if cell[3] == 1:\r\n                cell[0] -= 1\r\n                if cell[0] == 0:\r\n                    cell[2] = cell[2]//2\r\n                    cell[3] = 2\r\n            elif cell[3] == 2:\r\n                cell[0] += 1\r\n                if cell[0] == N-1:\r\n                    cell[2] = cell[2]//2\r\n                    cell[3] = 1\r\n            elif cell[3] == 3:\r\n                cell[1] -= 1\r\n                if cell[1] == 0:\r\n                    cell[2] = cell[2]//2\r\n                    cell[3] = 4\r\n            elif cell[3] == 4:\r\n                cell[1] += 1\r\n                if cell[1] == N-1:\r\n                    cell[2] = cell[2]//2\r\n                    cell[3] = 3\r\n    for idx, cell in enumerate(cell_list):\r\n        temp_max = cell[2]\r\n        for idx2, cell2 in enumerate(cell_list[idx+1:]):\r\n            if cell[0] == cell2[0] and cell[1] == cell2[1]:\r\n                if temp_max &gt; cell2[2]:\r\n                    pass\r\n                else:\r\n                    temp_max = cell2[2]\r\n                    cell[3] = cell2[3]\r\n                cell[2] += cell2[2]\r\n                cell2[2] = 0\r\n\r\nT = int(input())\r\nfor testcase in range(T):\r\n    N, M, K = map(int,input().split())\r\n    # 세로, 가로, 미생물 수, 이동방향\r\n    cell_list = [list(map(int,input().split())) for _ in range(K)]\r\n    for _ in range(M):\r\n        move_cell()\r\n    print(&#39;#{} {}&#39;.format(testcase+1, sum(i[2] for i in cell_list)))\r\n','2020-03-10 16:13:03',44),(12151629,'BJ',10844,'N = int(input())\r\nnum_list = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]\r\ntemp_list = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]\r\n\r\nfor T in range(N):\r\n    if N == 1:\r\n        pass\r\n    elif T &gt;= 1:\r\n        for idx, i in enumerate(num_list):\r\n            if idx == 0:\r\n                temp_list[0] = num_list[1]\r\n            elif idx == 9:\r\n                temp_list[9] = num_list[8]\r\n            else:\r\n                temp_list[idx] = num_list[idx - 1] + num_list[idx + 1]\r\n    for idx, i in enumerate(temp_list):\r\n        num_list[idx] = i\r\nprint(sum(num_list) % 1000000000)','2020-03-10 16:16:47',45),(12151629,'SW',5648,'my_map = [[0 for _ in range(4000)] for _ in range(4000)]\r\n\r\ndef move_atom():\r\n    global atom_list\r\n    global dead_list\r\n    global answer\r\n    for idx, atom in enumerate(atom_list):\r\n        if dead_list[idx] == 0:\r\n            my_map[atom[1]][atom[0]] -= 1\r\n            if atom[2] == 0:\r\n                if atom[1] == 2000:\r\n                    dead_list[idx] = 1\r\n                else:\r\n                    atom[1] += 1\r\n            elif atom[2] == 1:\r\n                if atom[1] == -2000:\r\n                    dead_list[idx] = 1\r\n                else:\r\n                    atom[1] -= 1\r\n            elif atom[2] == 2:\r\n                if atom[0] == -2000:\r\n                    dead_list[idx] = 1\r\n                else:\r\n                    atom[0] -= 1\r\n            elif atom[2] == 3:\r\n                if atom[0] == 2000:\r\n                    dead_list[idx] = 1\r\n                else:\r\n                    atom[0] += 1\r\n            my_map[atom[1]][atom[0]] += 1\r\n\r\n    for idx, atom in enumerate(atom_list):\r\n        if dead_list[idx] == 0:\r\n            if my_map[atom[1]][atom[0]] &gt; 1:\r\n                for idx2, atom2 in enumerate(atom_list[idx+1:]):\r\n                    if atom[0] == atom2[0] and atom[1] == atom2[1] and dead_list[idx + idx2 + 1] == 0:\r\n                        answer += atom2[3]\r\n                        dead_list[idx + idx2 + 1] = 1\r\n                        dead_list[idx] = 1\r\n                if dead_list[idx] == 1:\r\n                    answer += atom[3]\r\n\r\n\r\n# 31 번 테케.....\r\nT = int(input())\r\nfor testcase in range(T):\r\n    answer = 0\r\n    count = 0\r\n\r\n    # x, y, 방향, 에너지\r\n    atom_list = [list(map(int, input().split())) for _ in range(int(input()))]\r\n    dead_list = [0 for _ in range(len(atom_list))]\r\n    for idx, atom in enumerate(atom_list):\r\n        my_map[atom[1]][atom[0]] = 1\r\n        atom_list[idx][0] = atom_list[idx][0]*2\r\n        atom_list[idx][1] = atom_list[idx][1]*2\r\n    while dead_list.count(0) &gt; 1 and count &lt; 4004:\r\n        move_atom()\r\n        count += 1\r\n    # print(dead_list)\r\n    print(&#39;#{} {}&#39;.format(testcase+1, answer))\r\n\r\n','2020-03-10 18:06:04',46),(12181751,'BJ',11053,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint N;\r\npriority_queue&lt;pair&lt;int, int&gt;&gt; pq;\r\nint value[1001] = { 0 };\r\nint answer[1001] = { 0 };\r\n\r\nint max(int a, int b)\r\n{\r\n    if (a &gt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nvoid part()\r\n{\r\n    for(int cnt = 0 ; cnt &lt; N ; cnt++)\r\n    {\r\n        int num = pq.top().first;\r\n        int n = pq.top().second;\r\n        for (int i = n; i &lt; N; i++)\r\n        {\r\n            if (num &lt; value[i])\r\n                answer[n] = max(answer[n], answer[i]);//자신보다 큰 값이 나 보다 더 큰 index에 있다면 그 값의 부분수열 크기랑\r\n                                                    //내꺼랑 비교해서 더 큰것으로 자신의 부분수열 크기를 정한다\r\n        }\r\n        answer[n] += 1;//자신을 포함한다.\r\n        pq.pop();\r\n        pq.push(make_pair(-1, answer[n]));//절대 top의 위치에 오르지 못하도록 -1을 앞에 두고 각 해당 index의 값을 넣어둔다\r\n                                            //이때 priority queue를 사용하여 가장 큰 값이 가장 앞에 오도록한다.\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        int c;\r\n        scanf(&quot;%d&quot;, &c);//priority_queue에 들어가는 value값이랑 index를  pair로 저장해둔다\r\n        pq.push(make_pair(c, i));//값이 큰 것에 먼저 접근하여 결과값을 낼 예정\r\n        value[i] = c;\r\n    }\r\n    part();\r\n    cout &lt;&lt; pq.top().second&lt;&lt;endl;\r\n}','2020-03-12 15:19:47',47),(12181751,'BJ',11054,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N;\r\nint A[1001] = { 0 };\r\nint front_ans[1001] = { 1, };\r\nint back_ans[1001] = { 1, };\r\n\r\nint max(int a, int b)\r\n{\r\n    if (a &gt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nvoid front_series(int me)//계단 오르기 혹은 1로 만들기랑 똑같이 함\r\n{\r\n    for (int i = 0; i &lt; me; i++)\r\n    {\r\n        if (A[me] &gt; A[i])//자기 보다 작은 값을 갖는거가 있으면 그 인덱스에 저장된 값이랑 자기꺼랑 비교해서 갱신한다\r\n            front_ans[me] = max(front_ans[me], front_ans[i]);\r\n    }\r\n    front_ans[me] += 1;\r\n}\r\nvoid back_series(int me)\r\n{\r\n    for (int i = N-1; i &gt; me; i--)\r\n    {\r\n        if (A[me] &gt; A[i])//이건 뒤에서 부터 확인\r\n            back_ans[me] = max(back_ans[me], back_ans[i]);\r\n    }\r\n    back_ans[me] += 1;\r\n}\r\n\r\n\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &A[i]);\r\n    }\r\n    int mmax = front_ans[0] + back_ans[0] - 1;\r\n    for (int i = 1; i &lt; N; i++)\r\n    {\r\n        front_series(i);\r\n    }\r\n    for (int i = N - 1; i &gt;= 1; i--)\r\n    {\r\n        back_series(i);\r\n        if (mmax &lt; front_ans[i] + back_ans[i] - 1)\r\n            mmax = front_ans[i] + back_ans[i] - 1;\r\n    }\r\n    cout &lt;&lt; mmax &lt;&lt; endl;\r\n}','2020-03-12 15:20:14',48),(12151551,'BJ',2565,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\npair&lt;int, int&gt; arr[101] = { {0,0} };\r\nint check[101] = { 0 };\r\nint N;\r\n\r\nbool compare(const pair&lt;int, int&gt;&a, const pair&lt;int, int&gt;&b) {\r\n    return a.first &lt; b.first;\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; arr[i].first &gt;&gt; arr[i].second;\r\n    }\r\n    sort(arr, arr+N,compare);\r\n    check[0] = 1;\r\n    for (int i = 1; i &lt; N; i++) {\r\n        for (int j = i; j &gt;= 0; j--) {\r\n            if (arr[i].second &gt; arr[j].second) {\r\n                check[i] = max(check[j] + 1,check[i]);\r\n            }\r\n        }\r\n        if (check[i] == 0)\r\n            check[i] = 1;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        result = max(result, check[i]);\r\n    }\r\n    cout &lt;&lt; N - result &lt;&lt; endl;\r\n}','2020-03-12 19:56:51',49),(12151551,'BJ',1912,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr[2][100000] = { 0 };\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; arr[0][i];\r\n    }\r\n    arr[1][0] = arr[0][0];\r\n    for (int i = 1; i &lt; N; i++) {\r\n        arr[1][i] = max(arr[0][i] + arr[1][i - 1],arr[0][i]);\r\n    }\r\n    int result = -1001;\r\n    for (int i = 0; i &lt; N; i++)\r\n        result = max(result, arr[1][i]);\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}','2020-03-12 20:25:22',50),(12171820,'BJ',11053,'#include&lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n\r\nvector&lt;int &gt;ve;\r\nint a[1001];\r\nint main() {\r\n    int n; // 총 입력 받는 숫자의 개수\r\n    cin &gt;&gt; n;\r\n    \r\n    \r\n    for (int i =1 ; i &lt;= n; i++)\r\n    {\r\n        cin &gt;&gt; a[i];\r\n    }\r\n    ve.push_back( 1 );\r\n    vector &lt;int&gt; vv;\r\n    for (int i = 2; i &lt;= n; i++)\r\n    {\r\n        int len = 1;\r\n        for (int j = 1; j &lt; i; j++)\r\n        {\r\n            \r\n            if (a[j] &lt; a[j+1])\r\n            {\r\n                vv.push_back(a[j]);\r\n            }            \r\n        }\r\n        int temp = vv.size()+1;\r\n        ve.push_back((temp) );\r\n        vv.clear();\r\n        \r\n\r\n    }\r\n    sort(ve.begin(), ve.end());\r\n\r\n    cout &lt;&lt; ve.back() &lt;&lt; endl;\r\n    \r\n\r\n}','2020-03-21 13:45:30',51),(12151551,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr[101][100001] = { 0 };\r\nint N, K;\r\nint result = 0;\r\nvector&lt; pair&lt;int, int&gt; &gt; v;\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int W, V;\r\n        cin &gt;&gt; W &gt;&gt; V;\r\n        v.push_back({ W,V });\r\n    }\r\n    for (int i = 0; i &lt;v.size(); i++) {\r\n        arr[i + 1][v[i].first] = max(arr[i + 1][v[i].first],v[i].second);\r\n        for (int j = 0; j &lt; K; j++) {\r\n            if (v[i].first + j &gt; K)\r\n                break;\r\n            if(i!=0)\r\n                if (arr[i][j] == 0) arr[i][j] = arr[i-1][j];\r\n            arr[i+1][v[i].first + j] = max(arr[i][v[i].first + j], v[i].second + arr[i][j]);\r\n        }\r\n    }\r\n    for (int i = 0; i &lt;= N; i++) {\r\n        for (int j = 0; j &lt;= K; j++)\r\n            result = max(result, arr[i][j]);\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}\r\n\r\n//왜 안되는지 몰것음','2020-03-14 03:05:43',52),(12151551,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr[101][100001] = { 0 };\r\nint N, K;\r\nint result = 0;\r\nvector&lt; pair&lt;int, int&gt; &gt; v;\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int W, V;\r\n        cin &gt;&gt; W &gt;&gt; V;\r\n        v.push_back({ W,V });\r\n    }\r\n    for (int i = 0; i &lt;v.size(); i++) {\r\n        for (int j = 1; j &lt;= K; j++) {\r\n            if (j-v[i].first &gt;= 0)\r\n                arr[i + 1][j] = max(arr[i][j], arr[i][j - v[i].first] + v[i].second);\r\n            else\r\n                arr[i + 1][j] = arr[i][j];\r\n        }\r\n    }\r\n    for (int i = 0; i &lt;= N; i++) {\r\n        for (int j = 0; j &lt;= K; j++)\r\n            result = max(result, arr[i][j]);\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}','2020-03-14 03:18:49',53),(12151601,'BJ',1912,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int n;\r\n    cin &gt;&gt; n;\r\n    int N[100000], max, sum;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        cin &gt;&gt; N[i];\r\n    }\r\n    max = N[0];\r\n    sum = 0;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        sum += N[i];\r\n        max = max &lt; sum ? sum : max;\r\n        if (sum &lt; 0)\r\n            sum = 0;\r\n    }\r\n    cout &lt;&lt; max;\r\n}','2020-03-14 16:35:49',54),(12151551,'BJ',14891,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;cstring&gt;\r\nusing namespace std;\r\n\r\nvector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; v;\r\nint arr[9][9] = { 0 };\r\nbool visited[9];\r\n\r\nvoid rotate(int num, int dir) {\r\n    if (dir == 1) {\r\n        int fir = arr[num][7];\r\n        for (int i = 7; i &gt;= 1; i--) {\r\n            arr[num][i] = arr[num][i - 1];\r\n        }\r\n        arr[num][0] = fir;\r\n    }\r\n    else if (dir == -1) {\r\n        int fir = arr[num][0];\r\n        for (int i = 0; i &lt; 7; i++) {\r\n            arr[num][i] = arr[num][i + 1];\r\n        }\r\n        arr[num][7] = fir;\r\n    }\r\n}\r\n\r\nvoid allr(int num,int dir) {\r\n    visited[num] = true;\r\n    int prev_num = num - 1;\r\n    int next_num = num + 1;\r\n    if (next_num &lt; 4 && !visited[next_num]) {\r\n        if (arr[num][2] != arr[next_num][6])\r\n            allr(next_num, dir*-1);\r\n    }\r\n    if (prev_num &gt;= 0 && !visited[prev_num]) {\r\n        if (arr[num][6] != arr[prev_num][2])\r\n            allr(prev_num, dir*-1);\r\n    }\r\n    rotate(num, dir);\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        for (int j = 0; j &lt; 8; j++) {\r\n            scanf(&quot;%1d&quot;,&arr[i][j]);\r\n        }\r\n    }\r\n    int K;\r\n    cin &gt;&gt; K;\r\n    int num, dir;\r\n    for (int i = 0; i &lt; K; i++) {\r\n        cin &gt;&gt; num &gt;&gt; dir;\r\n        allr(num - 1, dir);\r\n        memset(visited, false, sizeof(visited));\r\n        //rotate(num - 1, dir);\r\n    }\r\n\r\n    int answ = 0;\r\n    int score[] = { 1, 2, 4, 8 };\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        if (arr[i][0] == 1)\r\n            answ += score[i];\r\n    }\r\n\r\n    cout &lt;&lt; answ &lt;&lt; endl;\r\n    return 0;\r\n}\r\n\r\n','2020-03-14 16:49:01',55),(12151601,'BJ',2565,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nvector&lt;pair&lt;int, int&gt;&gt; wire;\r\n\r\nbool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\r\n    return a.first &lt; b.first;\r\n}\r\n\r\nint main() {\r\n    int n, d[100], ans = 0;\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        int a, b;\r\n        cin &gt;&gt; a &gt;&gt; b;\r\n        wire.push_back({ a,b });\r\n    }\r\n    sort(wire.begin(), wire.end(), cmp);\r\n\r\n    for (int i = 0; i &lt; n; i++) {\r\n        d[i] = 1;\r\n        int mx = 1;\r\n        for (int j = 0; j &lt; i; j++) {\r\n            if (wire[j].second &lt; wire[i].second) {\r\n                mx = max(mx, d[i] + d[j]);\r\n            }\r\n        }\r\n        d[i] = mx;\r\n        ans = mx &gt; ans ? mx : ans;\r\n    }\r\n    cout &lt;&lt; n - ans;\r\n}','2020-03-15 20:41:14',56),(12151636,'SW',5644,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint dx[] = { 0,-1,0,1,0 };\r\nint dy[] = { 0,0,1,0,-1 };\r\nstruct BC {\r\n    int x;\r\n    int y;\r\n    int c;\r\n    int p;\r\n};\r\nstruct positon {\r\n    int x;\r\n    int y;\r\n    int value;\r\n};\r\nvector&lt;int&gt; A_move;\r\nvector&lt;int&gt; B_move;\r\nvector&lt;int&gt; battery;\r\nint M, bc_cnt;\r\npositon a, b;\r\nvector&lt;positon&gt; map[12][12];\r\n\r\nint choose_max(vector&lt;positon&gt; v) {\r\n    int max_value = 0;\r\n    for (int i = 0; i &lt; v.size(); i++) {\r\n        if (max_value &lt; v[i].value)\r\n            max_value = v[i].value;\r\n    }\r\n    return max_value;\r\n}\r\n\r\nvoid cal_map(vector&lt;positon&gt; v, vector&lt;positon&gt; v1) {\r\n    int max_value = 0;\r\n    if (v.size() &lt; v1.size()) {\r\n        if (v.size() == 0)\r\n            max_value = choose_max(v1);\r\n        else {\r\n            for (int i = 0; i &lt; v1.size(); i++) {\r\n                for (int j = 0; j &lt; v.size(); j++) {\r\n                    int s = v1[i].value + v[j].value;\r\n                    if (v1[i].value == v[j].value && v1[i].x == v[j].x && v1[i].y == v[j].y)\r\n                        s = (v1[i].value + v[j].value) / 2;\r\n                    if (max_value &lt; s)\r\n                        max_value = s;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (v.size() &gt; v1.size()) {\r\n        if (v1.size() == 0)\r\n            max_value = choose_max(v);\r\n        else {\r\n            for (int i = 0; i &lt; v.size(); i++) {\r\n                for (int j = 0; j &lt; v1.size(); j++) {\r\n                    int s = v[i].value + v1[j].value;\r\n                    if (v[i].value == v1[j].value && v[i].x == v1[j].x && v[i].y == v1[j].y)\r\n                        s = (v[i].value + v1[j].value) / 2;\r\n                    if (max_value &lt; s)\r\n                        max_value = s;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (v.size() == v1.size()) {\r\n        if (v.size() &gt; 0) {\r\n            for (int i = 0; i &lt; v.size(); i++) {\r\n                for (int j = 0; j &lt; v1.size(); j++) {\r\n                    int s = v[i].value + v1[j].value;\r\n                    if (v[i].value == v1[j].value && v[i].x == v1[j].x && v[i].y == v1[j].y)\r\n                        s = (v[i].value + v1[j].value) / 2;\r\n                    if (max_value &lt; s)\r\n                        max_value = s;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    battery.push_back(max_value);\r\n}\r\n\r\nvoid move() {\r\n    for (int i = 0; i &lt; A_move.size(); i++) {\r\n        a.x = a.x + dx[A_move[i]];\r\n        a.y = a.y + dy[A_move[i]];\r\n        b.x = b.x + dx[B_move[i]];\r\n        b.y = b.y + dy[B_move[i]];\r\n        cal_map(map[a.x][a.y], map[b.x][b.y]);\r\n    }\r\n}\r\n\r\nvoid start() {\r\n    a.x = 1; a.y = 1;\r\n    b.x = 10; b.y = 10;\r\n    a.value = choose_max(map[a.x][a.y]);\r\n    b.value = choose_max(map[b.x][b.y]);\r\n    cal_map(map[a.x][a.y], map[b.x][b.y]);\r\n    move();\r\n}\r\n\r\nint main() {\r\n    int testcase;\r\n    cin &gt;&gt; testcase;\r\n    for (int t = 0; t &lt; testcase; t++) {\r\n        A_move.clear();\r\n        B_move.clear();\r\n        battery.clear();\r\n        for (int i = 0; i &lt; 12; i++)\r\n            for (int j = 0; j &lt; 12; j++)\r\n                map[i][j].clear();\r\n        cin &gt;&gt; M &gt;&gt; bc_cnt;\r\n        for (int i = 0; i &lt; M; i++) {\r\n            int a_m;\r\n            cin &gt;&gt; a_m;\r\n            A_move.push_back(a_m);\r\n        }\r\n        for (int i = 0; i &lt; M; i++) {\r\n            int b_m;\r\n            cin &gt;&gt; b_m;\r\n            B_move.push_back(b_m);\r\n        }\r\n        for (int i = 0; i &lt; bc_cnt; i++) {\r\n            int visit[12][12] = { 0 };\r\n            BC bc;\r\n            cin &gt;&gt; bc.y &gt;&gt; bc.x &gt;&gt; bc.c &gt;&gt; bc.p;\r\n            queue&lt;positon&gt; q;\r\n            positon p; p.x = bc.x; p.y = bc.y; p.value = bc.c;\r\n            positon pq; pq.x = bc.x; pq.y = bc.y; pq.value = bc.p;\r\n            map[bc.x][bc.y].push_back(pq);\r\n            q.push(p); int c1 = bc.c;\r\n            while (!q.empty()) {\r\n                int x1 = q.front().x;\r\n                int y1 = q.front().y;\r\n                int value1 = q.front().value;\r\n                \r\n                visit[x1][y1] = 1;\r\n                q.pop();\r\n                if (value1 == 0) break;\r\n                for (int k = 1; k &lt;= 4; k++) {\r\n                    int nextx = x1 + dx[k];\r\n                    int nexty = y1 + dy[k];\r\n                    \r\n                    if (nextx &gt;=1 && nextx &lt;11 && nexty &gt;= 1 && nexty &lt; 11 &&visit[nextx][nexty] == 0) {\r\n                        positon ps;\r\n                        ps.x = bc.x; ps.y = bc.y; ps.value = bc.p;\r\n                        map[nextx][nexty].push_back(ps);\r\n                        visit[nextx][nexty] = 1;\r\n                        positon po;\r\n                        po.x = nextx; po.y = nexty; po.value = value1 - 1;\r\n                        q.push(po);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        start();\r\n        int sum = 0;\r\n        for (int i = 0; i &lt; battery.size(); i++) {\r\n            sum = sum + battery[i];\r\n        }\r\n        cout &lt;&lt; &quot;#&quot; &lt;&lt; t + 1 &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl;\r\n    }\r\n}','2020-03-15 21:27:43',57),(12151636,'BJ',1912,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr[100001];\r\nint dp[100001];\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n        cin &gt;&gt; arr[i];\r\n    dp[0] = arr[0]; \r\n    int max_value = arr[0];\r\n    dp[1] = max(dp[0] + arr[1], arr[1]);\r\n    for (int i = 2; i &lt; N; i++)\r\n        dp[i] = max(dp[i - 1] + arr[i],arr[i]);\r\n    for (int i = 0; i &lt; N; i++) {\r\n        if (max_value &lt; dp[i])\r\n            max_value = dp[i];\r\n    }\r\n    cout &lt;&lt; max_value &lt;&lt; endl;\r\n}','2020-03-15 21:28:23',58),(12151636,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint N,K;\r\nint DP[102][100002];\r\nstruct package {\r\n    int w;\r\n    int v;\r\n};\r\nvector&lt;package&gt; v1;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n\r\n    for (int i = 0; i &lt; N; i++) {\r\n        package p;\r\n        cin &gt;&gt; p.w &gt;&gt; p.v;\r\n        v1.push_back(p);\r\n    }\r\n    for (int i = 0; i &lt; v1.size(); i++) {\r\n        for (int j = 0; j &lt;= K; j++) {\r\n            if (j - v1[i].w &gt;= 0)\r\n                DP[i + 1][j] = max(DP[i][j], v1[i].v + DP[i][j - v1[i].w]);\r\n            else\r\n                DP[i + 1][j] = DP[i][j];\r\n        }\r\n    }\r\n    cout &lt;&lt; DP[N][K];\r\n}','2020-08-13 22:18:16',59),(12151636,'BJ',14891,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nstruct cir {\r\n    int num;\r\n    int dir;\r\n};\r\nvector&lt;char&gt; v[4]; int k;\r\nvector&lt;cir&gt; condition;\r\nint v_cond[4];\r\nint score;\r\n\r\nvoid cal_score() {\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        if (i == 0 && v[i][0] == &#39;1&#39;)\r\n            score = score + 1;\r\n        else if (i == 1 && v[i][0] == &#39;1&#39;)\r\n            score = score + 2;\r\n        else if (i == 2 && v[i][0] == &#39;1&#39;)\r\n            score = score + 4;\r\n        else if (i == 3 && v[i][0] == &#39;1&#39;)\r\n            score = score + 8;\r\n    }\r\n}\r\n\r\nvoid rotate_clock(int index,vector&lt;char&gt; v1) {\r\n    for (int i = 1; i &lt; v1.size(); i++)\r\n        v[index][i] = v1[i - 1];\r\n    v[index][0] = v1[v1.size() - 1];\r\n}\r\nvoid rotate_unclock(int index, vector&lt;char&gt; v1) {\r\n    for (int i = 0; i &lt; v1.size()-1; i++)\r\n        v[index][i] = v1[i + 1];\r\n    v[index][v1.size() - 1] = v1[0];\r\n}\r\n\r\nvoid rotation(int num, int dir) {\r\n    //오른쪽 확인 \r\n    v_cond[num - 1] = dir;\r\n    for (int i = num - 1; i &lt; 3 ; i++) {\r\n        if (v[i][2] != v[i + 1][6]) {\r\n            if (v_cond[i] == 1)\r\n                v_cond[i + 1] = -1;\r\n            else if (v_cond[i] == -1)\r\n                v_cond[i + 1] = 1;\r\n        }\r\n    }\r\n    //왼쪽 확인\r\n    for (int i = num - 1; i &gt;= 1; i--) {\r\n        if (v[i][6] != v[i - 1][2]) {\r\n            if (v_cond[i] == 1)\r\n                v_cond[i - 1] = -1;\r\n            else if (v_cond[i] == -1)\r\n                v_cond[i - 1] = 1;\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        vector&lt;char&gt; v1 = v[i];\r\n        if (v_cond[i] == 1)\r\n            rotate_clock(i, v1);\r\n        else if (v_cond[i] == -1)\r\n            rotate_unclock(i, v1);\r\n    }\r\n    \r\n}\r\n\r\nint main() {\r\n    score = 0;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        string s;\r\n        cin&gt;&gt;s;\r\n        for (int j = 0; j &lt; s.size(); j++)\r\n            v[i].push_back(s[j]);\r\n    }\r\n    cin &gt;&gt; k;\r\n    for (int i = 0; i &lt; k; i++) {\r\n        cir c;\r\n        cin &gt;&gt; c.num &gt;&gt; c.dir;\r\n        condition.push_back(c);\r\n    }\r\n    for (int i = 0; i &lt; condition.size(); i++) {\r\n        for (int j = 0; j &lt; 4; j++)\r\n            v_cond[j] = 0;\r\n        rotation(condition[i].num, condition[i].dir);\r\n    }\r\n    cal_score();\r\n    cout &lt;&lt; score &lt;&lt; endl;\r\n}','2020-03-15 21:29:39',60),(12151636,'BJ',2565,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nstruct elect {\r\n    int start;\r\n    int end;\r\n};\r\nvector&lt;elect&gt;  electronic; int dp[501];\r\nbool cmp(elect p1,elect p2) {\r\n    return p1.start &lt; p2.start;\r\n}\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        elect el;\r\n        cin &gt;&gt; el.start &gt;&gt; el.end;\r\n        electronic.push_back(el);\r\n    }\r\n    sort(electronic.begin(), electronic.end(), cmp);\r\n    dp[0] = 1;\r\n    for (int i = 1; i &lt; N; i++) {\r\n        for (int j = i; j &gt;= 0; j--) {\r\n            if (electronic[i].end &gt; electronic[j].end)\r\n                dp[i] = max(dp[i], dp[j] + 1);\r\n        }\r\n        if (dp[i] == 0)\r\n            dp[i] = 1;\r\n    }\r\n    int max_value = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        if (max_value &lt; dp[i])\r\n            max_value = dp[i];\r\n    }\r\n    cout &lt;&lt; N - max_value &lt;&lt; endl;\r\n}','2020-03-15 21:29:58',61),(12151601,'BJ',14891,'#include &lt;iostream&gt;\r\n#include &lt;memory.h&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nbool gear[4][8];\r\nbool visit[4];\r\n\r\nvoid rotate(int n, int d) {\r\n    int temp;\r\n    switch (d) {\r\n    case 1:\r\n        temp = gear[n][7];\r\n        for (int i = 7; i &gt; 0; i--) {\r\n            gear[n][i] = gear[n][i - 1];\r\n        }\r\n        gear[n][0] = temp;\r\n        break;\r\n\r\n    case -1:\r\n        temp = gear[n][0];\r\n        for (int i = 0; i &lt; 7; i++) {\r\n            gear[n][i] = gear[n][i + 1];\r\n        }\r\n        gear[n][7] = temp;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid move(int n, int d) {\r\n    visit[n] = true;\r\n    bool left, right;\r\n    left = right = false;\r\n\r\n    if (n - 1 &gt;= 0 && !visit[n - 1])\r\n        if (gear[n - 1][2] != gear[n][6])\r\n            left = true;\r\n\r\n    if (n + 1 &lt;= 3 && !visit[n + 1])\r\n        if (gear[n][2] != gear[n + 1][6])\r\n            right = true;\r\n\r\n    rotate(n, d);\r\n\r\n    if (left)\r\n        move(n - 1, d * -1);\r\n\r\n    if (right)\r\n        move(n + 1, d * -1);\r\n}\r\n\r\nint main() {\r\n    int ans = 0;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        for (int j = 0; j &lt; 8; j++) {\r\n            scanf(&quot;%1d&quot;, &gear[i][j]);\r\n        }\r\n    }\r\n    int K, n, d;\r\n    cin &gt;&gt; K;\r\n    for (int i = 0; i &lt; K; i++) {\r\n        memset(visit, false, sizeof(visit));\r\n        cin &gt;&gt; n &gt;&gt; d;\r\n        move(n - 1, d);\r\n    }\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        if (gear[i][0]) {\r\n            ans += pow(2, i);\r\n        }\r\n    }\r\n    cout &lt;&lt; ans;\r\n}','2020-03-15 22:31:57',62),(12151601,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint d[100001];\r\n\r\nint main() {\r\n    int N, K, W[100], V[100];\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; W[i] &gt;&gt; V[i];\r\n    }\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = K; j &gt;= 1; j--) {\r\n            if (W[i] &lt;= j) {\r\n                d[j] = max(d[j - W[i]] + V[i], d[j]);\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; d[K];\r\n}','2020-03-16 00:22:38',63),(12151526,'BJ',1912,'#include&lt;iostream&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;queue&gt;\r\nusing namespace std;\r\n\r\npriority_queue&lt;int&gt; answer;\r\nint N;\r\nint A[100000] = { 0, };\r\nint dp[100000] = { 0, };\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; A[i];\r\n    }\r\n    dp[0] = A[0];\r\n    answer.push(dp[0]);\r\n    for (int i = 1; i &lt; N; i++) {\r\n        dp[i] = 0;\r\n        if (A[i] + dp[i - 1] &gt; A[i]) {\r\n            dp[i] = A[i] + dp[i - 1];\r\n        }\r\n        else {\r\n            dp[i] = A[i];\r\n        }\r\n        answer.push(dp[i]);\r\n    }\r\n    cout &lt;&lt; answer.top();\r\n}','2020-03-16 01:15:39',64),(12151526,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\nint N, K;\r\nstruct st {\r\n    int w;\r\n    int v;\r\n};\r\nst arr[100];\r\nint weight[100000];\r\nint res;\r\nvector&lt;int&gt; num;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; arr[i].w &gt;&gt; arr[i].v;\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        vector&lt;int&gt; num2;\r\n        for (int j = num.size() - 1; j &gt;= 0; j--) {\r\n            if (arr[i].w + num[j] &lt;= K) {\r\n                if (weight[arr[i].w + num[j]] == 0) {\r\n                    num2.push_back(arr[i].w + num[j]);\r\n                }\r\n                weight[arr[i].w + num[j]] = max(weight[arr[i].w + num[j]], weight[num[j]] + arr[i].v);\r\n                res = max(res, weight[arr[i].w + num[j]]);\r\n            }\r\n        }\r\n        for (int j = 0; j &lt; num2.size(); j++) {\r\n            num.push_back(num2[j]);\r\n        }\r\n        if (arr[i].w &lt;= K) {\r\n            if (weight[arr[i].w] == 0) {\r\n                weight[arr[i].w] = arr[i].v;\r\n                num.push_back(arr[i].w);\r\n            }\r\n            else {\r\n                weight[arr[i].w] = max(arr[i].v, weight[arr[i].w]);\r\n            }\r\n            res = max(res, weight[arr[i].w]);\r\n        }\r\n        sort(num.begin(), num.end());\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-03-16 12:25:16',65),(12151526,'BJ',14891,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint gear1[8];\r\nint gear2[8];\r\nint gear3[8];\r\nint gear4[8];\r\nint K, res;\r\nstruct st {\r\n    int num;\r\n    int di;\r\n};\r\nst info[100];\r\nvoid rotate11() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear1[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear1[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear1[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate12() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear1[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear1[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear1[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate21() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear2[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear2[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear2[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate22() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear2[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear2[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear2[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate31() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear3[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear3[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear3[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate32() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear3[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear3[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear3[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate41() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear4[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear4[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear4[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate42() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear4[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear4[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear4[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate1(int a) {\r\n    if (a == 1) {\r\n        if (gear1[2] != gear2[6]) {\r\n            if (gear2[2] != gear3[6]) {\r\n                if (gear3[2] != gear4[6]) {\r\n                    rotate11();\r\n                    rotate22();\r\n                    rotate31();\r\n                    rotate42();\r\n                }\r\n                else {\r\n                    rotate11();\r\n                    rotate22();\r\n                    rotate31();\r\n                }\r\n            }\r\n            else {\r\n                rotate11();\r\n                rotate22();\r\n            }\r\n        }\r\n        else {\r\n            rotate11();\r\n        }\r\n    }\r\n    else if (a == -1) {\r\n        if (gear1[2] != gear2[6]) {\r\n            if (gear2[2] != gear3[6]) {\r\n                if (gear3[2] != gear4[6]) {\r\n                    rotate12();\r\n                    rotate21();\r\n                    rotate32();\r\n                    rotate41();\r\n                }\r\n                else {\r\n                    rotate12();\r\n                    rotate21();\r\n                    rotate32();\r\n                }\r\n            }\r\n            else {\r\n                rotate12();\r\n                rotate21();\r\n            }\r\n        }\r\n        else {\r\n            rotate12();\r\n        }\r\n    }\r\n}\r\nvoid rotate2(int a) {\r\n    if (a == 1) {\r\n        if (gear2[6] != gear1[2]) {\r\n            rotate12();\r\n        }\r\n        if (gear2[2] != gear3[6]) {\r\n            if (gear3[2] != gear4[6]) {\r\n                rotate32();\r\n                rotate41();\r\n            }\r\n            else {\r\n                rotate32();\r\n            }\r\n        }\r\n        rotate21();\r\n    }\r\n    else if (a == -1) {\r\n        if (gear2[6] != gear1[2]) {\r\n            rotate11();\r\n        }\r\n        if (gear2[2] != gear3[6]) {\r\n            if (gear3[2] != gear4[6]) {\r\n                rotate31();\r\n                rotate42();\r\n            }\r\n            else {\r\n                rotate31();\r\n            }\r\n        }\r\n        rotate22();\r\n    }\r\n}\r\nvoid rotate3(int a) {\r\n    if (a == 1) {\r\n        if (gear3[2] != gear4[6]) {\r\n            rotate42();\r\n        }\r\n        if (gear3[6] != gear2[2]) {\r\n            if (gear2[6] != gear1[2]) {\r\n                rotate22();\r\n                rotate11();\r\n            }\r\n            else {\r\n                rotate22();\r\n            }\r\n        }\r\n        rotate31();\r\n    }\r\n    else if (a == -1) {\r\n        if (gear3[2] != gear4[6]) {\r\n            rotate41();\r\n        }\r\n        if (gear3[6] != gear2[2]) {\r\n            if (gear2[6] != gear1[2]) {\r\n                rotate21();\r\n                rotate12();\r\n            }\r\n            else {\r\n                rotate21();\r\n            }\r\n        }\r\n        rotate32();\r\n    }\r\n}\r\nvoid rotate4(int a) {\r\n    if (a == 1) {\r\n        if (gear4[6] != gear3[2]) {\r\n            if (gear3[6] != gear2[2]) {\r\n                if (gear2[6] != gear1[2]) {\r\n                    rotate41();\r\n                    rotate32();\r\n                    rotate21();\r\n                    rotate12();\r\n                }\r\n                else {\r\n                    rotate41();\r\n                    rotate32();\r\n                    rotate21();\r\n                }\r\n            }\r\n            else {\r\n                rotate41();\r\n                rotate32();\r\n            }\r\n        }\r\n        else {\r\n            rotate41();\r\n        }\r\n    }\r\n    else if (a == -1) {\r\n        if (gear4[6] != gear3[2]) {\r\n            if (gear3[6] != gear2[2]) {\r\n                if (gear2[6] != gear1[2]) {\r\n                    rotate42();\r\n                    rotate31();\r\n                    rotate22();\r\n                    rotate11();\r\n                }\r\n                else {\r\n                    rotate42();\r\n                    rotate31();\r\n                    rotate22();\r\n                }\r\n            }\r\n            else {\r\n                rotate42();\r\n                rotate31();\r\n            }\r\n        }\r\n        else {\r\n            rotate42();\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear1[i]);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear2[i]);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear3[i]);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear4[i]);\r\n    }\r\n    scanf(&quot;%d&quot;, &K);\r\n    for (int i = 0; i &lt; K; i++) {\r\n        scanf(&quot;%d %d&quot;, &info[i].num, &info[i].di);\r\n    }\r\n    for (int i = 0; i &lt; K; i++) {\r\n        if (info[i].num == 1) {\r\n            rotate1(info[i].di);\r\n        }\r\n        else if (info[i].num == 2) {\r\n            rotate2(info[i].di);\r\n        }\r\n        else if (info[i].num == 3) {\r\n            rotate3(info[i].di);\r\n        }\r\n        else if (info[i].num == 4) {\r\n            rotate4(info[i].di);\r\n        }\r\n    }\r\n    if (gear1[0] == 1) {\r\n        res += 1;\r\n    }\r\n    if (gear2[0] == 1) {\r\n        res += 2;\r\n    }\r\n    if (gear3[0] == 1) {\r\n        res += 4;\r\n    }\r\n    if (gear4[0] == 1) {\r\n        res += 8;\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-03-16 01:16:39',66),(12151526,'BJ',14891,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint gear1[8];\r\nint gear2[8];\r\nint gear3[8];\r\nint gear4[8];\r\nint K, res;\r\nstruct st {\r\n    int num;\r\n    int di;\r\n};\r\nst info[100];\r\nvoid rotate11() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear1[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear1[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear1[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate12() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear1[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear1[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear1[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate21() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear2[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear2[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear2[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate22() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear2[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear2[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear2[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate31() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear3[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear3[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear3[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate32() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear3[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear3[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear3[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate41() {\r\n    int arr[8] = { 0, };\r\n    arr[0] = gear4[7];\r\n    for (int i = 1; i &lt; 8; i++) {\r\n        arr[i] = gear4[i - 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear4[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate42() {\r\n    int arr[8] = { 0, };\r\n    arr[7] = gear4[0];\r\n    for (int i = 0; i &lt; 7; i++) {\r\n        arr[i] = gear4[i + 1];\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        gear4[i] = arr[i];\r\n    }\r\n}\r\nvoid rotate1(int a) {\r\n    if (a == 1) {\r\n        if (gear1[2] != gear2[6]) {\r\n            if (gear2[2] != gear3[6]) {\r\n                if (gear3[2] != gear4[6]) {\r\n                    rotate11();\r\n                    rotate22();\r\n                    rotate31();\r\n                    rotate42();\r\n                }\r\n                else {\r\n                    rotate11();\r\n                    rotate22();\r\n                    rotate31();\r\n                }\r\n            }\r\n            else {\r\n                rotate11();\r\n                rotate22();\r\n            }\r\n        }\r\n        else {\r\n            rotate11();\r\n        }\r\n    }\r\n    else if (a == -1) {\r\n        if (gear1[2] != gear2[6]) {\r\n            if (gear2[2] != gear3[6]) {\r\n                if (gear3[2] != gear4[6]) {\r\n                    rotate12();\r\n                    rotate21();\r\n                    rotate32();\r\n                    rotate41();\r\n                }\r\n                else {\r\n                    rotate12();\r\n                    rotate21();\r\n                    rotate32();\r\n                }\r\n            }\r\n            else {\r\n                rotate12();\r\n                rotate21();\r\n            }\r\n        }\r\n        else {\r\n            rotate12();\r\n        }\r\n    }\r\n}\r\nvoid rotate2(int a) {\r\n    if (a == 1) {\r\n        if (gear2[6] != gear1[2]) {\r\n            rotate12();\r\n        }\r\n        if (gear2[2] != gear3[6]) {\r\n            if (gear3[2] != gear4[6]) {\r\n                rotate32();\r\n                rotate41();\r\n            }\r\n            else {\r\n                rotate32();\r\n            }\r\n        }\r\n        rotate21();\r\n    }\r\n    else if (a == -1) {\r\n        if (gear2[6] != gear1[2]) {\r\n            rotate11();\r\n        }\r\n        if (gear2[2] != gear3[6]) {\r\n            if (gear3[2] != gear4[6]) {\r\n                rotate31();\r\n                rotate42();\r\n            }\r\n            else {\r\n                rotate31();\r\n            }\r\n        }\r\n        rotate22();\r\n    }\r\n}\r\nvoid rotate3(int a) {\r\n    if (a == 1) {\r\n        if (gear3[2] != gear4[6]) {\r\n            rotate42();\r\n        }\r\n        if (gear3[6] != gear2[2]) {\r\n            if (gear2[6] != gear1[2]) {\r\n                rotate22();\r\n                rotate11();\r\n            }\r\n            else {\r\n                rotate22();\r\n            }\r\n        }\r\n        rotate31();\r\n    }\r\n    else if (a == -1) {\r\n        if (gear3[2] != gear4[6]) {\r\n            rotate41();\r\n        }\r\n        if (gear3[6] != gear2[2]) {\r\n            if (gear2[6] != gear1[2]) {\r\n                rotate21();\r\n                rotate12();\r\n            }\r\n            else {\r\n                rotate21();\r\n            }\r\n        }\r\n        rotate32();\r\n    }\r\n}\r\nvoid rotate4(int a) {\r\n    if (a == 1) {\r\n        if (gear4[6] != gear3[2]) {\r\n            if (gear3[6] != gear2[2]) {\r\n                if (gear2[6] != gear1[2]) {\r\n                    rotate41();\r\n                    rotate32();\r\n                    rotate21();\r\n                    rotate12();\r\n                }\r\n                else {\r\n                    rotate41();\r\n                    rotate32();\r\n                    rotate21();\r\n                }\r\n            }\r\n            else {\r\n                rotate41();\r\n                rotate32();\r\n            }\r\n        }\r\n        else {\r\n            rotate41();\r\n        }\r\n    }\r\n    else if (a == -1) {\r\n        if (gear4[6] != gear3[2]) {\r\n            if (gear3[6] != gear2[2]) {\r\n                if (gear2[6] != gear1[2]) {\r\n                    rotate42();\r\n                    rotate31();\r\n                    rotate22();\r\n                    rotate11();\r\n                }\r\n                else {\r\n                    rotate42();\r\n                    rotate31();\r\n                    rotate22();\r\n                }\r\n            }\r\n            else {\r\n                rotate42();\r\n                rotate31();\r\n            }\r\n        }\r\n        else {\r\n            rotate42();\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear1[i]);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear2[i]);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear3[i]);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        scanf(&quot;%1d&quot;, &gear4[i]);\r\n    }\r\n    scanf(&quot;%d&quot;, &K);\r\n    for (int i = 0; i &lt; K; i++) {\r\n        scanf(&quot;%d %d&quot;, &info[i].num, &info[i].di);\r\n    }\r\n    for (int i = 0; i &lt; K; i++) {\r\n        if (info[i].num == 1) {\r\n            rotate1(info[i].di);\r\n        }\r\n        else if (info[i].num == 2) {\r\n            rotate2(info[i].di);\r\n        }\r\n        else if (info[i].num == 3) {\r\n            rotate3(info[i].di);\r\n        }\r\n        else if (info[i].num == 4) {\r\n            rotate4(info[i].di);\r\n        }\r\n    }\r\n    if (gear1[0] == 1) {\r\n        res += 1;\r\n    }\r\n    if (gear2[0] == 1) {\r\n        res += 2;\r\n    }\r\n    if (gear3[0] == 1) {\r\n        res += 4;\r\n    }\r\n    if (gear4[0] == 1) {\r\n        res += 8;\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-03-16 01:16:42',67),(12151526,'SW',5644,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint T, M, A;\r\nstruct st {\r\n    int x;\r\n    int y;\r\n    int energy;\r\n};\r\nstruct aaa {\r\n    int x;\r\n    int y;\r\n    int c;\r\n    int p;\r\n};\r\nstruct stst{\r\n    int p;\r\n    int i;\r\n};\r\nst user_A;\r\nst user_B;\r\nint m[2][100];\r\nstst map[11][11][2];\r\nint dx[5] = { 0,-1,0,1,0 };\r\nint dy[5] = { 0,0,1,0,-1 };\r\nvector&lt;aaa&gt; ap;\r\nbool compare(stst s2, stst s3) {\r\n    return s2.p &gt; s3.p;\r\n}\r\nvoid change(int Y, int X, int p, int i) {\r\n    if (map[X][Y][0].p == 0) {\r\n        map[X][Y][0].p = p;\r\n        map[X][Y][0].i = i;\r\n    }\r\n    else {\r\n        if (map[X][Y][1].p == 0) {\r\n            if (map[X][Y][0].p &gt;= p) {\r\n                map[X][Y][1].p = p;\r\n                map[X][Y][1].i = i;\r\n            }\r\n            else {\r\n                int va = map[X][Y][0].p;\r\n                int va2 = map[X][Y][0].i;\r\n                map[X][Y][0].p = p;\r\n                map[X][Y][0].i = i;\r\n                map[X][Y][1].p = va;\r\n                map[X][Y][1].i = va2;\r\n            }\r\n        }\r\n        else {\r\n            vector&lt;stst&gt;va;\r\n            stst stst2, stst3, stst4;\r\n            stst2.i = map[X][Y][0].i;\r\n            stst2.p = map[X][Y][0].p;\r\n            stst3.i = map[X][Y][1].i;\r\n            stst3.p = map[X][Y][1].p;\r\n            stst4.i = i;\r\n            stst4.p = p;\r\n            va.push_back(stst2);\r\n            va.push_back(stst3);\r\n            va.push_back(stst4);\r\n            sort(va.begin(), va.end(), compare);\r\n            for (int k = 0; k &lt; 2; k++) {\r\n                map[X][Y][k].p = va[k].p;\r\n                map[X][Y][k].i = va[k].i;\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid apap() {\r\n    for (int i = 0; i &lt; ap.size(); i++) {\r\n        int x = ap[i].x; int y = ap[i].y; int p = ap[i].p; int c = ap[i].c;\r\n        for (int j = 0; j &lt; 2 * c + 1; j++) {\r\n            if (x - c + j &gt;= 1 && y &gt;= 1 && x - c + j &lt;= 10 && y &lt;= 10) {\r\n                change(x - c + j, y, p, i);\r\n            }\r\n        }\r\n        for (int j = 1; j &lt;= c; j++) {\r\n            for (int k = 0; k &lt; 2 * c + 1 - 2 * j; k++) {\r\n                if (x - c + j + k &gt;= 1 && y + j &gt;= 1 && x - c + j + k &lt;= 10 && y + j &lt;= 10) {\r\n                    change(x - c + j + k, y + j, p, i);\r\n                }\r\n                if (x - c + j + k &gt;= 1 && y - j &gt;= 1 && x - c + j + k &lt;= 10 && y - j &lt;= 10) {\r\n                    change(x - c + j + k, y - j, p, i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid go() {\r\n    if (map[user_A.x][user_A.y][0].p != 0) {\r\n        user_A.energy += map[user_A.x][user_A.y][0].p;\r\n    }\r\n    if (map[user_B.x][user_B.y][0].p != 0) {\r\n        user_B.energy += map[user_B.x][user_B.y][0].p;\r\n    }\r\n    for (int i = 0; i &lt; M; i++) {\r\n        user_A.x += dx[m[0][i]];\r\n        user_A.y += dy[m[0][i]];\r\n        user_B.x += dx[m[1][i]];\r\n        user_B.y += dy[m[1][i]];\r\n        if (map[user_A.x][user_A.y][0].p == 0&& map[user_B.x][user_B.y][0].p == 0) {\r\n        }\r\n        else if (map[user_A.x][user_A.y][0].p != 0 && map[user_B.x][user_B.y][0].p == 0) {\r\n            user_A.energy += map[user_A.x][user_A.y][0].p;\r\n        }\r\n        else if (map[user_A.x][user_A.y][0].p == 0 && map[user_B.x][user_B.y][0].p != 0) {\r\n            user_B.energy += map[user_B.x][user_B.y][0].p;\r\n        }\r\n        else if (map[user_A.x][user_A.y][0].p != 0 && map[user_B.x][user_B.y][0].p != 0) {\r\n            if (map[user_A.x][user_A.y][0].i == map[user_B.x][user_B.y][0].i) {\r\n                user_A.energy += map[user_A.x][user_A.y][0].p;\r\n                user_B.energy += max(map[user_A.x][user_A.y][1].p, map[user_B.x][user_B.y][1].p);\r\n            }\r\n            else {\r\n                user_A.energy += map[user_A.x][user_A.y][0].p;\r\n                user_B.energy += map[user_B.x][user_B.y][0].p;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int o = 0; o &lt; T; o++) {\r\n        user_A.x = 1; user_A.y = 1; user_A.energy = 0;\r\n        user_B.x = 10; user_B.y = 10; user_B.energy = 0;\r\n        cin &gt;&gt; M &gt;&gt; A;\r\n        ap.clear();\r\n        for (int i = 0; i &lt; 11; i++) {\r\n            for (int j = 0; j &lt; 11; j++) {\r\n                for (int k = 0; k &lt; 2; k++) {\r\n                    map[i][j][k].p = 0;\r\n                    map[i][j][k].i = 0;\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; 2; i++) {\r\n            for (int j = 0; j &lt; M; j++) {\r\n                cin &gt;&gt; m[i][j];\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; A; i++) {\r\n            aaa aaa2;\r\n            cin &gt;&gt; aaa2.x &gt;&gt; aaa2.y &gt;&gt; aaa2.c &gt;&gt; aaa2.p;\r\n            ap.push_back(aaa2);\r\n        }\r\n        apap();\r\n        go();\r\n        cout &lt;&lt; &quot;#&quot; &lt;&lt; o + 1 &lt;&lt; &quot; &quot; &lt;&lt; user_A.energy + user_B.energy &lt;&lt; endl;\r\n    }\r\n}','2020-03-16 01:17:03',68),(12151526,'BJ',2565,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;queue&gt;\r\nusing namespace std;\r\nstruct lo {\r\n    int x;\r\n    int y;\r\n};\r\nbool cmp (const lo &u, const lo &o) {\r\n    return u.x &lt; o.x;\r\n}\r\nlo A[500] = { 0, };\r\npriority_queue&lt;int&gt; answer;\r\nint N;\r\nint MX = 0;\r\nint res = 0;\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    int b = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; A[i].x &gt;&gt; A[i].y;\r\n    }\r\n    sort(A, A + N, cmp);\r\n    int dp[500] = { 0, };\r\n    for (int i = 0; i &lt; N; i++) {\r\n        dp[i] = 1;\r\n        MX = 1;\r\n        for (int j = 0; j &lt; i; j++) {\r\n            if (A[i].y &gt; A[j].y) {\r\n                res = dp[j] + dp[i];\r\n                MX = max(res, MX);\r\n            }\r\n        }\r\n        dp[i] = MX;\r\n        answer.push(MX);\r\n    }\r\n    cout &lt;&lt; N - answer.top();\r\n}','2020-03-16 01:17:21',69),(12151601,'BJ',1904,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int N, ans, cnt[2];\r\n    cin &gt;&gt; N;\r\n    cnt[0] = 1;\r\n    cnt[1] = 1;\r\n    ans = 1;\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        ans = (cnt[0] + cnt[1]) % 15746;\r\n        cnt[0] = cnt[1];\r\n        cnt[1] = ans;\r\n    }\r\n    cout &lt;&lt; ans;\r\n}','2020-03-16 02:35:08',70),(12151526,'BJ',1904,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N;\r\n\r\nlong long arr[1000000] = { 0, };\r\nlong long pibo(int n) {\r\n    arr[1] = 1;\r\n    arr[2] = 2;\r\n    if (n &gt;= 3) {\r\n        for (int i = 3; i &lt;= n; i++) {\r\n            arr[i] = (arr[i - 1] + arr[i - 2]) % 15746;\r\n        }\r\n    }\r\n    return arr[n];\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    cout &lt;&lt; pibo(N);\r\n}','2020-03-16 12:27:53',71),(12151601,'SW',5644,'//테케 50개중 40개 맞고 테케 5가 안됩니다\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\n\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\nint route[2][100], M;\r\n\r\nstruct battery {\r\n    int n, p;\r\n};\r\nvector&lt;battery&gt; bc[10][10];\r\n\r\nstruct location {\r\n    int x, y;\r\n};\r\n\r\nlocation A[2];\r\n\r\nvoid area(int x, int y, int c, int p, int o) {\r\n    queue&lt;pair&lt;int, location&gt;&gt; q;\r\n    bool visit[10][10] = { false };\r\n    visit[x][y] = true;\r\n    bc[x][y].push_back({ o,p });\r\n    q.push({ 0,{x,y} });\r\n    while (!q.empty()) {\r\n        int n = q.front().first;\r\n        x = q.front().second.x;\r\n        y = q.front().second.y;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = x + dx[i];\r\n            int ny = y + dy[i];\r\n            if (nx &lt; 10 && nx &gt;= 0 && ny &lt; 10 && ny &gt;= 0) {\r\n                if (visit[nx][ny])\r\n                    continue;\r\n                visit[nx][ny] = true;\r\n                if (n &lt; c) {\r\n                    bc[nx][ny].push_back({ o,p });\r\n                    q.push({ n + 1, { nx,ny } });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint move() {\r\n    int charge = 0;\r\n    for (int i = 0; i &lt;= M; i++) {\r\n        for (int a = 0; a &lt; 2; a++) {\r\n            int d = route[a][i] - 1;\r\n            if (d != -1) {\r\n                A[a].x += dx[d];\r\n                A[a].y += dy[d];\r\n            }\r\n        }\r\n        int Abc = bc[A[0].x][A[0].y].size();\r\n        int Bbc = bc[A[1].x][A[1].y].size();\r\n        int power = 0;\r\n        int temp;\r\n        if (Abc && Bbc) {\r\n            for (int a = 0; a &lt; Abc; a++) {\r\n                for (int b = 0; b &lt; Bbc; b++) {\r\n                    temp = 0;\r\n                    if (bc[A[0].x][A[0].y][a].n == bc[A[1].x][A[1].y][b].n) {\r\n                        temp += bc[A[0].x][A[0].y][a].p;\r\n                    }\r\n                    else {\r\n                        temp += bc[A[0].x][A[0].y][a].p + bc[A[1].x][A[1].y][b].p;\r\n                    }\r\n                    power = power &gt; temp ? power : temp;\r\n                }\r\n            }\r\n        }\r\n        else if (!Abc) {\r\n            for (int b = 0; b &lt; Bbc; b++) {\r\n                temp = 0;\r\n                temp += bc[A[1].x][A[1].y][b].p;\r\n                power = power &gt; temp ? power : temp;\r\n            }\r\n        }\r\n        else if (!Bbc) {\r\n            for (int a = 0; a &lt; Abc; a++) {\r\n                temp = 0;\r\n                temp += bc[A[0].x][A[0].y][a].p;\r\n                power = power &gt; temp ? power : temp;\r\n            }\r\n        }\r\n\r\n        charge += power;\r\n    }\r\n    return charge;\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int t = 1; t &lt;= T; t++) {\r\n        for (int i = 0; i &lt; 10; i++) {\r\n            for (int j = 0; j &lt; 10; j++) {\r\n                bc[i][j].clear();\r\n\r\n            }\r\n        }\r\n        int a, x, y, c, p;\r\n        cin &gt;&gt; M &gt;&gt; a;\r\n        for (int i = 0; i &lt; 2; i++) {\r\n            for (int j = 1; j &lt;= M; j++) {\r\n                cin &gt;&gt; route[i][j];\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; a; i++) {\r\n            cin &gt;&gt; y &gt;&gt; x &gt;&gt; c &gt;&gt; p;\r\n            area(x - 1, y - 1, c, p, i);\r\n        }\r\n        A[0].x = A[0].y = 0;\r\n        A[1].x = A[1].y = 9;\r\n        cout &lt;&lt; &#39;#&#39; &lt;&lt; t &lt;&lt; &#39; &#39; &lt;&lt; move() &lt;&lt; endl;\r\n\r\n    }\r\n}','2020-03-16 16:28:34',72),(12151536,'BJ',1912,'#include &lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint number[100001];\r\nint dp[100001];\r\nint value = -1001;\r\n\r\nint main() {\r\n    int n;\r\n    scanf(&quot;%d&quot;, &n);\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        scanf(&quot;%d&quot;, &number[i]);\r\n    }\r\n\r\n    dp[0] = 0;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        if (number[i] &lt;= dp[i - 1] + number[i]) {\r\n            dp[i] = dp[i - 1] + number[i];\r\n        }\r\n        else {\r\n            dp[i] = number[i];\r\n        }\r\n    }\r\n    for (int i = 1; i &lt;= n; i++) {\r\n            value = max(dp[i], value);\r\n    }\r\n    printf(&quot;%d&quot;, value);\r\n    \r\n}','2020-03-16 16:33:38',73),(12151551,'SW',5644,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\ntypedef struct info {\r\n    int y;\r\n    int x;\r\n    int C;\r\n    int P;\r\n}in;\r\n\r\nint dx[] = {0,-1,0,1,0 };\r\nint dy[] = {0,0,1,0,-1 };\r\n\r\nvector&lt;int&gt; A;\r\nvector&lt;int&gt; B;\r\nvector&lt;in&gt; BC;\r\nvector&lt;int&gt; check;\r\nvector&lt;int&gt; power;\r\nint M, S;\r\n\r\n\r\nint charge(int ax,int ay, int bx, int by) {\r\n    for (int i = 0; i &lt; BC.size(); i++)\r\n        power[i] = 0;\r\n    int sum = 0;\r\n    for (int i = 0; i &lt; BC.size(); i++) {\r\n        if ((abs(BC[i].y - ax) + abs(BC[i].x - ay)) &lt;= BC[i].C)\r\n            power[i]++;\r\n        if ((abs(BC[i].y - bx) + abs(BC[i].x - by)) &lt;= BC[i].C)\r\n            power[i]++;\r\n    }\r\n    int ss = 0;\r\n    for (int i = 0; i &lt; BC.size(); i++) {\r\n        if (power[i] == 0)\r\n            continue;\r\n        else {\r\n            power[i] = 0;\r\n            ss = max(ss,BC[i].P);\r\n            for (int j = i + 1; j &lt; BC.size(); j++) {\r\n                if (power[j] == 0) continue;\r\n                ss = max(ss,ss + BC[j].P);\r\n            }\r\n        }\r\n    }\r\n    return sum;\r\n}\r\n\r\nint move() {\r\n    int nxa = 1;\r\n    int nya = 1;\r\n    int nxb = 10;\r\n    int nyb = 10;\r\n    int result = charge(nxa, nya, nxb, nyb);\r\n    for (int i = 0; i &lt; M; i++) {\r\n        nxa = nxa + dx[A[i]];\r\n        nya = nya + dy[A[i]];\r\n        nxb = nxb + dx[B[i]];\r\n        nyb = nyb + dy[B[i]];\r\n        result = result + charge(nya, nxa, nyb, nxb);\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int q = 0; q &lt; T; q++) {\r\n        cin &gt;&gt; M &gt;&gt; S;\r\n        for (int i = 0; i &lt; M; i++) {\r\n            int dir;\r\n            cin &gt;&gt; dir;\r\n            A.push_back(dir);\r\n        }\r\n        for (int i = 0; i &lt; M; i++) {\r\n            int dir;\r\n            cin &gt;&gt; dir;\r\n            B.push_back(dir);\r\n        }\r\n        for (int i = 0; i &lt; S; i++) {\r\n            info information;\r\n            cin &gt;&gt; information.y &gt;&gt; information.x &gt;&gt; information.C &gt;&gt; information.P;\r\n            BC.push_back(information);\r\n        }\r\n        for (int i = 0; i &lt; BC.size(); i++)\r\n            power.push_back(0);\r\n\r\n        cout &lt;&lt; &quot;#&quot;&lt;&lt;q+1&lt;&lt;&quot; &quot;&lt;&lt;move() &lt;&lt; endl;\r\n    }\r\n\r\n}','2020-03-16 16:38:17',74),(12151629,'BJ',2565,'N = int(input())\r\ninfo = [0 for _ in range(501)]\r\ndp = [0 for _ in range(501)]\r\ndp_MAX = [0 for _ in range(501)]\r\nfor _ in range(N):\r\n    a, b = map(int, input().split())\r\n    info[a] = b\r\nfor idx1, line1 in enumerate(info):\r\n    temp = list()\r\n    for idx2, line2 in enumerate(info[:idx1]):\r\n        if line2 &lt; line1:\r\n            temp.append(dp[idx2] + 1)\r\n    if len(temp) &gt; 0:\r\n        dp[idx1] = max(temp)\r\n\r\nprint(N - max(dp))','2020-03-16 17:08:27',75),(12151629,'BJ',14891,'state = [input() for _ in range(4)]\r\ntemp = [0, 0, 0, 0]\r\n\r\ndef spin(num, dir):\r\n    global state, temp, already\r\n    if already[num-1] == 0:\r\n        already[num - 1] = 1\r\n        # num -1 , 1 : 시계 방향, -1 : 반시계 방향\r\n        if num == 1:\r\n            # 첫번째 톱니의 3시와 두번째 톱니의 9시가 다르다면\r\n            if state[0][(temp[0] + 2) % 8] != state[1][(temp[1] + 6) % 8] and already[1] == 0:\r\n                if dir == 1:\r\n                    spin(2, -1)\r\n                else:\r\n                    spin(2, 1)\r\n\r\n        elif num == 2:\r\n            # 2번째 톱니의 3시와 3번째 톱니의 9시가 다르다면\r\n            if state[1][(temp[1] + 2) % 8] != state[2][(temp[2] + 6) % 8] and already[2] == 0:\r\n                if dir == 1:\r\n                    spin(3, -1)\r\n                else:\r\n                    spin(3, 1)\r\n\r\n            # 2번째 톱니의 9시와 1번째 톱니의 3시가 다르다면\r\n            if state[1][(temp[1] + 6) % 8] != state[0][(temp[0] + 2) % 8] and already[0] == 0:\r\n                if dir == 1:\r\n                    spin(1, -1)\r\n                else:\r\n                    spin(1, 1)\r\n\r\n        elif num == 3:\r\n            # 3번째 톱니의 3시와 4번째 톱니의 9시가 다르다면\r\n            if state[2][(temp[2] + 2) % 8] != state[3][(temp[3] + 6) % 8] and already[3] == 0:\r\n                if dir == 1:\r\n                    spin(4, -1)\r\n                else:\r\n                    spin(4, 1)\r\n\r\n            # 3번째 톱니의 9시와 2번째 톱니의 3시가 다르다면\r\n            if state[2][(temp[2] + 6) % 8] != state[1][(temp[1] + 2) % 8] and already[1] == 0:\r\n                if dir == 1:\r\n                    spin(2, -1)\r\n                else:\r\n                    spin(2, 1)\r\n\r\n        elif num == 4:\r\n            # 4번째 톱니의 9시와 3번째 톱니의 3시가 다르다면\r\n            if state[3][(temp[3] + 6) % 8] != state[2][(temp[2] + 2) % 8] and already[2] == 0:\r\n                if dir == 1:\r\n                    spin(3, -1)\r\n                else:\r\n                    spin(3, 1)\r\n\r\n        if dir == 1:\r\n            temp[num-1] = (temp[num-1] + 7) % 8\r\n        else:\r\n            temp[num-1] = (temp[num-1] + 1) % 8\r\n\r\nfor _ in range(int(input())):\r\n    already = [0, 0, 0, 0]\r\n    num, direction = map(int, input().split())\r\n    spin(num, direction)\r\n\r\nanswer = 0\r\nif state[0][temp[0]] == &#39;1&#39;:\r\n    answer += 1\r\nif state[1][temp[1]] == &#39;1&#39;:\r\n    answer += 2\r\nif state[2][temp[2]] == &#39;1&#39;:\r\n    answer += 4\r\nif state[3][temp[3]] == &#39;1&#39;:\r\n    answer += 8\r\nprint(answer)\r\n','2020-03-16 17:42:16',76),(12151629,'BJ',1912,'N = int(input())\r\nnum_list = list(map(int, input().split()))\r\nmax_list = [0 for _ in range(N)]\r\nfor idx, i in enumerate(num_list):\r\n    if idx == 0:\r\n        max_list[idx] = i\r\n    else:\r\n        if max_list[idx-1] + i &lt; i:\r\n            max_list[idx] = i\r\n        else:\r\n            max_list[idx] = max_list[idx-1] + i\r\nprint(max(max_list))','2020-03-16 18:15:02',77),(12151536,'BJ',14891,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nint wheel[4][8];\r\nvoid check_r(int wheel[][8], int wheel_num);\r\nvoid check_l(int wheel[][8], int wheel_num);\r\nbool check_arr[4] = { 0 };\r\n\r\nvoid rotate_r(int wheel[][8],int wheel_num) {\r\n    if (wheel_num &gt; 3)return;\r\n    int new_wheel[8];\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        if (i == 0)\r\n            new_wheel[0] = wheel[wheel_num][7];\r\n        else\r\n            new_wheel[i] = wheel[wheel_num][i - 1];\r\n    }\r\n    \r\n    if (check_arr[wheel_num] == false) {\r\n        check_r(wheel, wheel_num);\r\n    }\r\n    \r\n    for(int i = 0; i &lt; 8;i++)\r\n        wheel[wheel_num][i] = new_wheel[i];\r\n\r\n}\r\n\r\nvoid rotate_l(int wheel[][8], int wheel_num) {\r\n    int a;\r\n    a = wheel_num;\r\n    if (wheel_num &gt; 3)return;\r\n    int new_wheel[8];\r\n    for (int i = 0; i &lt; 8; i++) {\r\n        if (i == 7)\r\n            new_wheel[7] = wheel[wheel_num][0];\r\n        else\r\n            new_wheel[i] = wheel[wheel_num][i + 1];\r\n        \r\n    }\r\n    if (check_arr[wheel_num] == false) {\r\n        check_l(wheel, a);\r\n    }\r\n    for (int i = 0; i &lt; 8; i++)\r\n        wheel[wheel_num][i] = new_wheel[i];\r\n    \r\n\r\n}\r\n\r\nvoid check_r(int wheel[][8], int wheel_num) {\r\n    int a;\r\n    a = wheel_num;\r\n    check_arr[wheel_num] = true;\r\n    if (wheel_num &gt; 3)return;\r\n    if (wheel[wheel_num][2] != wheel[wheel_num + 1][6]) { //오른쪽놈이랑 다른극\r\n        //오른쪽놈 반시계\r\n        if (check_arr[a + 1] == false) {\r\n            rotate_l(wheel, a + 1);\r\n        }\r\n        \r\n    }\r\n    if (wheel[wheel_num][6] != wheel[wheel_num - 1][2]) { //왼쪽 놈이랑 다른극\r\n        //왼쪽놈 반시계\r\n        if (check_arr[a - 1] == false) {\r\n            rotate_l(wheel, a - 1);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid check_l(int wheel[][8], int wheel_num) {\r\n    int a;\r\n    a = wheel_num;\r\n    check_arr[wheel_num] = true;\r\n    if (wheel_num &gt; 3)return;\r\n    if (wheel[wheel_num][2] != wheel[wheel_num + 1][6]) { //오른쪽놈이랑 다른극\r\n        //오른쪽놈 반시계\r\n        if (check_arr[a + 1] == false)\r\n            rotate_r(wheel, a + 1);\r\n    }\r\n    if (wheel[wheel_num][6] != wheel[wheel_num - 1][2]) { //왼쪽 놈이랑 다른극\r\n        //왼쪽놈 반시계\r\n        if (check_arr[a - 1] == false)\r\n            rotate_r(wheel, a - 1);\r\n    }\r\n\r\n}\r\n\r\nint main() {\r\n    int k;\r\n    int select[101];\r\n    int rotate[101];\r\n    for (int i = 0; i &lt; 4; i++ ) {\r\n        for (int j = 0; j &lt; 8; j++) {\r\n            scanf(&quot;%1d&quot;, &wheel[i][j]);\r\n        }\r\n    }\r\n\r\n    scanf(&quot;%d&quot;, &k);\r\n    for (int i = 0; i &lt; k; i++) {\r\n        scanf(&quot;%d %d&quot;, &select[i], &rotate[i]);\r\n        select[i] -= 1;\r\n    }\r\n\r\n    \r\n    for (int i = 0; i &lt; k; i++) {\r\n        if (rotate[i] == 1) {\r\n            //시계방향 회전\r\n            for (int j = 0; j &lt; 4; j++)\r\n                check_arr[j] = false;\r\n            rotate_r(wheel, select[i]);\r\n        }\r\n        else if(rotate[i] == -1){\r\n            //반시계 회전\r\n            for (int j = 0; j &lt; 4; j++)\r\n                check_arr[j] = false;\r\n            rotate_l(wheel, select[i]);\r\n        }\r\n    }\r\n    \r\n\r\n    /*\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        for (int j = 0; j &lt; 8; j++) {\r\n            printf(&quot;%d&quot;, wheel[i][j]);\r\n        }\r\n        printf(&quot;inha_univ&quot;);\r\n    }\r\n    */\r\n\r\n    int score = 0;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        if (wheel[i][0] == 1)\r\n            score += pow(2,i);\r\n    }\r\n    printf(&quot;%d&quot;, score);\r\n}','2020-03-16 18:50:00',78),(12151536,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;cstdio&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\npair&lt;int, int&gt; item[101];\r\nint dp[101][100001];\r\n\r\nint main() {\r\n    int n, k;\r\n    scanf(&quot;%d %d&quot;, &n, &k);\r\n    int w = 0;\r\n    int max_result;\r\n    \r\n\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        scanf(&quot;%d %d&quot;, &item[i].first, &item[i].second);\r\n    }\r\n    sort(item, item + n + 1);\r\n\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= k; j++) {\r\n            if (j &lt; item[i].first) { //해당 물건 넣을수 없을 때\r\n                dp[i][j] = dp[i-1][j];\r\n            }\r\n            else { // 넣을 수 있을 때는 이전 단계에서 해당 무게 일 때 최대 vs 지금 물건 넣고, + 남은 무게에서의 최대\r\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - item[i].first] + item[i].second);\r\n            }\r\n        }\r\n    }\r\n\r\n    printf(&quot;%d&quot;, dp[n][k]);\r\n    /*\r\n    for (int i = 0; i &lt; n; i++) {\r\n        w = k - weight[i];\r\n        result[i] = value[i];\r\n        for (int j = i + 1; j &lt; n; j++) {\r\n            if (w &gt;= weight[j]) {\r\n                w -= weight[j];\r\n                result[i] += value[j];\r\n            }\r\n        }\r\n        printf(&quot;%dinha_univ&quot;, result[i]);\r\n        max_result = max(result[i], max_result);\r\n    }\r\n    printf(&quot;%d&quot;, max_result);\r\n    */\r\n}','2020-03-16 18:51:25',79),(12161746,'BJ',1904,'#include&lt;iostream&gt;\r\n#include&lt;stdio.h&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint B[1000001];\r\nint cnt()\r\n{\r\n    if (N==0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (N == 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else {\r\n        B[0] = 1;        //첫번째 1\r\n        B[1] = 1;        //두번째 1\r\n        for (int i = 2; i &lt;= N; i++)\r\n        {\r\n            B[i] = (B[i - 1] + B[i - 2])%15746;        //줄여서 더해야됨\r\n        }\r\n        return B[N];\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    cnt();\r\n    cout &lt;&lt; cnt() &lt;&lt; endl;\r\n}','2020-03-17 16:53:08',80),(12151526,'BJ',10828,'import java.util.*;\r\nclass MyStack{\r\n    int va;\r\n    int[] arr;\r\n    public MyStack(){\r\n        va=-1;\r\n        arr = new int[10000];\r\n    }\r\n    void push(int a) {\r\n        va++;\r\n        arr[va]=a;\r\n    }\r\n    \r\n    int size() {\r\n        return va+1;\r\n    }\r\n    int empty() {\r\n        if(va==-1) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    int pop() {\r\n        if(va==-1) {\r\n            return -1;\r\n        }\r\n        else {\r\n            va--;\r\n            return arr[va+1];\r\n        }\r\n    }\r\n    int top() {\r\n        if(va==-1) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return arr[va];\r\n        }\r\n    }\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        MyStack exex=new MyStack();\r\n        Scanner sc=new Scanner(System.in);\r\n        int N;\r\n        N=sc.nextInt();\r\n        for(int i=0;i&lt;N+1;i++) {\r\n            String a=sc.nextLine();\r\n            String[] ar=a.split(&quot; &quot;);\r\n            if(ar[0].contentEquals(&quot;push&quot;)) {\r\n                exex.push(Integer.parseInt(ar[1]));\r\n            }\r\n            else if(ar[0].contentEquals(&quot;top&quot;)) {\r\n                System.out.println(exex.top());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;pop&quot;)) {\r\n                System.out.println(exex.pop());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;size&quot;)) {\r\n                System.out.println(exex.size());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;empty&quot;)) {\r\n                System.out.println(exex.empty());\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n','2020-03-20 18:15:27',81),(12151526,'BJ',10845,'import java.util.*;\r\nclass MyQueue{\r\n    int va;\r\n    int va2;\r\n    int[] arr;\r\n    public MyQueue(){\r\n        va=-1;\r\n        va2=-1;\r\n        arr = new int[10000];\r\n    }\r\n    public void push(int a) {\r\n        va2++;\r\n        arr[va2]=a;\r\n    }\r\n    public int size() {\r\n        return va2-va;\r\n    }\r\n    public int empty() {\r\n        if(va==va2) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    public int pop() {\r\n        if(va==va2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            va++;\r\n            return arr[va];\r\n        }\r\n    }\r\n    public int front() {\r\n        if(va==va2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return arr[va+1];\r\n        }\r\n    }\r\n    public int back() {\r\n        if(va==va2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return arr[va2];\r\n        }\r\n    }\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        MyQueue exex=new MyQueue();\r\n        Scanner sc=new Scanner(System.in);\r\n        int N;\r\n        N=sc.nextInt();\r\n        for(int i=0;i&lt;N+1;i++) {\r\n            String a=sc.nextLine();\r\n            String[] ar=a.split(&quot; &quot;);\r\n            if(ar[0].contentEquals(&quot;push&quot;)) {\r\n                exex.push(Integer.parseInt(ar[1]));\r\n            }\r\n            else if(ar[0].contentEquals(&quot;front&quot;)) {\r\n                System.out.println(exex.front());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;back&quot;)) {\r\n                System.out.println(exex.back());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;pop&quot;)) {\r\n                System.out.println(exex.pop());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;size&quot;)) {\r\n                System.out.println(exex.size());\r\n            }\r\n            else if(ar[0].contentEquals(&quot;empty&quot;)) {\r\n                System.out.println(exex.empty());\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}','2020-03-20 18:15:44',82),(12151526,'SW',4012,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint N2;\r\nint map[17][17];\r\nint team1[8];\r\nint mn = 9999999;\r\nvector&lt;int&gt; num;\r\nvector&lt;int&gt; num2;\r\n\r\nint calcul(int arr[]) {\r\n    int res = 0;\r\n    for (int i = 0; i &lt; N2; i++) {\r\n        for (int j = 0; j &lt; N2; j++) {\r\n            if (i == j) {\r\n            }\r\n            else {\r\n                res += map[arr[i]][arr[j]];\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid didi(int a, int arr[], vector&lt;int&gt; b) {\r\n    if (a == N2) {\r\n        int arr2[10] = { 0, };\r\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;pq;\r\n        for (int i = 0; i &lt; N2; i++) {\r\n            pq.push(arr[i]);\r\n        }\r\n        int vava = 0;\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            if (!pq.empty()) {\r\n                if (i == pq.top()) {\r\n                    pq.pop();\r\n                }\r\n                else {\r\n                    arr2[vava] = i;\r\n                    vava++;\r\n                }\r\n            }\r\n            else {\r\n                arr2[vava] = i;\r\n                vava++;\r\n            }\r\n        }\r\n        int res1 = calcul(arr);\r\n        int res2 = calcul(arr2);\r\n        int res3 = abs(res1 - res2);\r\n        if (res3 &lt; mn) {\r\n            mn = res3;\r\n        }\r\n    }\r\n    else {\r\n        int va = b.size();\r\n        for (int i = va - 1; i &gt;= 0; i--) {\r\n            arr[a] = b[i];\r\n            b.erase(b.begin() + i);\r\n            didi(a + 1, arr, b);\r\n        }\r\n    }\r\n}\r\n\r\nint  main() {\r\n    int T = 0;\r\n    cin &gt;&gt; T;\r\n    for (int o = 0; o &lt; T; o++) {\r\n        for (int i = 0; i &lt; 8; i++) {\r\n            team1[i] = 0;\r\n        }\r\n        mn = 9999999;\r\n        num.clear();\r\n        num2.clear();\r\n        cin &gt;&gt; N;\r\n        N2 = N / 2;\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            for (int j = 1; j &lt;= N; j++) {\r\n                cin &gt;&gt; map[i][j];\r\n            }\r\n        }\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            num.push_back(i);\r\n        }\r\n        num2 = num;\r\n        didi(0, team1, num);\r\n        cout &lt;&lt; &quot;#&quot;&lt;&lt;o+1&lt;&lt;&quot; &quot; &lt;&lt;mn&lt;&lt;endl;\r\n    }\r\n}','2020-03-17 19:05:35',83),(12151526,'SW',1952,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint T, a, b, c, d;\r\nint plan[13];\r\nint dp[2][13];\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int p = 0; p &lt; T; p++) {\r\n        for (int i = 0; i &lt; 12; i++) {\r\n            plan[i] = 0;\r\n            dp[0][i] = 0;\r\n            dp[1][i] = 0;\r\n        }\r\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\r\n        for (int i = 1; i &lt;= 12; i++) {\r\n            cin &gt;&gt; plan[i];\r\n        }\r\n        for (int i = 1; i &lt;= 12; i++) {\r\n            if (i &gt; 5) {\r\n                dp[0][i] = min(a*plan[i], b) + min(dp[0][i - 1], dp[1][i - 1]);\r\n                dp[1][i] = min(dp[0][i - 3], dp[1][i - 3]) + c;\r\n            }\r\n            else if (i == 4 || i == 5) {\r\n                dp[0][i] = min(a*plan[i], b) + min(dp[0][i - 1], dp[1][i - 1]);\r\n                dp[1][i] = c + dp[0][i - 3];\r\n            }\r\n            else if (i == 3) {\r\n                dp[0][i] = min(a*plan[i], b) + dp[0][i - 1];\r\n                dp[1][i] = c + dp[0][i - 3];\r\n            }\r\n            else {\r\n                dp[0][i] = min(a*plan[i], b) + dp[0][i - 1];\r\n            }\r\n        }\r\n        cout &lt;&lt; &quot;#&quot; &lt;&lt; p + 1 &lt;&lt; &quot; &quot; &lt;&lt; min(d, min(dp[0][12], dp[1][12])) &lt;&lt; endl;\r\n    }\r\n}','2020-03-17 19:05:50',84),(12151526,'BJ',15686,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\nint N, M;\r\nint map[50][50];\r\nstruct lo {\r\n    int x;\r\n    int y;\r\n};\r\nvector&lt;lo&gt;chi;\r\nvector&lt;int&gt;chi2;\r\nvector&lt;lo&gt;ho;\r\nint va = 9999999;\r\nvoid chicken(int a, vector&lt;int&gt; b, vector&lt;int&gt; c) {\r\n    vector&lt;int&gt; d = b;\r\n    if (a == M) {\r\n        int res = 0;\r\n        for (int i = 0; i &lt; ho.size(); i++) {\r\n            int min_num = 10000;\r\n            for (int j = 0; j &lt; c.size(); j++) {\r\n                min_num = min(min_num, abs(ho[i].x - chi[c[j]].x) + abs(ho[i].y - chi[c[j]].y));\r\n            }\r\n            res += min_num;\r\n        }\r\n        va = min(va, res);\r\n    }\r\n    else {\r\n        while(d.size()&gt;0) {\r\n            vector&lt;int&gt;e = c;\r\n            e.push_back(d[d.size()-1]);\r\n            d.pop_back();\r\n            chicken(a + 1, d, e);\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == 1) {\r\n                ho.push_back({ i, j });\r\n            }\r\n            else if (map[i][j] == 2) {\r\n                chi.push_back({ i,j });\r\n                chi2.push_back(chi.size() - 1);\r\n            }\r\n        }\r\n    }\r\n    vector&lt;int&gt;vava;\r\n    chicken(0, chi2, vava);\r\n    cout &lt;&lt; va;\r\n}','2020-03-17 19:44:45',85),(12151536,'BJ',1309,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint dp[100001][4];\r\nint ans;\r\nint n;\r\nint main() {\r\n    cin &gt;&gt; n;\r\n    dp[1][0] = 1;\r\n    dp[1][1] = 1;\r\n    dp[1][2] = 1;\r\n    for (int i = 2; i &lt;= n; i++) {\r\n        dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2])%9901;\r\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2])%9901;\r\n        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1])%9901;\r\n    }\r\n    for (int i = 0; i &lt; 3; i++) {\r\n        ans += dp[n][i];\r\n    }\r\n    cout &lt;&lt; ans % 9901;\r\n}','2020-03-17 20:19:19',86),(12151536,'BJ',15686,'#include &lt;iostream&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\n\r\npair&lt;int, int&gt; va[14]; //어떠한 치킨집을 최소 거리로 갖는 집의 수\r\nint n, m;\r\nint map[51][51];\r\nint house[102][2];\r\nint chicken[14][2];\r\n\r\nbool Select[14];\r\nint a[14];\r\nint dist[102];\r\nint min_dist[102];\r\nint real_min_dist[3433] = { 0 }; //14C7 이 최대\r\nint h_count = 1;\r\nint c_count = 1;\r\nint counter = 0;\r\nint cal_dist(int x1, int x2, int y1, int y2);\r\n\r\nvoid pickup(int count) {\r\n    for (int i = 0; i &lt;= 101; i++) {\r\n        min_dist[i] = 1000000;\r\n    }\r\n    int j = 1;\r\n    for (int i = 1; i &lt;= c_count; i++) {\r\n        if (Select[i] == true) {\r\n            a[j] = i;\r\n            j++;\r\n            //cout &lt;&lt; i;\r\n        }\r\n    }\r\n    //cout &lt;&lt; endl;\r\n\r\n    for (int i = 1; i &lt;= m; i++) {\r\n        for (int k = 1; k &lt;= h_count; k++) {\r\n            dist[k] = cal_dist(house[k][0],chicken[a[i]][0],house[k][1], chicken[a[i]][1]);\r\n            min_dist[k] = min(dist[k], min_dist[k]);\r\n        }\r\n    }\r\n    for (int i = 1; i &lt;= h_count; i++) {\r\n        real_min_dist[count] += min_dist[i];\r\n    }\r\n}\r\n\r\nvoid DFS(int Idx, int Cnt)\r\n{\r\n    if (Cnt == m)\r\n    {\r\n        pickup(counter);\r\n        counter++;\r\n        return;\r\n        \r\n    }\r\n\r\n    for (int i = Idx; i &lt;= c_count; i++)\r\n    {\r\n        if (Select[i] == true) continue;\r\n        Select[i] = true;\r\n        DFS(i, Cnt + 1);\r\n        Select[i] = false;\r\n    }\r\n}\r\n\r\n\r\nint cal_dist(int x1, int x2, int y1, int y2) { // |x1 - x2| + |y1 - y2|\r\n    int distance = abs(x1 - x2) + abs(y1 - y2);\r\n    return distance;\r\n}\r\n\r\nint main() {\r\n\r\n\r\n    scanf(&quot;%d %d&quot;, &n, &m);\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= n; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == 1) { //집 check\r\n                house[h_count][0] = i;\r\n                house[h_count][1] = j;\r\n                h_count++;\r\n            }\r\n            else if (map[i][j] == 2) { //치킨집 check\r\n                chicken[c_count][0] = i;\r\n                chicken[c_count][1] = j;\r\n                c_count++;\r\n            }\r\n        }\r\n    }\r\n    h_count--;\r\n    c_count--;\r\n    DFS(1, 0);\r\n    int ans = 10000000;\r\n    for (int i = 0; i &lt;= counter-1; i++) {\r\n        ans = min(ans, real_min_dist[i]);\r\n        //cout &lt;&lt; real_min_dist[i] &lt;&lt; endl;\r\n    }\r\n    cout &lt;&lt; ans;\r\n}','2020-03-17 21:57:04',87),(12151536,'SW',4012,'#include &lt;iostream&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint T;\r\nint N; // 4~16\r\nint S[17][17];\r\nbool Select[17];\r\nint counter = 0;\r\n\r\nint a[8]; //뽑힌 N/2개의 음식번호 저장\r\nint b[8]; //나머지 N/2개 저장\r\nint S_list[12871]; //시너지 저장 nCr\r\n\r\nint cal(int a, int b){\r\n    return abs(a - b);\r\n}\r\nvoid check(int counter) {\r\n    int j = 0;\r\n    int k = 0;\r\n    int A_sum = 0;\r\n    int B_sum = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        if (Select[i] == true) {\r\n            a[j] = i;\r\n            j++;\r\n        }\r\n        else {\r\n            b[k] = i;\r\n            k++;\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; N / 2; i++) {\r\n        for (int j = 0; j &lt; N / 2; j++) {\r\n            if (i != j) {\r\n                A_sum += S[a[i]][a[j]];\r\n                B_sum += S[b[i]][b[j]];\r\n            }\r\n        }\r\n    }\r\n    S_list[counter] = cal(A_sum, B_sum);\r\n\r\n}\r\n\r\nvoid DFS(int idx, int cnt) { //총 N개 중에서 N/2를 뽑는 조합\r\n    if (cnt == N / 2) {\r\n        check(counter);\r\n        counter++;\r\n        return;\r\n    }\r\n    for(int i = idx; i &lt; N; i++) {\r\n        if (Select[i] == true)continue;\r\n        Select[i] = true;\r\n        DFS(i, cnt + 1);\r\n        Select[i] = false;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int t = 1; t &lt;= T; t++) {\r\n        cin &gt;&gt; N;\r\n        counter = 0;\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; N; j++) {\r\n                cin &gt;&gt; S[i][j];\r\n            }\r\n        }\r\n        DFS(0, 0);\r\n        int ans = 1000000;\r\n        for (int i = 0; i &lt; counter; i++) {\r\n            ans = min(S_list[i], ans);\r\n        }\r\n        for (int i = 0; i &lt; counter; i++) {\r\n            S_list[i] = 0;\r\n        }\r\n        printf(&quot;#%d %dinha_univ&quot;, t,ans);\r\n    }\r\n    return 0;\r\n}','2020-03-18 15:44:39',88),(12151551,'SW',4012,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr[17][17] = { 0 };\r\nint check[17][17] = { 0 };\r\nbool visit[17] = { 0 };\r\nint T, N;\r\nint result = 10000000;\r\nint foodA[17] = { 0 };\r\nint foodB[17] = { 0 };\r\nint A = 1;\r\nint B = 1;\r\n\r\nvoid cal() {\r\n    int sum = 0;\r\n    int sum2 = 0;\r\n    for (int i = 1; i &lt;= N/2; i++) {\r\n        for (int j = i+1; j &lt;= N/2; j++) {\r\n            sum += check[foodA[i]][foodA[j]];\r\n            sum2 += check[foodB[i]][foodB[j]];\r\n        }\r\n    }\r\n    result = min(result, abs(sum-sum2));\r\n}\r\n\r\nvoid find(int num) {\r\n    //재귀\r\n    if (num &gt;= N) {\r\n        cal();\r\n        return;\r\n    }\r\n    if (A &lt;= N / 2) {\r\n        foodA[A] = num+1;\r\n        A++;\r\n        find(num + 1);\r\n        A--;\r\n    }\r\n    if (B &lt;= N / 2) {\r\n        foodB[B] = num+1;\r\n        B++;\r\n        find(num + 1);\r\n        B--;\r\n    }\r\n    \r\n}\r\n\r\nvoid make() {\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            check[i][j] = arr[i][j];\r\n        }\r\n    }\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            check[i][j] = check[i][j] + arr[j][i];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int i = 0; i &lt; T; i++) {\r\n        cin &gt;&gt; N;\r\n        A = 1;\r\n        B = 1;\r\n        result = 10000000;\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            for (int j = 1; j &lt;= N; j++) {\r\n                cin &gt;&gt; arr[i][j];\r\n            }\r\n        }\r\n        make();\r\n        find(0);\r\n        cout &lt;&lt; &quot;#&quot;&lt;&lt;i+1&lt;&lt;&quot; &quot;&lt;&lt;result &lt;&lt; endl;\r\n    }\r\n\r\n}','2020-03-19 10:18:07',89),(12151636,'BJ',10845,'import java.util.Scanner;\r\nimport java.util.*;\r\n\r\nclass queue{\r\n    int top;\r\n    int[] queue;\r\n    int size;\r\n    int f;\r\n    int b;\r\n    \r\n    public queue() {\r\n        top = -1;\r\n        queue = new int[10000];\r\n        size = 0;\r\n        f = 1;\r\n        b = 0;\r\n    }\r\n    public int size() {\r\n        return size;\r\n    }\r\n    public int empty() {\r\n        if(size==0)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n    public int front() {\r\n        if(empty()==1)\r\n            return -1;\r\n        else\r\n            return queue[f];\r\n    }\r\n    public int back() {\r\n        if(empty()==1)\r\n            return -1;\r\n        else\r\n            return queue[b];\r\n    }\r\n    public void pop() {\r\n        if(empty()==1)\r\n            System.out.println(-1);\r\n        else {\r\n        System.out.println(front());\r\n        size = size - 1;\r\n        f = f + 1;\r\n        }\r\n    }\r\n    public void push(int s){\r\n        size = size + 1;\r\n        b = b + 1;\r\n        queue[b] = s;\r\n    }\r\n\r\n}\r\npublic class Main{\r\n    public static void main(String[] args) {\r\n        queue st = new queue();\r\n        Scanner sc = new Scanner(System.in);\r\n        String line;\r\n        int str = sc.nextInt();\r\n        for(int i = 0; i&lt;str; i++) {\r\n            line = sc.next();\r\n            if(line.equals(&quot;push&quot;)) {\r\n                st.push(sc.nextInt());\r\n            }\r\n            else if(line.equals(&quot;pop&quot;))\r\n                st.pop();\r\n            else if(line.equals(&quot;front&quot;))\r\n                System.out.println(st.front());\r\n            else if(line.equals(&quot;back&quot;))\r\n                System.out.println(st.back());\r\n            else if(line.equals(&quot;size&quot;))\r\n                System.out.println(st.size());\r\n            else if(line.equals(&quot;empty&quot;))\r\n                System.out.println(st.empty());\r\n        }\r\n    }\r\n}\r\n','2020-03-19 13:14:05',90),(12151636,'BJ',10828,'import java.util.Scanner;\r\nimport java.util.*;\r\n\r\nclass stack{\r\n    int top;\r\n    int[] stack;\r\n    int size;\r\n    \r\n    public stack() {\r\n        top = -1;\r\n        stack = new int[1000000];\r\n        size = 0;\r\n    }\r\n    public int size() {\r\n        return size;\r\n    }\r\n    public int empty() {\r\n        if(size==0)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n    public int top() {\r\n        if(empty()==1)\r\n            return -1;\r\n        else\r\n            return stack[size];\r\n    }\r\n    public void pop() {\r\n        if(empty()==1)\r\n            System.out.println(-1);\r\n        else {\r\n        System.out.println(top());\r\n        size = size-1;\r\n        }\r\n    }\r\n    public void push(int s){\r\n        size = size + 1;\r\n        stack[size] = s;\r\n    }\r\n\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        stack st = new stack();\r\n        Scanner sc = new Scanner(System.in);\r\n        String line;\r\n        int str = sc.nextInt();\r\n        for(int i = 0; i&lt;str; i++) {\r\n            line = sc.next();\r\n            if(line.equals(&quot;push&quot;)) {\r\n                st.push(sc.nextInt());\r\n            }\r\n            else if(line.equals(&quot;pop&quot;))\r\n                st.pop();\r\n            else if(line.equals(&quot;top&quot;))\r\n                System.out.println(st.top());\r\n            else if(line.equals(&quot;size&quot;))\r\n                System.out.println(st.size());\r\n            else if(line.equals(&quot;empty&quot;))\r\n                System.out.println(st.empty());\r\n        }\r\n    }\r\n}\r\n','2020-03-19 13:14:43',91),(12151526,'SW',2112,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint T, D, W, K;\r\nint film[14][21];\r\nint film2[14][21];\r\nint arr3[14];\r\nbool change = false;\r\nint res = 0;\r\n\r\nbool test() {\r\n    bool va = true;\r\n    for (int i = 1; i &lt;= W; i++) {\r\n        int va2 = 1; int va3 = film[1][i];\r\n        for (int j = 2; j &lt;= D; j++) {\r\n            if (va3 == film[j][i]) {\r\n                va2++;\r\n                if (va2 == K) break;\r\n            }\r\n            else {\r\n                va2 = 1;\r\n                va3 = film[j][i];\r\n            }\r\n            if (j == D) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return va;\r\n}\r\nbool test2() {\r\n    bool va = true;\r\n    for (int i = 1; i &lt;= W; i++) {\r\n        int va2 = 1; int va3 = film2[1][i];\r\n        for (int j = 2; j &lt;= D; j++) {\r\n            if (va3 == film2[j][i]) {\r\n                va2++;\r\n                if (va2 == K) break;\r\n            }\r\n            else {\r\n                va2 = 1;\r\n                va3 = film2[j][i];\r\n            }\r\n            if (j == D) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return va;\r\n}\r\nvoid combi(int a, int b, int arr[], int d) {\r\n    if (change == false) {\r\n        if (a == d) {\r\n            int arr2[14] = { 0, };\r\n            for (int i = pow(2, a) - 1; i &gt;= 0; i--) {\r\n                int vava = i;\r\n                for (int j = 0; j &lt; a; j++) {\r\n                    arr2[j] = vava % 2;\r\n                    vava /= 2;\r\n                }\r\n                for (int j = 0; j &lt; a; j++) {\r\n                    for (int k = 1; k &lt;= W; k++) {\r\n                        film2[arr[j]][k] = arr2[j];\r\n                    }\r\n                }\r\n                change = test2();\r\n                if (change == true) {\r\n                    res = d;\r\n                    break;\r\n                }\r\n                for (int j = 0; j &lt; a; j++) {\r\n                    for (int k = 1; k &lt;= W; k++) {\r\n                        film2[arr[j]][k] = film[arr[j]][k];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            int arr2[14] = { 0, };\r\n            for (int i = 0; i &lt; a; i++) {\r\n                arr2[i] = arr[i];\r\n            }\r\n            for (int i = 1; i &lt;= b; i++) {\r\n                arr2[a] = i;\r\n                combi(a + 1, i-1, arr2, d);\r\n            }\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int o = 0; o &lt; T; o++) {\r\n        for (int i = 0; i &lt;= 14; i++) {\r\n            for (int j = 0; j &lt;= 21; j++) {\r\n                film[i][j] = 0;\r\n                film2[i][j] = 0;\r\n            }\r\n            arr3[i] = 0;\r\n        }\r\n        change = false;\r\n        res = 0;\r\n        cin &gt;&gt; D &gt;&gt; W &gt;&gt; K;\r\n        for (int i = 1; i &lt;= D; i++) {\r\n            for (int j = 1; j &lt;= W; j++) {\r\n                cin &gt;&gt; film[i][j];\r\n                film2[i][j] = film[i][j];\r\n            }\r\n        }\r\n        if (test() || K == 1) {\r\n            cout &lt;&lt; &quot;#&quot; &lt;&lt; o + 1 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; endl;\r\n        }\r\n        else {\r\n            for (int i = 1; i &lt;= K; i++) {\r\n                combi(0, D, arr3, i);\r\n                if (res &gt;= 1) {\r\n                    break;\r\n                }\r\n            }\r\n            cout &lt;&lt; &quot;#&quot; &lt;&lt; o + 1 &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt; endl;\r\n        }\r\n    }\r\n}','2020-03-20 13:58:46',92),(12171820,'BJ',1904,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin &gt;&gt; n;\r\n    int a[3];\r\n    a[0] = 1;\r\n    a[1] = 2;\r\n\r\n    \r\n    for (int i = 3; i &lt;= n; i++)\r\n    {\r\n        a[2] = (a[0] + a[1]) % 15746;\r\n        a[0] = a[1];\r\n        a[1] = a[2];\r\n    }\r\n    cout &lt;&lt; a[2];\r\n}','2020-03-20 14:49:15',93),(12161777,'BJ',1904,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint N; //자리수\r\n//점화식 N=1 &gt; 1 , N=2 &gt; 2,   3 이상의  N= (N-1) + (N-2)\r\nint dp[1000001];\r\n\r\nvoid result() {\r\n    dp[1] = 1;\r\n    dp[2] = 2;\r\n    for (int i = 3; i &lt;= N; i++) {\r\n        dp[i] = (dp[i - 1] + dp[i - 2]) % 15746;\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    cin &gt;&gt; N;\r\n    cout &lt;&lt; endl;\r\n    result();\r\n    cout &lt;&lt; dp[N] % 15746;\r\n    return 0;\r\n}','2020-03-20 18:17:03',94),(12151526,'BJ',1309,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N;\r\nint x[100001];\r\nint le[100001];\r\nint ri[100001];\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    x[1] = 1; le[1] = 1; ri[1] = 1;\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        x[i] = (x[i - 1] + le[i - 1] + ri[i - 1]) % 9901;\r\n        le[i] = (x[i - 1] + ri[i - 1]) % 9901;\r\n        ri[i] = (x[i - 1] + le[i - 1]) % 9901;\r\n    }\r\n    cout &lt;&lt; (x[N] + le[N] + ri[N]) % 9901;\r\n}','2020-03-20 18:57:31',95),(12151526,'BJ',11053,'#include&lt;iostream&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;queue&gt;\r\nusing namespace std;\r\n\r\npriority_queue&lt;int&gt; answer;\r\nint N;\r\nint A[1000] = { 0, };\r\nint dp[1000] = { 0, };\r\nint MX = 0;\r\nint res = 0;\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; A[i];\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        dp[i] = 1;\r\n        MX = 1;\r\n        for (int j = 0; j &lt; i; j++) {\r\n            if (A[i] &gt; A[j]) {\r\n                res = dp[j] + dp[i];\r\n                MX = max(res, MX);\r\n            }\r\n        }\r\n        dp[i] = MX;\r\n        answer.push(MX);\r\n    }\r\n    cout &lt;&lt; answer.top();\r\n}','2020-03-20 19:26:09',96),(12151526,'BJ',1021,'#include&lt;iostream&gt;\r\n#include&lt;deque&gt;\r\n#include&lt;queue&gt;\r\nusing namespace std;\r\ndeque&lt;int&gt; dq;\r\nqueue&lt;int&gt; qu;\r\nint N, M, res;\r\nvoid rotate(deque&lt;int&gt; dqdq) {\r\n    if (!qu.empty()) {\r\n        int va = 0, va2 = 0;\r\n        deque&lt;int&gt; dq2(dqdq);\r\n        deque&lt;int&gt; dq3(dqdq);\r\n        for (int i = 0; i &lt;= va; i++) {\r\n            if (qu.front() == dq2.front()) {\r\n                dq2.pop_front();\r\n            }\r\n            else {\r\n                va++;\r\n                dq2.push_back(dq2.front());\r\n                dq2.pop_front();\r\n            }\r\n        }\r\n        for (int i = 0; i &lt;= va2; i++) {\r\n            if (qu.front() == dq3.front()) {\r\n                dq3.pop_front();\r\n            }\r\n            else {\r\n                va2++;\r\n                dq3.push_front(dq3[dq3.size()-1]);\r\n                dq3.pop_back();\r\n            }\r\n        }\r\n        qu.pop();\r\n        if (va &lt;= va2) {\r\n            res += va;\r\n            rotate(dq2);\r\n        }\r\n        else {\r\n            res += va2;\r\n            rotate(dq3);\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        dq.push_back(i);\r\n    }\r\n    for (int i = 0; i &lt; M; i++) {\r\n        int a;\r\n        cin &gt;&gt; a;\r\n        qu.push(a);\r\n    }\r\n    rotate(dq);\r\n    cout &lt;&lt; res;\r\n}','2020-03-20 19:49:11',97),(12161777,'BJ',12865,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint W[101];\r\nint V[101];\r\nint dp[101][100001]; // n, 담을수 있는 무게 limit에 해당 하는 배열 &gt;&gt; 개수가 i일때 j 무게까지 넣었을때의 최대가치가 담긴 이중배열\r\n\r\nint main() {\r\n    int N, limit;\r\n\r\n    cin &gt;&gt; N &gt;&gt; limit;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; W[i] &gt;&gt; V[i];    // i번째 물건의 무게와 가치 입력\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++) {        //i는 물건 개수와 상응, j는 버틸수있는 최대무게와 상응\r\n        for (int j = 1; j &lt;= limit; j++) {\r\n            dp[i][j] = dp[i - 1][j];      //최대 가치에 포함되지 않는경우 (담지 않은경우)  : w[i]&gt;j일때\r\n            if (j - W[i] &gt;= 0) {\r\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - W[i]] + V[i]); //최대 가치산출에 포함된 경우(담은 경우) : w[i] &lt;= j &gt;&gt; w[i]를 넣어도 한계값인 j보다 작으므로\r\n                                                                      //j가 초과되기 전까지 최대한 새로들어온 물건과 이전 물건중에서의 최대가치값을 산출해봄\r\n            }   //이전의 최대값이었던 dp[i][j]와 개수가 늘었을 때의 최대값(dp[i-1][j - W[i]] + V[i])을 max를 통해 비교하여 새로운 최대값 갱신\r\n        }\r\n    }\r\n\r\n    cout &lt;&lt; dp[N][limit] &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-03-28 17:22:52',98),(12171820,'BJ',1021,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n; // 총 숫자\r\n    int m; // 내가 고를 숫자들 개수\r\n\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    int term = 0;\r\n    vector &lt;int&gt; q; // 숫자들\r\n    vector &lt;int&gt; ch; // 내가 고른\r\n    for (int i = 1; i &lt;=n; i++)\r\n    {\r\n        q.push_back((i));\r\n    }\r\n    for (int i = 1; i &lt;=m; i++)\r\n    {\r\n        int temp = 0;\r\n        cin &gt;&gt; temp;\r\n        ch.push_back(temp);\r\n    }\r\n\r\n    while (m != 0)\r\n    {\r\n        //제일 첫번째 숫자가 같을때 없에주구 내가고를 숫자를 줄여준다\r\n        if (ch[0] == q[0])\r\n        {\r\n            ch.erase(ch.begin());\r\n            q.erase(q.begin());\r\n            m--;\r\n            \r\n        }\r\n        else\r\n        {\r\n            int front=2;\r\n            for (int i = 0; i &lt; q.size(); i++)\r\n            {\r\n                if (q[i] == ch[0])\r\n                {\r\n                    front = 1;\r\n                    break;\r\n                }\r\n                else if (q[q.size() - 1 - i] == ch[0])\r\n                {\r\n                    front = 0;\r\n                    break;\r\n                }\r\n            }\r\n            if (front == 1)\r\n            {\r\n                while (ch[0] != q[0])\r\n                {\r\n                    q.push_back(q[0]);\r\n                    q.erase(q.begin());\r\n                    term++;\r\n                }\r\n            }\r\n            else if(front == 0)\r\n            {\r\n                while (ch[0] != q[0])\r\n                {\r\n                    q.insert(q.begin(), q.back());\r\n                    q.pop_back();\r\n                    term++;\r\n                }\r\n            }\r\n\r\n\r\n\r\n        }\r\n    }\r\n    cout &lt;&lt; term &lt;&lt; endl;\r\n\r\n}','2020-03-21 14:59:56',99),(12161777,'BJ',11053,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n\r\nint N;\r\nint A[1001];\r\nint dp[1001];\r\n\r\nint main() {\r\n    int sum = 0;\r\n\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; A[i];\r\n    }\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        dp[i] = 1;            //dp 1로 초기화\r\n\r\n        for (int j = 0; j &lt; i; j++)\r\n        {\r\n            if (A[i] &gt; A[j])        //A[i]과 이전의 값들을 비교하여 A[i]가 이전값 보다크면 +1 증가\r\n            {\r\n                dp[i] = max(dp[i], dp[j] + 1);\r\n            }\r\n        }\r\n        sum = max(sum, dp[i]); //dp와 sum을 비교하여 max값 갱신\r\n    }\r\n\r\n    cout &lt;&lt; sum &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-03-21 15:38:59',100),(12161783,'BJ',11054,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\nint A[1001];\r\nint dp[1001];\r\nint dp2[1001];\r\n\r\nint main()\r\n{\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n\r\n    int MIN = 0;\r\n    int MAX = 0;\r\n\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; A[i];\r\n    }\r\n\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        MIN = 0;\r\n        for (int j = 1; j &lt;= i; j++)\r\n        {\r\n            if (A[i] &gt; A[j] && dp[j] &gt; MIN)\r\n            {\r\n                MIN = dp[j];\r\n            }\r\n        }\r\n        dp[i] = MIN + 1;\r\n    }\r\n\r\n    for (int i = N; i &gt;= 1; i--) {\r\n        MIN = 0;\r\n        for (int j = N; j &gt;= i; j--) {\r\n            if (A[i] &gt; A[j] && dp2[j] &gt; MIN) {\r\n                MIN = dp2[j];\r\n            }\r\n        }\r\n        dp2[i] = MIN + 1;\r\n    }\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        if (MAX &lt; dp[i] + dp2[i]) {\r\n            MAX = dp[i] + dp2[i];\r\n        }\r\n    }\r\n\r\n    MAX = MAX - 1;\r\n    cout &lt;&lt; MAX &lt;&lt; endl;\r\n\r\n    return 0;\r\n}\r\n\r\n','2020-03-21 16:02:51',101),(12161783,'BJ',11053,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\nint A[1001];\r\nint dp[1001];\r\n\r\nint main()\r\n{\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n\r\n    int MIN = 0;\r\n    int MAX = 0;\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; A[i];\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        MIN = 0;\r\n        for (int j = 1; j &lt;= i; j++)\r\n        {\r\n            if (A[i] &gt; A[j]&&dp[j]&gt;MIN)\r\n            {\r\n                MIN =dp[j];\r\n            }\r\n        }\r\n        dp[i] = MIN + 1;\r\n\r\n        \r\n        if (MAX &lt; dp[i]) {\r\n            MAX = dp[i];\r\n        }\r\n    }\r\n\r\n    cout &lt;&lt; MAX &lt;&lt; endl;\r\n    return 0;\r\n}','2020-03-21 16:03:05',102),(12161783,'BJ',1904,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N;\r\n    int dp[10000001] = { 0,1,2, };\r\n\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 3; i &lt;= N; i++)\r\n    {\r\n        dp[i] = dp[i - 1] + dp[i - 2];\r\n        dp[i] = dp[i] % 15746;\r\n    }\r\n    cout &lt;&lt; dp[N] &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-03-21 16:25:46',103),(12151636,'SW',1952,'#include&lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint pay[4];\r\nint month[13];\r\nint dp[13];\r\nint main() {\r\n    int testcase;\r\n    cin &gt;&gt; testcase;\r\n    for (int t = 0; t &lt; testcase; t++) {\r\n        for (int i = 0; i &lt;= 12; i++)\r\n            dp[i] = 0;\r\n        for (int i = 0; i &lt; 4; i++)\r\n            cin &gt;&gt; pay[i];\r\n        for (int i = 1; i &lt;= 12; i++)\r\n            cin &gt;&gt; month[i];\r\n        dp[1] = min(month[1] * pay[0], pay[1]);\r\n        for (int i = 2; i &lt;= 12; i++) {\r\n            if (i - 3&gt;= 0) {\r\n                dp[i] = dp[i - 3] + pay[2];\r\n                dp[i] = min(dp[i], dp[i - 1] + pay[1]);\r\n                dp[i] = min(dp[i], dp[i - 1] + pay[0] * month[i]);\r\n            }\r\n            else {\r\n                dp[i] = min(dp[i - 1] + pay[1], dp[i - 1] + pay[0] * month[i]);\r\n            }\r\n        }\r\n        dp[12] = min(dp[12], pay[3]);\r\n        cout &lt;&lt;&quot;#&quot;&lt;&lt;t+1&lt;&lt;&quot; &quot;&lt;&lt; dp[12] &lt;&lt; endl;\r\n    }\r\n}','2020-03-21 16:47:12',104),(12151636,'BJ',15686,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nstruct position {\r\n    int x;\r\n    int y;\r\n    int value;\r\n};\r\n\r\nint N, M;\r\nint map[51][51];\r\nvector&lt;position&gt; v;\r\nvector&lt;position&gt; v1;\r\nvector&lt;position&gt; cal;\r\nint answer;\r\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\r\nvoid cal_distance() {\r\n    int sum = 0;\r\n    for (int i = 0; i &lt; v1.size(); i++) {\r\n        int value = 999999999;\r\n        for (int j = 0; j &lt; cal.size(); j++) {\r\n            int happy = abs(v1[i].x - cal[j].x) + abs(v1[i].y - cal[j].y);\r\n            if (happy &lt; value)\r\n                value = happy;\r\n        }\r\n        sum = sum + value;\r\n    }\r\n    answer = sum;\r\n}\r\nvoid start(int index, int cnt) {\r\n    if (cnt== M) {\r\n        cal_distance();\r\n        pq.push(answer);\r\n        return;\r\n    }\r\n    else {\r\n        for (int k = index; k &lt; v.size(); k++) {\r\n            if (v[k].value == 0) {\r\n                v[k].value = 1;\r\n                position p;\r\n                p.x = v[k].x;\r\n                p.y = v[k].y;\r\n                p.value = v[k].value;\r\n                cal.push_back(p);\r\n                start(k+1, cnt + 1);\r\n                v[k].value = 0;\r\n                cal.pop_back();\r\n            }\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    \r\n    for (int i = 1; i &lt;= N; i++)\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == 2) {\r\n                position p;\r\n                p.x = i; p.y = j; p.value = 0;\r\n                v.push_back(p);\r\n            }\r\n            else if(map[i][j] == 1){\r\n                position p;\r\n                p.x = i; p.y = j; p.value = 0;\r\n                v1.push_back(p);\r\n            }\r\n        }\r\n    \r\n    start(0, 0);\r\n    cout &lt;&lt; pq.top() &lt;&lt; endl;\r\n}','2020-03-21 16:48:07',105),(12151636,'SW',4012,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\r\nvector&lt;int&gt; v;\r\nvector&lt;int&gt; v1;\r\nint arr[17][17];\r\nint visit[17];\r\nint N;\r\nint final_value;\r\nint middle_value;\r\nvoid cal_max() {\r\n    final_value = 0;\r\n    middle_value = 0;\r\n    for (int i = 0; i &lt; v.size(); i++) {\r\n        for (int j = 0; j &lt; v.size(); j++) {\r\n            if (i != j)\r\n                final_value = final_value + arr[v[i]][v[j]];\r\n        }\r\n    }\r\n        for (int i = 0; i &lt; v1.size(); i++) {\r\n            for (int j = 0; j &lt; v1.size(); j++) {\r\n                if (i != j)\r\n                    middle_value = middle_value + arr[v1[i]][v1[j]];\r\n            }\r\n        }\r\n        int value = abs(final_value - middle_value);\r\n        pq.push(value);\r\n}\r\nvoid start(int cnt, int value) {\r\n    if (cnt == N / 2) {\r\n        for (int i = 0; i &lt; N; i++) {\r\n            if (visit[i] == 1)\r\n                v.push_back(i);\r\n            else\r\n                v1.push_back(i);\r\n        }\r\n        cal_max();\r\n        v.clear();\r\n        v1.clear();\r\n        return;\r\n    }\r\n    for (int i = value; i &lt; N; i++) {\r\n        if (visit[i] == 0) {\r\n            visit[i] = 1;\r\n            start(cnt + 1, i);\r\n            visit[i] = 0;\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    int testcase;\r\n    cin &gt;&gt; testcase;\r\n    for (int t = 0; t &lt; testcase; t++) {\r\n        cin &gt;&gt; N;\r\n        while (!pq.empty())\r\n            pq.pop();\r\n        final_value = 0;\r\n        middle_value = 0;\r\n        for (int i = 0; i &lt; N; i++)\r\n            for (int j = 0; j &lt; N; j++)\r\n                arr[i][j] = 0;\r\n        for (int i = 0; i &lt; N; i++)\r\n            for (int j = 0; j &lt; N; j++)\r\n                cin &gt;&gt; arr[i][j];\r\n        int cnt = 0;\r\n        start(0,0);\r\n        cout &lt;&lt;&quot;#&quot;&lt;&lt;t+1&lt;&lt;&quot; &quot;&lt;&lt; pq.top() &lt;&lt; endl;\r\n    }\r\n}','2020-03-21 22:52:42',106),(12151636,'SW',2112,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint MAX, D, W, K;\r\nint map[14][21];\r\nint temp[14][21];\r\nint visit[14];\r\nint visit_cnt;\r\nbool check_flag;\r\nint check() {\r\n    for (int j = 0; j &lt; W; j++) {\r\n        int a_cnt = 0;\r\n        int b_cnt = 0;\r\n        int flag = false;\r\n        for (int i = 0; i &lt; D; i++) {\r\n            if (temp[i][j] == 0) {\r\n                b_cnt = 0;\r\n                a_cnt = a_cnt + 1;\r\n            }\r\n            else {\r\n                a_cnt = 0;\r\n                b_cnt = b_cnt + 1;\r\n            }\r\n            if (a_cnt == K || b_cnt == K) {\r\n                flag = true;\r\n                break;\r\n            }\r\n        }\r\n        if (flag == false)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nvoid insert_A(int row) {\r\n    for (int i = 0; i &lt; W; i++)\r\n        temp[row][i] = 0;\r\n}\r\nvoid insert_B(int row) {\r\n    for (int i = 0; i &lt; W; i++)\r\n        temp[row][i] = 1;\r\n}\r\nvoid solve(int index, int cnt) {\r\n    if (visit_cnt == cnt) {\r\n        if (check() == true) {\r\n            MAX = cnt;\r\n            check_flag = true;\r\n            return;\r\n        }\r\n    }\r\n    else if (check_flag == false) {\r\n        for (int i = index; i &lt; D; i++) {\r\n            if (visit[i] == 0) {\r\n                visit[i] = 1;\r\n                visit_cnt = visit_cnt + 1;\r\n                insert_A(i);\r\n                solve(i, cnt);\r\n                for (int j = 0; j &lt; W; j++) {\r\n                    temp[i][j] = map[i][j];\r\n                }\r\n                insert_B(i);\r\n                solve(i, cnt);\r\n                for (int j = 0; j &lt; W; j++) {\r\n                    temp[i][j] = map[i][j];\r\n                }\r\n                visit[i] = 0;\r\n                visit_cnt = visit_cnt - 1;\r\n            }\r\n        }\r\n    }\r\n    else if (check_flag == true)\r\n        return;\r\n}\r\n\r\nvoid start() {\r\n    if (check() == true) {\r\n        MAX = 0;\r\n        return;\r\n    }\r\n    else {\r\n        visit_cnt = 0;\r\n        for (int i = 1; i &lt;= D; i++)\r\n            solve(0, i);\r\n    }\r\n}\r\n\r\nint main() {\r\n    int testcase;\r\n    cin &gt;&gt; testcase;\r\n    for (int t = 0; t &lt; testcase; t++) {\r\n        MAX = 999999999;\r\n        check_flag = false;\r\n        cin &gt;&gt; D &gt;&gt; W &gt;&gt; K;\r\n        for (int i = 0; i &lt; D; i++)\r\n            visit[i] = 0;\r\n        for (int i = 0; i &lt; D; i++) {\r\n            for (int j = 0; j &lt; W; j++) {\r\n                cin &gt;&gt; map[i][j];\r\n                temp[i][j] = map[i][j];\r\n            }\r\n        }\r\n        start();\r\n        cout &lt;&lt;&quot;#&quot;&lt;&lt;t+1&lt;&lt;&quot; &quot;&lt;&lt; MAX &lt;&lt; endl;\r\n    }\r\n}','2020-03-21 16:50:07',107),(12181853,'BJ',1904,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define MOD 15746\r\n\r\nint main() {\r\n\r\n    int N, i;\r\n\r\n    cin &gt;&gt; N;\r\n    long long dp[1000001];\r\n    dp[0] = 0;\r\n    dp[1] = 1;\r\n    dp[2] = 2;\r\n\r\n    for (i = 3; i &lt;= N; i++) \r\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\r\n    cout &lt;&lt; dp[N];\r\n}','2020-03-21 16:50:17',108),(12181853,'BJ',11053,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\n#define MAX 1001\r\n\r\nint N; // 수열 A의 크기 \r\nint VAL[MAX] = { 0 }; // 각각의 수열 원소 하나하나가 가지는 값\r\nint A[MAX] = { 0 }; // 출력하고자 하는 가장 긴 증가하는 부분 수열\r\nint Seq;\r\n\r\npriority_queue&lt;pair&lt;int, int&gt;&gt; pq;\r\n\r\nvoid LCS()\r\n{\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        int num = pq.top().first;\r\n        int idx = pq.top().second;\r\n\r\n        for (int j = idx; j &lt; N; j++)\r\n        {\r\n            if (num &lt; VAL[j])\r\n                A[idx] = max(A[idx], A[j]);\r\n        }\r\n        A[idx] += 1;\r\n        pq.pop();\r\n        pq.push(make_pair(-1, A[idx]));\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; Seq;\r\n        pq.push(make_pair(Seq, i));\r\n        VAL[i] = Seq;\r\n    }\r\n    LCS();\r\n    cout &lt;&lt; pq.top().second &lt;&lt; endl;\r\n}','2020-03-21 16:52:22',109),(12181751,'BJ',1904,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N;\r\n\r\nint main()\r\n{\r\n    long long answer = 1;\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 1; i &lt;= N / 2; i++)\r\n    {\r\n        answer += N - (2 * i)+1;\r\n        if (i != 1)\r\n        {\r\n            for (int j = 0; j &lt; N - (2 * i); j++)\r\n                answer += j+1;\r\n        }\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2020-03-21 16:55:00',110),(12181751,'BJ',1021,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N, M;\r\nint N_N[51] = { 0 };\r\nint rent[51] = { 0 };\r\nint sum = 0;\r\nint cnt = 0;\r\nvoid swap_left(int i)\r\n{\r\n    rent[N-1] = N_N[i];\r\n    for (int j = N-1; j &gt; i ; j--)\r\n    {\r\n        rent[j - 1] = N_N[j];\r\n        N_N[j] = rent[j];\r\n    }\r\n    N_N[i] = rent[i];\r\n}\r\nvoid swap_right(int i)\r\n{\r\n    rent[i] = N_N[N-1];\r\n    for (int j = i; j &lt; N-1; j++)\r\n    {\r\n        rent[j + 1] = N_N[j];\r\n        N_N[j] = rent[j];\r\n    }\r\n    N_N[N-1] = rent[N];\r\n}\r\nint cycle_queue(int num)\r\n{\r\n    int cnt1 = 0;\r\n    int cnt2 = 0;\r\n    int zero1 = 0;\r\n    int zero2 = 0;\r\n    \r\n    int j = cnt;\r\n    int k = cnt;\r\n    while (N_N[j] != num)\r\n    {\r\n        if (N_N[j] == 0)\r\n            zero1++;\r\n        cnt1++;\r\n        if (j == 0)\r\n            j = N-1;\r\n        else\r\n            j--; \r\n    }\r\n    while (N_N[k] != num)\r\n    {\r\n        if (N_N[j] == 0)\r\n            zero2++;\r\n        cnt2++;\r\n        if (k == N)\r\n            k = 1;\r\n        else\r\n            k++;\r\n    }\r\n\r\n    if (cnt1 &lt; cnt2)\r\n    {\r\n        for(int c=0;c&lt;cnt1;c++)\r\n            swap_right(0);\r\n        N_N[cnt] = 0;\r\n        return cnt1-zero1;\r\n    }\r\n    else\r\n    {\r\n        for (int c = 0; c &lt; cnt2; c++)\r\n            swap_left(0);\r\n        N_N[cnt] = 0;\r\n        return cnt2-zero2;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d %d&quot;, &N, &M);\r\n    for (int i = 0; i &lt; N; i++)\r\n        N_N[i] = i+1;\r\n    for (int i = 0; i &lt; M; i++)\r\n    {\r\n        int num;\r\n        scanf(&quot;%d&quot;, &num);\r\n        sum+=cycle_queue(num);\r\n        cnt++;\r\n    }\r\n    cout &lt;&lt; sum &lt;&lt; endl;\r\n}\r\n//하...','2020-03-21 17:00:16',111),(12161746,'BJ',1021,'#include&lt;iostream&gt;\r\n#include&lt;deque&gt;\r\n#include&lt;vector&gt;\r\nusing namespace std;\r\nconst int MAX = 51;\r\nint N, M;\r\nint count = 0;\r\n/*\r\nclass Deque {\r\nprivate:\r\n    int data[MAX];\r\n    int idx_front;\r\n    int idx_back;\r\npublic:\r\n    Deque();\r\n    void push_front(int x);\r\n    void push_back(int x);\r\n    void pop_front();\r\n    void pop_back();\r\n    void size();\r\n    int front();\r\n    int back();\r\n};\r\n\r\nvoid Deque::push_front(int x)\r\n{\r\n    data[idx_front] = x;\r\n    idx_front = (idx_front - 1 + MAX) % MAX;\r\n}\r\n\r\nvoid Deque::push_back(int x)\r\n{\r\n    idx_back = (idx_back + 1) % MAX;\r\n    data[idx_back] = x;\r\n}\r\n\r\nvoid Deque::pop_front()\r\n{\r\n    idx_front = (idx_front + 1) % MAX;\r\n}\r\n\r\nvoid Deque::pop_back()\r\n{\r\n    idx_back = (idx_back - 1 + MAX) % MAX;\r\n}\r\n\r\nvoid Deque::size()\r\n{\r\n\r\n}\r\n\r\nint Deque::front()\r\n{\r\n    return data[(idx_front + 1) % MAX];\r\n}\r\n\r\nint Deque::back()\r\n{\r\n    return data[idx_back];\r\n}\r\n*/\r\n\r\nvoid main()\r\n{\r\n    deque &lt;int&gt; Rotate;\r\n    cin &gt;&gt; N &gt;&gt; M;                //첫번째줄 입력\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        Rotate.push_front(i);\r\n    }\r\n    for (int i = 0; i &lt; M; i++)    //두번째줄 입력\r\n    {\r\n        int num;\r\n        cin &gt;&gt; num;\r\n        int idx;\r\n        for (int i = 0; i &lt; Rotate.size(); i++)\r\n        {\r\n            if (Rotate[i] == num)\r\n            {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n        //왼쪽, 오른쪽 비교해보기\r\n        if (idx &lt; Rotate.size() - idx)\r\n        {\r\n            //왼쪽으로 이동\r\n\r\n        }\r\n        else\r\n        {\r\n            //오른쪽으로 이동\r\n        }\r\n    }\r\n    \r\n}','2020-03-21 17:10:18',112),(12151551,'SW',1952,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint cost[5] = { 0 };\r\nint cal[12] = { 0 };\r\nint cl[12] = { 0 };\r\nint result = 10000000;\r\n\r\nvoid calculator() {\r\n    int sum = 0;\r\n    for (int i = 0; i &lt; 12; i++) {\r\n        if (cl[i] != 0) {\r\n            if (cl[i] == 1)\r\n                sum = sum + (cost[cl[i]] * cal[i]);\r\n            else {\r\n                sum = sum + cost[cl[i]];\r\n                if (cl[i] == 4) break;\r\n                else if (cl[i] == 3) i = i + 1;\r\n            }\r\n        }\r\n    }\r\n    result = min(result, sum);\r\n}\r\n\r\nvoid find(int num) {\r\n    if (num &gt;= 12) {\r\n        calculator();\r\n        return;\r\n    }\r\n    for (int i = num; i &lt; 12; i++) {\r\n        if (cal[i] != 0) {\r\n            for (int j = 1; j &lt;= 4; j++) {\r\n                if (j == 1) {\r\n                    cl[i] = j;\r\n                    find(i + 1);\r\n                    cl[i] = 0;\r\n                }\r\n                else if (j == 2) {\r\n                    cl[i] = 2;\r\n                    find(i + 1);\r\n                    cl[i] = 0;\r\n                }\r\n                else if (j == 3) {\r\n                    cl[i] = j;\r\n                    for (int e = i+1; e &lt; i+3; e++) cl[e] = 0;\r\n                    find(i + 3);\r\n                    cl[i] = 0;\r\n                }\r\n                else if (j == 4) {\r\n                    cl[i] = 4;\r\n                    find(i + 12);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    calculator();\r\n    return;\r\n\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int q = 0; q &lt; T; q++) {\r\n        result = 10000000;\r\n        for (int i = 0; i &lt; 12; i++) cal[i] = 0;\r\n        for (int i = 0; i &lt; 12; i++) cl[i] = 0;\r\n        for (int i = 1; i &lt;= 4; i++) cin &gt;&gt; cost[i];\r\n        for (int i = 0; i &lt; 12; i++) cin &gt;&gt; cal[i];\r\n        find(0);\r\n        cout &lt;&lt;&quot;#&quot;&lt;&lt;q+1&lt;&lt;&quot; &quot;&lt;&lt; result &lt;&lt; endl;\r\n    }\r\n}','2020-03-21 23:44:19',113),(12151551,'BJ',15686,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint map[52][52] = { 0 };\r\nvector&lt; pair&lt;int,int&gt; &gt; house;\r\nvector&lt; pair&lt;int, int&gt; &gt; ch;\r\nint ax[52];\r\nbool check[52] = { 0 };\r\nint N, M;\r\nint real = 1000000;\r\n\r\nint distance() {\r\n    int result = 0;\r\n    for (int i = 0; i &lt; house.size(); i++) {\r\n        int sum = 10000000;\r\n        for (int j = 0; j &lt; M; j++) {\r\n            sum = min(sum, (abs(house[i].first - ch[ax[j]].first) + abs(house[i].second - ch[ax[j]].second)));\r\n        }\r\n        result += sum;\r\n    }\r\n    return result;\r\n}\r\n\r\nvoid find(int num,int index) {\r\n    if (num &gt;= M) {\r\n        real = min(real,distance());\r\n        return;\r\n    }\r\n    for (int i = index; i &lt; ch.size(); i++) {\r\n        if (check[i] == false) {\r\n            check[i] = true;\r\n            ax[num] = i;\r\n            find(num + 1, i+1);\r\n            check[i] = false;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == 1) house.push_back({ i,j });\r\n            if (map[i][j] == 2) ch.push_back({ i,j });\r\n        }\r\n    }\r\n    find(0,0);\r\n    cout &lt;&lt; real &lt;&lt; endl;\r\n\r\n}','2020-03-22 01:23:01',114),(12151551,'BJ',1309,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint dp[100001] = { 0 };\r\n\r\nint main() {\r\n    dp[0] = 1;\r\n    dp[1] = 3;\r\n    int N; \r\n    cin &gt;&gt; N;\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        dp[i] = ((2 * dp[i - 1]) + dp[i - 2])%9901;\r\n    }\r\n    cout &lt;&lt; dp[N]&lt;&lt; endl;\r\n}','2020-03-22 03:12:29',115),(12151636,'BJ',1309,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint x[100001];\r\nint righ[100001];\r\nint lef[100001];\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    x[1] = 1; righ[1] = 1; lef[1] = 1;\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        x[i] = (x[i - 1] + righ[i - 1] + lef[i - 1]) % 9901;\r\n        righ[i] = (x[i - 1] + lef[i - 1]) % 9901;\r\n        lef[i] = (x[i - 1] + righ[i - 1])% 9901;\r\n    }\r\n    cout &lt;&lt; (x[N] + righ[N] + lef[N]) % 9901 &lt;&lt; endl;\r\n}\r\n','2020-03-22 15:05:08',116),(12151526,'BJ',14890,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n\r\nusing namespace std;\r\nint N = 0;\r\nint X = 0;\r\nint map[100][100] = { 0, };\r\nint cnt = 0;\r\nvector&lt;int&gt; answer;\r\n\r\nvoid row_test() {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        bool tf = true;\r\n        for (int j = 0; j &lt; N - 1; j++) {\r\n            if (map[i][j] == map[i][j + 1]) {\r\n            }\r\n            else if (map[i][j] == map[i][j + 1] - 1) {\r\n                int va2 = map[i][j];\r\n                for (int k = 0; k &lt; X; k++) {\r\n                    if (j - k &gt;= 0) {\r\n                        if (map[i][j - k] == va2) {\r\n                        }\r\n                        else {\r\n                            tf = false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tf = false;\r\n                    }\r\n                }\r\n            }\r\n            else if (map[i][j] == map[i][j + 1] + 1) {\r\n                int va2 = map[i][j + 1];\r\n                for (int k = 0; k &lt; X; k++) {\r\n                    if (j + k + 1 &lt; N) {\r\n                        if (map[i][j + k + 1] == va2) {\r\n                        }\r\n                        else {\r\n                            tf = false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tf = false;\r\n                    }\r\n                }\r\n                for (int k = 1; k &lt;= X; k++) {\r\n                    if (j + X + k &lt; N) {\r\n                        if (map[i][j + X + k] &gt; va2) {\r\n                            tf = false;\r\n                        }\r\n                    }\r\n                }\r\n                j = j + X - 1;\r\n            }\r\n            else {\r\n                tf = false;\r\n            }\r\n        }\r\n        if (tf == true) {\r\n            cnt++;\r\n        }\r\n    }\r\n}\r\nvoid col_test() {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        bool tf = true;\r\n        for (int j = 0; j &lt; N - 1; j++) {\r\n            if (map[j][i] == map[j + 1][i]) {\r\n            }\r\n            else if (map[j][i] == map[j + 1][i] - 1) {\r\n                int va2 = map[j][i];\r\n                for (int k = 0; k &lt; X; k++) {\r\n                    if (j - k &gt;= 0) {\r\n                        if (map[j - k][i] == va2) {\r\n                        }\r\n                        else {\r\n                            tf = false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tf = false;\r\n                    }\r\n                }\r\n            }\r\n            else if (map[j][i] == map[j + 1][i] + 1) {\r\n                int va2 = map[j + 1][i];\r\n                for (int k = 0; k &lt; X; k++) {\r\n                    if (j + k + 1 &lt; N) {\r\n                        if (map[j + k + 1][i] == va2) {\r\n                        }\r\n                        else {\r\n                            tf = false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tf = false;\r\n                    }\r\n                }\r\n                for (int k = 1; k &lt;= X; k++) {\r\n                    if (j + X + k &lt; N) {\r\n                        if (map[j + X + k][i] &gt; va2) {\r\n                            tf = false;\r\n                        }\r\n                    }\r\n                }\r\n                j = j + X - 1;\r\n            }\r\n            else {\r\n                tf = false;\r\n            }\r\n        }\r\n        if (tf == true) {\r\n            cnt++;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; X;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n        }\r\n    }\r\n    row_test();\r\n    col_test();\r\n    cout &lt;&lt; cnt;\r\n}','2020-03-22 15:13:58',117),(12151636,'BJ',14890,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint map[101][101] = { 0 };\r\nint visit[101][101] = { 0 };\r\nint N,X;\r\nint cnt;\r\n\r\nvoid row_check() {\r\n    int i = 0;\r\n    while (i!=N) {\r\n        int x = 0;\r\n        int flag = true;\r\n        for (int i = 0; i &lt; N; i++)\r\n            for (int j = 0; j &lt; N; j++)\r\n                visit[i][j] = 0;\r\n        for (int j = 1; j &lt; N; j++) {\r\n            if (map[i][j] - map[i][j - 1] == 0)\r\n                continue;\r\n            else if (map[i][j] - map[i][j - 1] == 1) {\r\n                int value = map[i][j] - 1;\r\n                for (int k = 1; k &lt;= X; k++) {\r\n                    if (j - k &lt; 0) {\r\n                        flag = false;\r\n                        break;\r\n                    }\r\n                    if (map[i][j - k] != value)\r\n                        flag = false;\r\n\r\n                    if (visit[i][j - k] != 0)\r\n                        flag = false;\r\n                    else\r\n                        visit[i][j - k] = 1;\r\n                }\r\n                if(flag==false)\r\n                    for (int k = 1; k &lt;= X; k++) {\r\n                        if (j - k &lt; 0) break;\r\n                        if (visit[i][j - k] == 0)break;\r\n                        visit[i][j - k] = 0;\r\n                    }\r\n            }\r\n            else if (map[i][j] - map[i][j - 1] == -1) {\r\n                int value = map[i][j];\r\n                for (int k = 0; k &lt; X; k++) {\r\n                    if (j + k &gt;= N) {\r\n                        flag = false;\r\n                        break;\r\n                    }\r\n                    if (map[i][j + k] != value)\r\n                        flag = false;\r\n\r\n                    if (visit[i][j + k] != 0)\r\n                        flag = false;\r\n                    else\r\n                        visit[i][j + k] = 1;\r\n                }\r\n                if (flag == false)\r\n                    for (int k = 0; k &lt; X; k++) {\r\n                        if (j + k &gt;= N) break;\r\n                        if (visit[i][j+k] == 0)break;\r\n                        visit[i][j + k] = 0;\r\n                    }\r\n            }\r\n            else {\r\n                flag = false;\r\n                break;\r\n            }\r\n            if (flag == false)\r\n                break;\r\n        }\r\n        if (flag == true)\r\n            cnt = cnt + 1;\r\n        i++;\r\n    }\r\n}\r\nvoid col_check() {\r\n    int j = 0;\r\n    while (j != N) {\r\n        int x = 0;\r\n        int flag = true;\r\n        for (int i = 0; i &lt; N; i++)\r\n            for (int j = 0; j &lt; N; j++)\r\n                visit[i][j] = 0;\r\n        for (int i = 1; i &lt; N; i++) {\r\n            if (map[i][j] - map[i-1][j] == 0)\r\n                continue;\r\n            else if (map[i][j] - map[i-1][j] == 1) {\r\n                int value = map[i][j] - 1;\r\n                for (int k = 1; k &lt;= X; k++) {\r\n                    if (i - k &lt; 0) {\r\n                        flag = false;\r\n                        break;\r\n                    }\r\n                    if (map[i-k][j] != value)\r\n                        flag = false;\r\n\r\n                    if (visit[i-k][j] != 0)\r\n                        flag = false;\r\n                    else\r\n                        visit[i-k][j] = 1;\r\n                }\r\n                if (flag == false)\r\n                    for (int k = 1; k &lt;= X; k++) {\r\n                        if (i - k &lt; 0) break;\r\n                        if (visit[i - k][j] == 0)break;\r\n                        visit[i - k][j] = 0;\r\n                    }\r\n            }\r\n            else if (map[i][j] - map[i-1][j] == -1) {\r\n                int value = map[i][j];\r\n                for (int k = 0; k &lt; X; k++) {\r\n                    if (i + k &gt;= N) {\r\n                        flag = false;\r\n                        break;\r\n                    }\r\n                    if (map[i+k][j] != value)\r\n                        flag = false;\r\n                    if (visit[i + k][j]!= 0)\r\n                        flag = false;\r\n                    else\r\n                        visit[i + k][j] = 1;\r\n                }\r\n                if (flag == false)\r\n                    for (int k = 0; k &lt; X; k++) {\r\n                        if (i + k &gt;= N) break;\r\n                        if (visit[i + k][j] == 0)break;\r\n                        visit[i + k][j] = 0;\r\n                    }\r\n            }\r\n            else {\r\n                flag = false;\r\n                break;\r\n            }\r\n            if (flag == false)\r\n                break;\r\n        }\r\n        if (flag == true)\r\n            cnt = cnt + 1;\r\n        j++;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int value;\r\n    cin &gt;&gt; N &gt;&gt; X;\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; value;\r\n            map[i][j] = value;\r\n        }\r\n    row_check();\r\n    col_check();\r\n    cout&lt;&lt; cnt &lt;&lt;endl;\r\n}','2020-03-22 15:14:03',118),(12151636,'BJ',1904,'#include &lt;vector&gt;\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N; int arr[1000001];\r\n\r\nvoid start() {\r\n    arr[1] = 1;\r\n    arr[2] = 2;\r\n    for (int i = 3; i &lt;= N; i++) {\r\n        arr[i] = (arr[i - 1] + arr[i - 2]) % 15746;\r\n        //arr[i] = (arr[i - 1] + arr[i - 2]);\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    start();\r\n    cout &lt;&lt; arr[N]&lt;&lt; endl;\r\n}','2020-03-22 15:51:14',119),(12181853,'BJ',10844,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define MOD 1000000000\r\n\r\nint N;\r\nlong long cache[101][10] = { 0 };\r\n// 앞은 자릿수, 즉 숫자의 길이를 의미, 뒤는 시작하는 숫자를 의미 \r\n// 즉 cache[a][b]는 길이가 a인 수에서 b로 시작하는 계단 수의 개수를 의미!\r\nlong long cnt = 0;\r\n\r\nvoid STAIR_NUM()\r\n{\r\n    for (int i = 1; i &lt; 10; i++)\r\n    {\r\n        cache[1][i] = 1; // 한 자릿수에서 계단수는 자기 자신 하나밖에 없으므로!\r\n    }\r\n\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        for (int j = 0; j &lt; 10; j++)\r\n        {\r\n            if (j == 0)\r\n                cache[i][j] = cache[i - 1][j + 1] % MOD;\r\n\r\n            else if (j == 9)\r\n                cache[i][j] = cache[i - 1][j - 1] % MOD;\r\n            else\r\n                cache[i][j] = (cache[i - 1][j - 1] + cache[i - 1][j + 1]) % MOD;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i &lt; 10; i++)\r\n    {\r\n        cnt += cache[N][i]; // N개 자릿수의 숫자에서 0부터 9까지 시작하는 숫자에 대해 모두 cnt에 넣어준다\r\n    }\r\n\r\n    cout &lt;&lt; cnt % MOD &lt;&lt; endl;\r\n}\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n\r\n    cin &gt;&gt; N;\r\n\r\n    STAIR_NUM();\r\n}','2020-03-22 16:09:27',120),(12151601,'SW',1952,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int t = 1; t &lt;= T; t++) {\r\n        int cost[4] = { 0 };\r\n        int swim[12] = { 0 };\r\n        int d[12] = { 0 };\r\n\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            cin &gt;&gt; cost[i];\r\n        }\r\n        for (int i = 0; i &lt; 12; i++) {\r\n            cin &gt;&gt; swim[i];\r\n            d[i] = min(cost[1], swim[i] * cost[0]);\r\n        }\r\n\r\n        for (int i = 1; i &lt; 12; i++) {\r\n            if (i &lt; 3) {\r\n                d[i] = min(d[i] + d[i - 1], cost[2]);\r\n                continue;\r\n            }\r\n            d[i] = min(d[i - 3] + cost[2], d[i - 1] + d[i]);\r\n        }\r\n        cout &lt;&lt; &#39;#&#39; &lt;&lt; t &lt;&lt; &#39; &#39; &lt;&lt; min(d[11], cost[3]) &lt;&lt; endl;\r\n    }\r\n}','2020-03-22 16:12:50',121),(12181751,'BJ',10844,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nlong long num[101][10] = { 0 };\r\n\r\nint main()\r\n{\r\n    int N;\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 1; i &lt;= 9; i++)\r\n        num[1][i] = 1 % 1000000000;\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        for (int j = 0; j &lt; 10; j++)\r\n        {\r\n            if (j == 0)\r\n                num[i][0] += num[i - 1][1] % 1000000000;//0일때는 1로부터만 받는게 가능하고\r\n            else if (j == 9)\r\n                num[i][9] += num[i - 1][8] % 1000000000;//9일때는 8로부터 받는것만이 가능하고\r\n            else\r\n            {\r\n                num[i][j] += (num[i - 1][j-1]+num[i-1][j+1]) % 1000000000;//나머지는 앞 뒤 숫자로 부터 받는게 가능하다\r\n            }\r\n        }\r\n    }\r\n    long long sum = 0;\r\n    for (int i = 0; i &lt; 10; i++)\r\n        sum += num[N][i] % 1000000000;\r\n    printf(&quot;%d&quot;,sum% 1000000000);//출력을 1000000000로 나눈 수로 하라고 했는데 위에까지만 나머지 연산해서 틀려 먹었었음..\r\n    printf(&quot;inha_univ&quot;);\r\n    return 0;\r\n}','2020-03-22 17:50:59',122),(12151536,'SW',2112,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint D, W, K;\r\nint layer[14][21];\r\nint ans;\r\n\r\nvoid check_layer(int cnt) {\r\n    for (int i = 1; i &lt;= W; i++) {\r\n        int check_count = 1;\r\n        for (int j = 1; j &lt; D; j++) {\r\n            if (layer[j][i] == layer[j + 1][i]) {\r\n                check_count++;\r\n            }\r\n            else {\r\n                check_count = 1;\r\n            }\r\n            if (check_count == K) {\r\n                break;\r\n            }\r\n        }\r\n        if (check_count &lt; K)return;\r\n    }\r\n    if (ans &gt; cnt) {\r\n        ans = cnt;\r\n    }\r\n}\r\n\r\nvoid insert_drug(int D,int type) {\r\n    for (int i = 1; i &lt;= W; i++) {\r\n        layer[D][i] = type;\r\n    }\r\n}\r\n\r\nvoid copy_layer(int A[21], int B[21]) {\r\n    for (int i = 1; i &lt;= W; i++) {\r\n        A[i] = B[i];\r\n    }\r\n}\r\n\r\nvoid dfs(int d, int cnt) {\r\n    if (d &gt; D) {\r\n        check_layer(cnt);\r\n        return;\r\n    }\r\n    if (cnt &gt; ans) {\r\n        return;\r\n    }\r\n    //안뿌림\r\n    dfs(d + 1, cnt);\r\n\r\n    //A로 뿌림\r\n    int temp[21] = { 0 };\r\n    copy_layer(temp, layer[d]);\r\n    insert_drug(d, 1);\r\n    dfs(d + 1, cnt + 1);\r\n    copy_layer(layer[d], temp);\r\n\r\n    //B로 뿌림\r\n    copy_layer(temp, layer[d]);\r\n    insert_drug(d, 0);\r\n    dfs(d + 1, cnt + 1);\r\n    copy_layer(layer[d], temp);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nint main(){\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int test_case = 1; test_case &lt;= T; test_case++) {\r\n        ans = 100000;\r\n        cin &gt;&gt; D &gt;&gt; W &gt;&gt; K;\r\n        for (int i = 1; i &lt;= D; i++) {\r\n            for (int j = 1; j &lt;= W; j++) {\r\n                cin &gt;&gt; layer[i][j];\r\n            }\r\n        }\r\n\r\n        dfs(1, 0);\r\n        printf(&quot;#%d %dinha_univ&quot;, test_case, ans);\r\n    }\r\n}','2020-03-22 18:27:20',123),(12151601,'SW',4012,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;memory.h&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint S[17][17];\r\nbool visit[17];\r\nint N, ans;\r\n\r\nint synergy(int s[]) {\r\n    int syn = 0;\r\n\r\n    for (int i = 0; i &lt; N / 2; i++) {\r\n        for (int j = 0; j &lt; N / 2; j++) {\r\n            if (i == j) continue;\r\n            syn += S[s[i]][s[j]];\r\n        }\r\n    }\r\n    return syn;\r\n}\r\n\r\nvoid choice(int n, int a[], int b[]) {\r\n    if (n == N / 2) {\r\n        ans = min(abs(synergy(a) - synergy(b)), ans);\r\n    }\r\n    else {\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            int aa[16] = { 0 };\r\n            int bb[16] = { 0 };\r\n            for (int i = 0; i &lt; n; i++) {\r\n                aa[i] = a[i];\r\n            }\r\n            if (n == 0 || (!visit[i] && aa[n - 1] &lt; i)) {\r\n                aa[n] = i;\r\n                visit[i] = true;\r\n                if (n == N / 2 - 1) {\r\n                    int cnt = 0;\r\n                    for (int e = 1; e &lt;= N; e++) {\r\n                        if (!visit[e]) {\r\n                            bb[cnt] = e;\r\n                            cnt++;\r\n                        }\r\n                    }\r\n                }\r\n                choice(n + 1, aa, bb);\r\n                visit[i] = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int t = 1; t &lt;= T; t++) {\r\n        cin &gt;&gt; N;\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            for (int j = 1; j &lt;= N; j++) {\r\n                cin &gt;&gt; S[i][j];\r\n            }\r\n        }\r\n        ans = 99999999;\r\n        memset(visit, false, sizeof(visit));\r\n        int a[16], b[16];\r\n        choice(0, a, b);\r\n        cout &lt;&lt; &#39;#&#39; &lt;&lt; t &lt;&lt; &#39; &#39; &lt;&lt; ans &lt;&lt; endl;\r\n    }\r\n}','2020-03-23 01:35:47',124),(12151526,'BJ',11724,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;list&gt;\r\nusing namespace std;\r\nint N, M;\r\nint visit[1001];\r\nlist&lt;int&gt;li[1001];\r\nqueue&lt;int&gt;qu;\r\nint res;\r\nvoid go(int a) {\r\n    qu.push(a);\r\n    visit[a] = 1;\r\n    while (!qu.empty()) {\r\n        int va = qu.front();\r\n        qu.pop();\r\n        visit[va] = 1;\r\n        while(!li[va].empty()) {\r\n            visit[li[va].front()] = 1;\r\n            qu.push(li[va].front());\r\n            li[va].pop_front();\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; M; i++) {\r\n        int va, va2;\r\n        cin &gt;&gt; va &gt;&gt; va2;\r\n        li[va].push_back(va2);\r\n        li[va2].push_back(va);\r\n    }\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        if (visit[i] == 0) {\r\n            res++;\r\n            go(i);\r\n        }\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-03-22 19:00:07',125),(12151629,'BJ',15686,'import itertools\r\nN, M = map(int, input().split())\r\nmy_map = [list(map(int, input().split())) for _ in range(N)]\r\nhome = []\r\nchicken = []\r\nfor idx1, line in enumerate(my_map):\r\n    for idx2, i in enumerate(line):\r\n        if i == 1:\r\n            home.append([idx1, idx2])\r\n\r\n        elif i == 2:\r\n            chicken.append([idx1, idx2])\r\n\r\ndef min_answer(chick):\r\n    global home\r\n    min_cost = [9999 for _ in range(len(home))]\r\n    for idx_home, xy_home in enumerate(home):\r\n        for idx_chick, xy_chick in enumerate(chick):\r\n            temp = abs(xy_chick[0] - xy_home[0]) + abs(xy_chick[1] - xy_home[1])\r\n            if temp &lt; min_cost[idx_home]:\r\n                min_cost[idx_home] = temp\r\n    return sum(min_cost)\r\n\r\n# 줄일 치킨집이 없다면\r\nif len(chicken) == M:\r\n    # 최소값 계산.\r\n    print(min_answer(chicken))\r\nelse:\r\n    answer = 1000000\r\n    # combination은 맞고 permitation은 틀리다;;;;;; 공부해야겠다.\r\n    for chickens in list(itertools.combinations(chicken, M)):\r\n        temp = min_answer(chickens)\r\n        if answer &gt; temp:\r\n            answer = temp\r\n    print(answer)\r\n','2020-03-22 21:27:27',126),(12151629,'BJ',1309,'cage = [1, 1, 1]\r\nfor i in range(1, int(input())):\r\n    # !!!!\r\n    cage = [x % 9901 for x in [sum(cage), cage[0] + cage[2], cage[0] + cage[1]]]\r\n    # !!!!\r\nprint((sum(cage)%9901))\r\n\r\n# 연산 중에 나눠주지 않으면 값이 너무 커져서 속도 7배 차이남\r\n# 리스트 컴프리헨션에 대해 다시한번 배우게 됨\r\n# cage = [[1, 1, 1], [0, 0, 0]]\r\n# for i in range(1, int(input())):\r\n#     one = (i+1)%2\r\n#     two = i%2\r\n#     cage[two][0] = cage[one][0] + cage[one][1] + cage[one][2]\r\n#     cage[two][1] = cage[one][0] + cage[one][2]\r\n#     cage[two][2] = cage[one][0] + cage[one][1]\r\n# print((sum(max(cage)))%9901)','2020-03-23 16:17:20',127),(12151601,'BJ',15686,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nstruct location {\r\n    int x, y;\r\n};\r\n\r\nvector&lt;location&gt; chk;\r\nint N, M, ans=10000000;\r\nint map[50][50];\r\nbool visit[13];\r\n\r\nint distance(int x, int y, location chicken[13]) {\r\n    int dis = 10000000;\r\n    for (int c = 0; c &lt; M; c++)\r\n        dis = min(abs(chicken[c].x - x) + abs(chicken[c].y - y), dis);    \r\n    return dis;\r\n    \r\n}\r\n\r\nvoid choice(int n, int f, location c[13]) {\r\n    if (n == M) {\r\n        int sum = 0;\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; N; j++) {\r\n                if (map[i][j] == 1) {\r\n                    sum += distance(i, j, c);\r\n                }\r\n            }\r\n        }\r\n        ans = min(sum, ans);\r\n        return;\r\n    }\r\n    else {\r\n        location chicken[13] = { 0 };\r\n        for (int i = 0; i &lt; n; i++) {\r\n            chicken[i] = c[i];\r\n        }\r\n        for (int i = f; i &lt; chk.size(); i++) {\r\n            if (!visit[i]) {\r\n                chicken[n] = chk[i];\r\n                visit[i] = true;\r\n                choice(n + 1, i, chicken);\r\n                visit[i] = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == 2) {\r\n                chk.push_back({ i,j });\r\n            }\r\n        }\r\n    }\r\n    location chicken[13] = { 0 };\r\n    choice(0, 0, chicken);\r\n    cout &lt;&lt; ans;\r\n}','2020-03-23 14:29:43',128),(12151629,'SW',4012,'import itertools\r\n\r\nfor testcase in range(1, int(input())+1):\r\n    N = int(input())\r\n    S = [list(map(int, input().split())) for _ in range(N)]\r\n    answer = 50000\r\n    my_list = list(itertools.combinations(range(N), N//2))\r\n    for idx, xy in enumerate(my_list):\r\n        j = list(range(N))\r\n        for i in xy:\r\n            j.remove(i)\r\n        temp2 = list(itertools.combinations(j, 2))\r\n        temp1 = list(itertools.combinations(xy, 2))\r\n        one = 0\r\n        two = 0\r\n        for xy1 in temp1:\r\n            one += S[xy1[0]][xy1[1]] + S[xy1[1]][xy1[0]]\r\n        for xy2 in temp2:\r\n            two += S[xy2[0]][xy2[1]] + S[xy2[1]][xy2[0]]\r\n        if answer &gt; abs(one-two):\r\n            answer = abs(one-two)\r\n    print(&#39;#{} {}&#39;.format(testcase, answer))','2020-03-23 14:49:09',129),(12181853,'BJ',2565,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\n#define MAX 101\r\n\r\nint N;\r\nint A;\r\nint B;\r\nint AB[MAX] = { 0 };\r\nint RES = 0;\r\nint ANS = 0;\r\n\r\nvector&lt;pair&lt;int, int&gt;&gt; V;\r\n\r\nbool compare(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B)\r\n{\r\n    return A.first &lt; B.first;\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; A &gt;&gt; B;\r\n        V.push_back({ A,B });\r\n    }\r\n    sort(V.begin(), V.end(), compare);\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        AB[i] = 1;\r\n        RES = 1;\r\n\r\n        for (int j = 0; j &lt; i; j++)\r\n        {\r\n            if (V[j].second &lt; V[i].second)\r\n            {\r\n                RES = max(RES, AB[i] + AB[j]);\r\n            }\r\n        }\r\n        AB[i] = RES;\r\n        ANS = RES &gt; ANS ? RES : ANS;\r\n    }\r\n    cout &lt;&lt; N - ANS &lt;&lt; endl;\r\n}','2020-03-23 14:51:27',130),(12151551,'SW',2112,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint D, W, K;\r\nint fil[14][21] = { 0 };\r\nint cp[14][21] = { 0 };\r\nint ch[21] = { 0 };\r\nint result = 1000000;\r\nint A = 0;\r\nint B = 0;\r\nint fin = 0;\r\n\r\nbool cal(int index) {\r\n    int num = 0;\r\n    int same = 1;\r\n    for (int i = 0; i &lt; W; i++) {\r\n        same = 1;\r\n        int val = 0;\r\n        for (int j = 1; j &lt; D; j++) {\r\n            if (cp[j][i] == cp[j - 1][i]) same++;\r\n            else same = 1;\r\n            if (same &gt;= K && val == 0) {\r\n                num++;\r\n                val = 1;\r\n                continue;\r\n            }\r\n            \r\n        }\r\n        if (val != 1) break;\r\n    }\r\n    if (num &gt;= W) {\r\n        fin = 1;\r\n        return true;\r\n    }\r\n    else return false;\r\n}\r\n\r\n\r\nvoid change(int index) {\r\n    if (result &lt; index) return;\r\n    else {\r\n        for (int i = 0; i &lt; D; i++) {\r\n            if (ch[i] == 0) continue;\r\n            else {\r\n                if (ch[i] == 1) {\r\n                    for (int j = 0; j &lt; W; j++) {\r\n                        cp[i][j] = 0;\r\n                    }\r\n                }\r\n                else if (ch[i] == 2) {\r\n                    for (int j = 0; j &lt; W; j++) {\r\n                        cp[i][j] = 1;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        if (cal(index) == true) {\r\n            result = min(result, index);\r\n        }\r\n        for (int i = 0; i &lt; D; i++) {\r\n            for (int j = 0; j &lt; W; j++)\r\n                cp[i][j] = fil[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid check(int index, int nu, int visit) {\r\n    if (index &gt; D) return;\r\n    if (nu &gt; K) return;\r\n    if (nu &gt; result) return;\r\n    if (visit == nu) {\r\n        if (fin == 1) return;\r\n        change(nu);\r\n    }\r\n\r\n    for (int i = index; i &lt; D; i++) {\r\n        ch[i] = 1;\r\n        check(i + 1, nu+1, visit);\r\n        ch[i] = 2;\r\n        check(i +1, nu+1, visit);\r\n        ch[i] = 0;\r\n    }\r\n    \r\n\r\n}\r\n\r\nvoid start() {\r\n    if (fin == 1)\r\n        return;\r\n    else {\r\n        for (int i = 0; i &lt; D; i++) {\r\n            check(0, 0, i);\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int q = 0; q &lt; T; q++) {\r\n        for (int i = 0; i &lt;= 13; i++) {\r\n            for (int j = 0; j &lt;= 20; j++) {\r\n                cp[i][j] = 0;\r\n                fil[i][j] = 0;\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; 21; i++) ch[i] = 0;\r\n        result = 1000000;\r\n        fin = 0;\r\n\r\n        cin &gt;&gt; D &gt;&gt; W &gt;&gt; K;\r\n\r\n        for (int i = 0; i &lt; D; i++) {\r\n            for (int j = 0; j &lt; W; j++) {\r\n                cin &gt;&gt; fil[i][j];\r\n                cp[i][j] = fil[i][j];\r\n            }\r\n        }\r\n        if(K == 1) cout &lt;&lt; &quot;#&quot; &lt;&lt; q + 1 &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; endl;\r\n        else {\r\n            start();\r\n            cout &lt;&lt; &quot;#&quot; &lt;&lt; q + 1 &lt;&lt; &quot; &quot; &lt;&lt; result &lt;&lt; endl;\r\n        }\r\n    }\r\n\r\n}','2020-03-23 18:02:45',131),(12151536,'SW',1952,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint cost[5];\r\nint month[13];\r\nint dp[13];\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int test_case = 1; test_case &lt;= T; test_case++) {\r\n        for (int i = 1; i &lt;= 4; i++) {\r\n            cin &gt;&gt; cost[i];\r\n        }\r\n        for (int i = 1; i &lt;= 12; i++) {\r\n            cin &gt;&gt; month[i];\r\n        }\r\n        dp[0] = 0;\r\n        for (int i = 1; i &lt;= 12; i++) {\r\n            if (i == 1 || i == 2) {\r\n                dp[i] = min(dp[i - 1] + cost[1] * month[i], dp[i - 1] + cost[2]);\r\n            }\r\n            else\r\n                dp[i] = min(min(dp[i - 1] + cost[1] * month[i], dp[i - 1] + cost[2]), dp[i - 3] + cost[3]);\r\n        }\r\n        int ans = min(dp[12], cost[4]);\r\n        printf(&quot;#%d %dinha_univ&quot;, test_case, ans);\r\n    }\r\n}','2020-03-23 18:10:26',132),(12181751,'BJ',14890,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N, L;\r\nint N_N[101][101] = { 0 };\r\nint answer = 0;\r\nvoid slop_colourm()\r\n{\r\n    for (int j = 0; j &lt; N; j++)\r\n    {\r\n        int num = N_N[0][j];\r\n        int cnt = 1;\r\n        int i;\r\n        for (i = 1; i &lt; N; i++)\r\n        {\r\n            if (num == N_N[i][j]) //같으면 cnt를 증가한다.\r\n                cnt++;\r\n            else if (abs(num - N_N[i][j]) &gt; 1) //증가 or 감소가 2 이상되는 경우\r\n                break;\r\n            else if (num + 1 == N_N[i][j]) //오르막\r\n            {\r\n                if (cnt &lt; L) //이전까지 평지가 원하는 만큼 없으면 바이\r\n                    break;\r\n                else if (L &lt;= cnt && cnt &lt; 2 * L) //이전까지 잘 와서 하나의 오르막을 올랐는데 다음 언덕을 만났을 때 오르막을 오를 수없는 경우\r\n                {\r\n                    if (i - cnt - 1 &gt;= 0 && N_N[i - cnt - 1][j] == num + 1)\r\n                        break;\r\n                }\r\n                if (i != N - 1)//N==3 L==2일때 223일때 맞다고 해야해서\r\n                    cnt = 1;//올라간 상태에서 다시 올라가는 경우가 있을 수있으니까\r\n            }\r\n            else if (num - 1 == N_N[i][j])\r\n            {\r\n                if ((i - cnt - 1 &gt;= 0 && N_N[i - cnt - 1][j] == num + 1) && cnt &lt; L)//내려왔다가 또 내려가는 경우 22 11이런경우에서 문제가 없는지 확인\r\n                    break;\r\n\r\n                cnt = 1;//내려갔으면 평지의 수가 맞는지 확인\r\n            }\r\n            num = N_N[i][j];\r\n        }\r\n        if (i == N && cnt &gt;= L)//break를 안당했거나 마지막에서 cnt가 원하는 만큼 잘 온 경우\r\n        {\r\n            //cout &lt;&lt; j &lt;&lt; endl;\r\n            answer++;\r\n        }\r\n        else if (i == N && cnt &lt; L)//2222233이렇게 cnt가 억울하게 부족한 경우 \r\n        {\r\n            int va2 = 1;\r\n            int va = N_N[N - 1][j];\r\n            for (int k = 0; k &lt; L; k++)//끝에서 부터 L전까지의 숫자들 중에 +1이되는 경우가 없으면 문제 없음 \r\n            {\r\n                if (N_N[N - 1 - k][j] == va + 1) {\r\n                    va2 = 0;\r\n                }\r\n            }\r\n            if (va2 == 1) {\r\n                answer++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid slop_row()\r\n{\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        int num = N_N[i][0];\r\n        int cnt = 1;\r\n        int j;\r\n        for (j = 1; j &lt; N; j++)\r\n        {\r\n            if (num == N_N[i][j])\r\n                cnt++;\r\n            else if (abs(num - N_N[i][j]) &gt; 1)\r\n                break;\r\n            else if (num + 1 == N_N[i][j])\r\n            {\r\n                if (cnt &lt; L)\r\n                    break;\r\n                else if (L &lt;= cnt && cnt &lt; 2 * L)\r\n                {\r\n                    if (j - cnt - 1 &gt;= 0 && N_N[i][j - cnt - 1] == num + 1)\r\n                        break;\r\n                }\r\n                if (i != N - 1)\r\n                    cnt = 1;\r\n            }\r\n            else if (num - 1 == N_N[i][j])\r\n            {\r\n                if ((j - cnt - 1 &gt;= 0 && N_N[i][j - cnt - 1] == num + 1) && cnt &lt; L)\r\n                    break;\r\n                cnt = 1;\r\n            }\r\n            num = N_N[i][j];\r\n        }\r\n        if (j == N && cnt &gt;= L)\r\n        {\r\n            //cout &lt;&lt; i &lt;&lt; endl;\r\n            answer++;\r\n        }\r\n        else if (j == N && cnt &lt; L) {\r\n            int va2 = 1;\r\n            int va = N_N[i][N - 1];\r\n            for (int k = 0; k &lt; L; k++) {\r\n                if (N_N[i][N - 1 - k] == va + 1) {\r\n                    va2 = 0;\r\n                }\r\n            }\r\n            if (va2 == 1) {\r\n                answer++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d %d&quot;, &N, &L);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; N; j++)\r\n            scanf(&quot;%d&quot;, &N_N[i][j]);\r\n    }\r\n    slop_row();\r\n    slop_colourm();\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}\r\n//범수좌 감사합니다!','2020-03-24 18:16:03',133),(12151601,'SW',2112,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint D, W, K, ans = 10000000;\r\nbool film[13][20];\r\nbool visit[13];\r\n\r\nvoid copyarr(bool a[13][20], bool b[13][20]) {\r\n    for (int i = 0; i &lt; D; i++) {\r\n        for (int j = 0; j &lt; W; j++) {\r\n            b[i][j] = a[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nbool check(bool f[13][20]) {\r\n    bool flag = true;\r\n    for (int i = 0; i &lt; W; i++) {\r\n        int cnt = 0, mx = 0;\r\n        if (flag) {\r\n            for (int j = 1; j &lt; D; j++) {\r\n                if (f[j - 1][i] == f[j][i]) {\r\n                    cnt++;\r\n                    mx = max(cnt, mx);\r\n                }\r\n                else {\r\n                    cnt = 0;\r\n                }\r\n            }\r\n        }\r\n        if (mx &lt; K - 1)\r\n            flag = false;\r\n    }\r\n    return flag;\r\n}\r\n\r\n\r\n\r\nvoid input(int k, int n, bool f[13][20]) {\r\n\r\n    if (check(f) || k == D) {\r\n        ans = min(ans, k);\r\n    }\r\n    else if (ans &gt; k) {\r\n        bool filmcopy[13][20] = { 0 };\r\n        copyarr(f, filmcopy);\r\n        for (int i = n; i &lt; D; i++) {\r\n            if (!visit[i]) {\r\n                visit[i] = true;\r\n                for (int j = 0; j &lt; W; j++)\r\n                    filmcopy[i][j] = true;\r\n                input(k + 1, i, filmcopy);\r\n                for (int j = 0; j &lt; W; j++)\r\n                    filmcopy[i][j] = false;\r\n\r\n                input(k + 1, i, filmcopy);\r\n                for (int j = 0; j &lt; W; j++)\r\n                    filmcopy[i][j] = f[i][j];\r\n                visit[i] = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int t = 1; t &lt;= T; t++) {\r\n        cin &gt;&gt; D &gt;&gt; W &gt;&gt; K;\r\n        for (int i = 0; i &lt; D; i++) {\r\n            for (int j = 0; j &lt; W; j++) {\r\n                cin &gt;&gt; film[i][j];\r\n            }\r\n        }\r\n        if (K == 1) {\r\n            cout &lt;&lt; &#39;#&#39; &lt;&lt; t &lt;&lt; &#39; &#39; &lt;&lt; 0 &lt;&lt; &#39;inha_univ&#39;;\r\n        }\r\n        else {\r\n            input(0, 0, film);\r\n            cout &lt;&lt; &#39;#&#39; &lt;&lt; t &lt;&lt; &#39; &#39; &lt;&lt; ans &lt;&lt; &#39;inha_univ&#39;;\r\n\r\n            ans = 10000000;\r\n        }\r\n    }\r\n}','2020-03-23 17:39:13',134),(12151629,'SW',1952,'for testcase in range(int(input())):\r\n    D, M, M3, Y = map(int, input().split())\r\n    plan = list(map(int, input().split()))\r\n    cost_min = [[0, 0, 0] for _ in range(3)]\r\n    for idx, i in enumerate(plan):\r\n        last = (idx+2)%3\r\n        if i == 0:\r\n            cost_min[idx%3] = cost_min[last]\r\n        else:\r\n            last_min = min(cost_min[last])\r\n            cost_min[idx%3] = [x for x in [last_min+(i*D), last_min+M, min(cost_min[idx%3])+M3]]\r\n    if min(cost_min[(len(plan)-1)%3]) &gt; Y:\r\n        print(&#39;#{} {}&#39;.format(testcase+1, Y))\r\n    else:\r\n        print(&#39;#{} {}&#39;.format(testcase+1, (min(cost_min[(len(plan)-1)%3]))))','2020-03-23 18:19:18',135),(12151601,'BJ',1309,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int N, ans = 0;\r\n    int d[2][3];\r\n    d[0][0] = d[0][1] = d[0][2] = 1;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N - 1; i++) {\r\n        d[1][0] = d[0][0] + d[0][1] + d[0][2];\r\n        d[1][1] = d[0][0] + d[0][2];\r\n        d[1][2] = d[0][0] + d[0][1];\r\n        for (int n = 0; n &lt; 3; n++)\r\n            d[0][n] = d[1][n] % 9901;\r\n    }\r\n    for (int i = 0; i &lt; 3; i++) {\r\n        ans += d[0][i];\r\n    }\r\n    cout &lt;&lt; ans % 9901;\r\n}','2020-03-23 18:15:25',136),(12151551,'BJ',1495,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint V[101] = { 0 };\r\nint N, S, M;\r\nint dp[101][1001] = { 0 };\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; S &gt;&gt; M;\r\n    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; V[i];\r\n    dp[0][S] = 1;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 0; j &lt;= M; j++) {\r\n            if (dp[i - 1][j] != 0) {\r\n                if(j + V[i] &lt;= M) dp[i][j + V[i]] = 1;\r\n                if(j-V[i] &gt;=0) dp[i][j - V[i]] = 1;\r\n            }\r\n        }\r\n    }\r\n    int result = -1;\r\n    for (int i = 0; i &lt;= M; i++) {\r\n        if (dp[N][i] != 0) result = max(result, i);\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}','2020-03-23 22:01:07',137),(12151551,'BJ',1535,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint per[21] = { 0 };\r\nint hap[21] = { 0 };\r\nint dp[101] = { 0 };\r\n\r\nint main() {\r\n    int N; \r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; per[i];\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; hap[i];\r\n        for (int j = 0; j &lt;= 100; j++) {\r\n            if (dp[j] != 0) {\r\n                if (j - per[i] &gt; 0) dp[j - per[i]] = max(dp[j - per[i]], dp[j] + hap[i]);\r\n            }\r\n        }\r\n        dp[100 - per[i]] = max(dp[100 - per[i]], hap[i]);\r\n    }\r\n    int result = 0;\r\n    for (int i = 1; i &lt;= 100; i++) {\r\n        result = max(result, dp[i]);\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n\r\n}','2020-03-23 22:35:21',138),(12151551,'BJ',14502,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint map[9][9] = { 0 };\r\nint cp[9][9] = { 0 };\r\nbool visit[9][9] = { 0 };\r\nint result = 0;\r\nint N, M;\r\n\r\nbool inner(int x, int y) {\r\n    return (x&lt;N&& y&lt;M && x &gt;= 0 && y &gt;= 0);\r\n}\r\n\r\nvoid safe() {\r\n    int sum = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            if (cp[i][j] == 0) sum++;\r\n        }\r\n    }\r\n    result = max(result, sum);\r\n}\r\n\r\n\r\nvoid virus(int x, int y) {\r\n    for (int i = x; i &lt; N; i++) {\r\n        for (int j = y; j &lt; M; j++) {\r\n            if (cp[i][j] == 2) {\r\n                if (inner(i+1,j)&& cp[i+1][j] == 0) {\r\n                    cp[i + 1][j] = 2;\r\n                    virus(i + 1, j);\r\n                }\r\n                if (inner(i - 1, j) && cp[i - 1][j] == 0) {\r\n                    cp[i - 1][j] = 2;\r\n                    virus(i - 1, j);\r\n                }\r\n                if (inner(i,j+1) && cp[i][j+1] == 0) {\r\n                    cp[i][j+1] = 2;\r\n                    virus(i, j+1);\r\n                }\r\n                if (inner(i, j-1) && cp[i][j-1] == 0) {\r\n                    cp[i][j-1] = 2;\r\n                    virus(i, j-1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid co() {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++)\r\n            cp[i][j] = map[i][j];\r\n    }\r\n\r\n}\r\n\r\n\r\nvoid check(int index) {\r\n    if (index == 3) {\r\n        co();\r\n        virus(0,0);\r\n        safe();\r\n        return;\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            if (map[i][j] == 0) {\r\n                map[i][j] = 1;\r\n                check(index + 1);\r\n                map[i][j] = 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] != 0) visit[i][j] = true;\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            if (map[i][j] == 0) {\r\n                map[i][j] = 1;\r\n                check(1);\r\n                map[i][j] = 0;\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n    return 0;\r\n\r\n}','2020-03-24 00:07:15',139),(12151629,'BJ',14502,'import copy\r\nN, M = map(int,input().split())\r\nmy_map = [list(map(int, input().split())) for _ in range(N)]\r\nzero, one, two = [], [], []\r\nanswer = 0\r\n\r\ndef start(a, b):\r\n    global temp_map, two, N, M, temp_zero\r\n    temp_map[a][b] = 2\r\n    temp_zero -= 1\r\n    # 위\r\n    if a &gt; 0:\r\n        if temp_map[a-1][b] == 0:\r\n            start(a-1, b)\r\n    # 아래\r\n    if a &lt; N-1:\r\n        if temp_map[a+1][b] == 0:\r\n            start(a+1, b)\r\n    # 왼쪽\r\n    if b &gt; 0:\r\n        if temp_map[a][b-1] == 0:\r\n            start(a, b-1)\r\n    # 오른쪽\r\n    if b &lt; M - 1:\r\n        if temp_map[a][b+1] == 0:\r\n            start(a, b+1)\r\n\r\nfor idx1, line in enumerate(my_map):\r\n    for idx2, i in enumerate(line):\r\n        if i == 0 :\r\n            zero.append([idx1,idx2])\r\n        elif i == 1:\r\n            one.append([idx1, idx2])\r\n        else:\r\n            two.append([idx1, idx2])\r\nfor idx1, i in enumerate(zero[:-2]):\r\n    for idx2, j in enumerate(zero[idx1+1:]):\r\n        for idx3, k in enumerate(zero[idx1+idx2+1:]):\r\n            temp_map = copy.deepcopy(my_map)\r\n            temp_zero = len(zero)+len(two)-3\r\n            temp_map[i[0]][i[1]] = 1\r\n            temp_map[j[0]][j[1]] = 1\r\n            temp_map[k[0]][k[1]] = 1\r\n            for a, b in two:\r\n                start(a, b)\r\n            if answer &lt; temp_zero:\r\n                answer = temp_zero\r\nprint(answer)','2020-03-24 14:40:59',140),(12151526,'BJ',1535,'#include&lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\nint N;\r\nint max_num;\r\nstruct st {\r\n    int health;\r\n    int happy;\r\n};\r\nst node[20];\r\nint heal[100];\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; node[i].health;\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; node[i].happy;\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 99; j &gt;= 0; j--) {\r\n            if (heal[j] != 0) {\r\n                if (j + node[i].health &lt; 100) {\r\n                    heal[j + node[i].health] = max(heal[j + node[i].health], heal[j] + node[i].happy);\r\n                    max_num = max(max_num, heal[j + node[i].health]);\r\n                }\r\n            }\r\n        }\r\n        if (node[i].health &lt; 100) {\r\n            heal[node[i].health] = max(node[i].happy, heal[node[i].health]);\r\n            max_num = max(max_num, heal[node[i].health]);\r\n        }\r\n    }\r\n    cout &lt;&lt; max_num;\r\n}','2020-03-24 15:20:51',141),(12151536,'BJ',1535,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint L[21];\r\nint J[21];\r\nint hp = 100;\r\nint happy = 0;\r\nint ans = 0;\r\n\r\nvoid check_happy() {\r\n    if (happy &gt; ans) {\r\n        ans = happy;\r\n    }\r\n}\r\n\r\nvoid dfs(int p, int cnt) {\r\n    if (hp &lt;= 0)return;\r\n\r\n    if (cnt == N) {\r\n        check_happy();\r\n        return;\r\n    }\r\n\r\n    //인사안하기\r\n    dfs(p + 1, cnt + 1);\r\n    \r\n    //인사하기\r\n    hp -= L[p];\r\n    happy += J[p];\r\n    dfs(p + 1, cnt + 1);\r\n    hp += L[p];\r\n    happy -= J[p];\r\n}\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; L[i];\r\n    }\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; J[i];\r\n    }\r\n    dfs(1, 0);\r\n    printf(&quot;%d&quot;, ans);\r\n    return 0;\r\n}','2020-03-24 16:31:04',142),(12151526,'BJ',1495,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint N, S, M;\r\nint dp[101][1001];\r\nint node[100];\r\nint res;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; S &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; node[i];\r\n    }\r\n    dp[0][S] = 1;\r\n    for (int i = 1; i &lt;= N - 1; i++) {\r\n        int change = 0;\r\n        for (int j = M; j &gt;= 0; j--) {\r\n            if (dp[i - 1][j] != 0) {\r\n                if (j + node[i - 1] &lt;= M) {\r\n                    change = 1;\r\n                    dp[i][j + node[i - 1]] = 1;\r\n                }\r\n                if (j - node[i - 1] &gt;= 0) {\r\n                    change = 1;\r\n                    dp[i][j - node[i - 1]] = 1;\r\n                }\r\n            }\r\n        }\r\n        if (change == 0) {\r\n            cout &lt;&lt; -1;\r\n            return 0;\r\n        }\r\n    }\r\n    int change = 0;\r\n    for (int j = M; j &gt;= 0; j--) {\r\n        if (dp[N - 1][j] != 0) {\r\n            if (j + node[N - 1] &lt;= M) {\r\n                change = 1;\r\n                res = max(res, j + node[N - 1]);\r\n            }\r\n            if (j - node[N - 1] &gt;= 0) {\r\n                change = 1;\r\n                res = max(res, j - node[N - 1]);\r\n            }\r\n        }\r\n    }\r\n    if (change == 0) {\r\n        cout &lt;&lt; -1;\r\n        return 0;\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-03-24 18:30:11',143),(12151526,'BJ',14502,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\nint N, M;\r\nint map[8][8];\r\nint map2[8][8];\r\nint arr[3];\r\nint dx[4] = { -1,1,0,0 };\r\nint dy[4] = { 0,0,-1,1 };\r\nint res;\r\nstruct st {\r\n    int x;\r\n    int y;\r\n};\r\nvector&lt;st&gt;loca;\r\nqueue&lt;st&gt;qu;\r\nvoid various(queue&lt;st&gt;q) {\r\n    int va = 0;\r\n    queue&lt;st&gt;q2 = q;\r\n    while (!q2.empty()) {\r\n        int x = q2.front().x;\r\n        int y = q2.front().y;\r\n        q2.pop();\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            if (x + dx[i] &gt;= 0 && x + dx[i] &lt; N&&y + dy[i] &gt;= 0 && y + dy[i] &lt; M) {\r\n                if (map2[x + dx[i]][y + dy[i]] == 0) {\r\n                    map2[x + dx[i]][y + dy[i]] = 2;\r\n                    q2.push({ x + dx[i],y + dy[i] });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            if (map2[i][j] == 0) va++;\r\n        }\r\n    }\r\n    res = max(res, va);\r\n}\r\nvoid lab(int a, int b) {\r\n    if (a == 3) {\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; M; j++) {\r\n                map2[i][j] = map[i][j];\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; 3; i++) {\r\n            map2[loca[arr[i]].x][loca[arr[i]].y] = 1;\r\n        }\r\n        various(qu);\r\n    }\r\n    else {\r\n        for (int i = b; i &gt;= 0; i--) {\r\n            arr[a] = i;\r\n            lab(a + 1, i - 1);\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == 0) {\r\n                loca.push_back({ i,j });\r\n            }\r\n            else if (map[i][j] == 2) {\r\n                qu.push({ i,j });\r\n            }\r\n        }\r\n    }\r\n    lab(0, loca.size() - 1);\r\n    cout &lt;&lt; res;\r\n}','2020-03-24 19:15:05',144),(12181751,'BJ',2565,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint elec[501] = { 0 };\r\nint elec2[501] = { 0 };\r\nint answer[501] = { 0 };\r\nint N;\r\nint mmax1 = 0;\r\nint mmax2 = 0;\r\nint max(int a, int b)\r\n{\r\n    if (a &gt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        int c1, c2;\r\n        scanf(&quot;%d %d&quot;, &c1, &c2);\r\n        elec[c2] = c1;\r\n        elec2[c1] = c2;\r\n        if (mmax1 &lt; c1)\r\n            mmax1 = c1;\r\n        if (mmax2 &lt; c2)\r\n            mmax2 = c2;\r\n    }\r\n    answer[mmax2] = 1;\r\n    int ans = 1;\r\n    for (int i = mmax2-1; i &gt;= 1; i--)\r\n    {\r\n        if (elec[i] == 0)\r\n            continue;\r\n        for (int j = elec[i]; j &lt;= mmax1; j++)\r\n        {\r\n            if (elec2[j] == 0)\r\n                continue;\r\n            if (elec2[j] &gt; i)\r\n                answer[i] = max(answer[elec2[j]], answer[i]);\r\n        }\r\n        answer[i]++;\r\n        ans = max(ans, answer[i]);\r\n    }\r\n    cout &lt;&lt; N - ans &lt;&lt; endl;\r\n}','2020-03-24 22:01:54',145),(12151551,'BJ',10845,'import java.util.*;\r\n\r\nclass queue{\r\n    int fr;\r\n    int ba;\r\n    int[] arr;\r\n    public queue() {\r\n        fr = -1;\r\n        ba = -1;\r\n        arr = new int[10000];\r\n    }\r\n    public void push(int val) {\r\n        ba++;\r\n        arr[ba] = val;\r\n    }\r\n    \r\n    public int empty() {\r\n        if(fr==ba) return 1;\r\n        else return 0;\r\n    }\r\n    \r\n    public int front() {\r\n        if(empty() == 1) return -1;\r\n        else return arr[fr+1]; \r\n    }\r\n    public int size() {\r\n        return ba-fr;\r\n    }\r\n    public int pop() {\r\n        if(empty() == 1) return -1;\r\n        else {\r\n            fr++;\r\n            return arr[fr];\r\n        }\r\n    }\r\n    public int back() {\r\n        if(empty() == 1) return -1;\r\n        else return arr[ba];\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        queue my = new queue();\r\n        Scanner sc= new Scanner(System.in);\r\n        int N;\r\n        N= sc.nextInt();\r\n        for(int i=0; i&lt;N+1; i++) {\r\n            String v = sc.nextLine();\r\n            String[] a = v.split(&quot; &quot;);\r\n            if(a[0].contentEquals(&quot;push&quot;)) {\r\n                my.push(Integer.parseInt(a[1]));\r\n            }\r\n            else if(a[0].contentEquals(&quot;pop&quot;)) {\r\n                System.out.println(my.pop());\r\n            }\r\n            else if(a[0].contentEquals(&quot;front&quot;)) {\r\n                System.out.println(my.front());\r\n            }\r\n            else if(a[0].contentEquals(&quot;back&quot;)) {\r\n                System.out.println(my.back());\r\n            }\r\n            else if(a[0].contentEquals(&quot;size&quot;)) {\r\n                System.out.println(my.size());\r\n            }\r\n            else if(a[0].contentEquals(&quot;empty&quot;)) {\r\n                System.out.println(my.empty());\r\n            }\r\n        }\r\n    }\r\n}\r\n','2020-03-26 17:11:24',146),(12151551,'BJ',10828,'import java.util.*;\r\n\r\nclass queue{\r\n    int fr;\r\n    int ba;\r\n    int[] arr;\r\n    public queue() {\r\n        ba = 0;\r\n        arr = new int[10000];\r\n    }\r\n    public void push(int val) {\r\n        ba++;\r\n        arr[ba] = val;\r\n    }\r\n    \r\n    public int empty() {\r\n        if(ba == 0) return 1;\r\n        else return 0;\r\n    }\r\n    \r\n    public int top() {\r\n        if(empty() == 1) return -1;\r\n        else return arr[ba]; \r\n    }\r\n    public int size() {\r\n        if(empty() == 1) return 0;\r\n        else return ba;\r\n    }\r\n    public int pop() {\r\n        if(empty() == 1) return -1;\r\n        else {\r\n            int re = arr[ba];\r\n            ba--;\r\n            return re;\r\n        }\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String args[]) {\r\n        queue my = new queue();\r\n        Scanner sc= new Scanner(System.in);\r\n        int N;\r\n        N= sc.nextInt();\r\n        for(int i=0; i&lt;N+1; i++) {\r\n            String v = sc.nextLine();\r\n            String[] a = v.split(&quot; &quot;);\r\n            if(a[0].contentEquals(&quot;push&quot;)) {\r\n                my.push(Integer.parseInt(a[1]));\r\n            }\r\n            else if(a[0].contentEquals(&quot;pop&quot;)) {\r\n                System.out.println(my.pop());\r\n            }\r\n            else if(a[0].contentEquals(&quot;top&quot;)) {\r\n                System.out.println(my.top());\r\n            }\r\n            else if(a[0].contentEquals(&quot;size&quot;)) {\r\n                System.out.println(my.size());\r\n            }\r\n            else if(a[0].contentEquals(&quot;empty&quot;)) {\r\n                System.out.println(my.empty());\r\n            }\r\n        }\r\n    }\r\n}\r\n','2020-03-26 17:30:49',147),(12181751,'BJ',12865,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N;\r\nint K;\r\nstruct ppair\r\n{\r\n    int a; int b;\r\n};\r\nppair value[101] = { 0 };\r\nint answer[100001] = { 0 };\r\nint mmax(int a, int b)\r\n{\r\n    if (a &gt; b)\r\n        return a;\r\n    else\r\n        return b;\r\n}\r\nint main()\r\n{\r\n    scanf(&quot;%d %d&quot;, &N, &K);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        int c1, c2;\r\n        scanf(&quot;%d %d&quot;, &c1, &c2);\r\n        value[i].a=c1;\r\n        value[i].b = c2;\r\n    }\r\n    for (int x = 0; x &lt; N; x++)\r\n    {\r\n        for (int y = K; y &gt;= 1; y--)\r\n        {\r\n            int check = value[x].a;\r\n            if (check == y)\r\n                answer[check] = mmax(value[x].b, answer[check]);\r\n            else if(check + y &lt;= K)\r\n                answer[check + y] = mmax(answer[check + y],answer[y]+value[x].b);\r\n        }\r\n    }\r\n    cout &lt;&lt; answer[K] &lt;&lt; endl;\r\n}','2020-03-26 22:34:55',148),(12151536,'BJ',14502,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint proto_lab[9][9];\r\nint lab[9][9];\r\nint n, m;\r\nbool visited[9][9];\r\n\r\nqueue &lt;pair&lt;int, int&gt;&gt; q;\r\n\r\nint dx[4] = { -1,1,0,0 };\r\nint dy[4] = { 0,0,1,-1 };\r\nint ans = 0;\r\n\r\nvoid bfs();\r\n\r\nvoid make_wall(int idx,int cnt) {\r\n    if (cnt == 3) {\r\n        bfs();\r\n        return;\r\n    }\r\n    for (int i = idx; i &lt; n *m; i++) {\r\n        int col = i / m;\r\n        int row = i % m;\r\n        if (lab[col][row] == 1 || lab[col][row] == 2)continue;\r\n        if (visited[col][row] == true)continue;\r\n        visited[col][row] = true;\r\n        make_wall(i, cnt + 1);\r\n        visited[col][row] = false;\r\n    }\r\n}\r\n\r\n\r\n\r\nvoid copy_lab(int a[9][9], int b[9][9]) {\r\n    for (int i = 0; i &lt; n; i++) {\r\n        for (int j = 0; j &lt; m; j++) {\r\n            a[i][j] = b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid check_0() {\r\n    int count = 0;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        for (int j = 0; j &lt; m; j++) {\r\n            if (lab[i][j] == 0) {\r\n                count++;\r\n            }\r\n        }\r\n    }\r\n    if (ans &lt; count)ans = count;\r\n}\r\n\r\nvoid bfs() {\r\n    for (int i = 0; i &lt; n; i++) {\r\n        for (int j = 0; j &lt; m; j++) {\r\n            if (lab[i][j] == 2) {\r\n                q.push(make_pair(i, j));\r\n            }\r\n            if (visited[i][j] == true) { //조합으로 뽑은 것을 1로 바꿔준다\r\n                lab[i][j] = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    while (!q.empty()) {\r\n        int x = q.front().first;\r\n        int y = q.front().second;\r\n        q.pop();\r\n\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = x + dx[i];\r\n            int ny = y + dy[i];\r\n            if (0 &lt;= nx && nx &lt; n && 0 &lt;= ny && ny &lt; m) {\r\n                if (lab[nx][ny] == 0) {\r\n                    lab[nx][ny] = 2;\r\n                    q.push(make_pair(nx, ny));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    check_0();\r\n    copy_lab(lab, proto_lab); //다시 되돌리기\r\n\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    //바이러스 입력\r\n    for (int i = 0; i &lt; n; i++) {\r\n        for (int j = 0; j &lt; m; j++) {\r\n            cin &gt;&gt; proto_lab[i][j];\r\n        }\r\n    }\r\n\r\n\r\n    copy_lab(lab, proto_lab);\r\n    make_wall(0,0);\r\n    cout &lt;&lt; ans &lt;&lt; endl;\r\n\r\n    return 0;\r\n\r\n    //바이러스 퍼뜨리기\r\n    /*\r\n    for (int i = 0; i &lt; n; i++) {\r\n        for (int j = 0; j &lt; m; j++) {\r\n            bfs(i, j);\r\n        }\r\n    }\r\n    */\r\n    /*\r\n    for (int i = 0; i &lt; n; i++) {\r\n        for (int j = 0; j &lt; m; j++) {\r\n            printf(&quot;%d &quot;, lab[i][j]);\r\n        }\r\n        printf(&quot;inha_univ&quot;);\r\n    }\r\n    */\r\n\r\n}','2020-03-26 23:59:13',149),(12151629,'BJ',10828,'import java.util.*;\r\n\r\nclass My_stack {\r\n    int[] space = new int[10005];\r\n    int size = 0;\r\n\r\n    public void push(int a) {\r\n        space[size] = a;\r\n        size += 1;\r\n    }\r\n\r\n    public void pop() {\r\n        if (size == 0) System.out.println(-1);\r\n        else {\r\n            size -= 1;\r\n            System.out.println(space[size]);\r\n        }\r\n    }\r\n\r\n    public void size() {\r\n        System.out.println(size);\r\n    }\r\n\r\n    public void empty() {\r\n        if (size == 0) System.out.println(1);\r\n        else System.out.println(0);\r\n    }\r\n\r\n    public void top() {\r\n        if (size == 0) System.out.println(-1);\r\n        else System.out.println(space[size - 1]);\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[ ] args){\r\n        My_stack stack = new My_stack();\r\n        Scanner sc = new Scanner(System.in);\r\n        int N;\r\n        N = sc.nextInt();\r\n        for(int i=0; i&lt;=N;i++){\r\n            String order = sc.nextLine();\r\n            String[] order1 = order.split(&quot; &quot;);\r\n            if(order1[0].equals(&quot;push&quot;)){\r\n                stack.push(Integer.parseInt(order1[1]));\r\n            }else if(order1[0].equals(&quot;pop&quot;)){\r\n                stack.pop();\r\n            }else if(order1[0].equals(&quot;size&quot;)){\r\n                stack.size();\r\n            }else if(order1[0].equals(&quot;empty&quot;)){\r\n                stack.empty();\r\n            }else if(order1[0].equals(&quot;top&quot;)){\r\n                stack.top();\r\n            }\r\n        }\r\n    }\r\n}\r\n','2020-03-27 16:55:31',150),(12151601,'BJ',10845,'import java.util.Scanner;\r\n\r\nclass myQueue {\r\n\r\n    int cursor, first;\r\n    int[] arr;\r\n\r\n    public myQueue() {\r\n        cursor = 0;\r\n        first = 0;\r\n        arr = new int[10000];\r\n    }\r\n\r\n    public void push(int a) {\r\n        arr[cursor++] = a;\r\n    }\r\n\r\n    public int empty() {\r\n        if (first == cursor)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    public int front() {\r\n        if (empty() == 1)\r\n            return -1;\r\n        else\r\n            return arr[first];\r\n    }\r\n\r\n    public int back() {\r\n        if (empty() == 1)\r\n            return -1;\r\n        else\r\n            return arr[cursor - 1];\r\n    }\r\n\r\n    public void pop() {\r\n        if (empty() == 0) {\r\n            System.out.println(arr[first]);\r\n            first++;\r\n        } else\r\n            System.out.println(-1);\r\n    }\r\n\r\n    public int size() {\r\n        return cursor - first;\r\n    }\r\n\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        myQueue myQueue = new myQueue();\r\n        Scanner sc = new Scanner(System.in);\r\n        int n = sc.nextInt();\r\n        for (int i = 0; i &lt; n; i++) {\r\n            String string;\r\n            string = sc.next();\r\n\r\n            if (string.equals(&quot;push&quot;)) {\r\n                int integer = sc.nextInt();\r\n                myQueue.push(integer);\r\n            } else if (string.equals(&quot;empty&quot;)) {\r\n                System.out.println(myQueue.empty());\r\n\r\n            } else if (string.equals(&quot;size&quot;)) {\r\n                System.out.println(myQueue.size());\r\n            } else if (string.equals(&quot;front&quot;)) {\r\n                System.out.println(myQueue.front());\r\n            } else if (string.equals(&quot;back&quot;)) {\r\n                System.out.println(myQueue.back());\r\n            } else if (string.equals(&quot;pop&quot;)) {\r\n                myQueue.pop();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n','2020-03-27 18:11:26',151),(12161783,'BJ',14890,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint arr[101][101];\r\nint carr[101][101];\r\n\r\nint main() {\r\n    int N, L;\r\n    cin &gt;&gt; N &gt;&gt; L;\r\n\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            cin &gt;&gt; arr[i][j];\r\n        }\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            carr[i][j]=arr[j][i];\r\n        }\r\n    }\r\n\r\n    int cnt,ex; \r\n    int ans = 0;//ans만 내면되므로 코딩할때 ans만 늘려주는 경우의 수만 생각\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cnt = 1;\r\n        ex = 1;\r\n        for (int j = 1; j &lt; N; j++) {\r\n            \r\n            if (arr[i][j] == arr[i][j + 1]) {\r\n                cnt++;\r\n                ex++;\r\n            }\r\n            else if (arr[i][j] == arr[i][j + 1] - 1 && cnt &gt;= L) { cnt = 1; ex++; }\r\n            else if (arr[i][j] - 1 == arr[i][j + 1] && cnt &gt;= 0) { cnt = 1 - L; ex++; }\r\n            else break;\r\n        }\r\n        if (ex==N&& cnt &gt;= 0)ans++;\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cnt = 1;\r\n        ex = 1;\r\n        for (int j = 1; j &lt; N; j++) {\r\n\r\n            if (carr[i][j] == carr[i][j + 1]) {\r\n                cnt++;\r\n                ex++;\r\n            }\r\n            else if (carr[i][j] == carr[i][j + 1] - 1 && cnt &gt;= L) { cnt = 1; ex++; }\r\n            else if (carr[i][j] - 1 == carr[i][j + 1] && cnt &gt;= 0) { cnt = 1 - L; ex++; }\r\n            else break;\r\n        }\r\n        if (ex == N && cnt &gt;= 0)ans++;\r\n    }\r\n\r\n\r\n\r\n    cout &lt;&lt; ans;\r\n    \r\n    return 0;\r\n}','2020-03-28 00:18:53',152),(12161777,'BJ',10844,'#include &lt;iostream&gt;\r\n\r\nint dp[100 + 1][10 + 1];\r\nconst int max = 1000000000; \r\n\r\nint main(void)\r\n{\r\n    int n; \r\n    std::cin &gt;&gt; n;           //일반적으로  using namespace std를 통해서 cin을 하면 컴파일 에러가 발생\r\n\r\n    // dp[i][j]의 의미는 i자릿수의 마지막 수가 j인 숫자들의 개수, 맨처음엔 맨 앞자리를 기준으로 하려했으나 뒤로 갈수록 따져줘야할게 많아서 맨뒤를 기준으로 바꿔주었다.\r\n    // 처음의 의도는 맨앞 자리 기준으로 +1,-1만 가능한 성질을 이용하여 하려했으나 자리수가 늘어남에 따라 -1,10에 의한 case가 불규칙적이어서 기준을 바꿈\r\n    for (int i = 1; i &lt;= 9; i++) { dp[1][i] = 1; } // 자리수가 1이면 당연히 1~9까지 1개만 올수있으므로 1이다.\r\n\r\n    // 처음 값은 계산했으므로 2자릿수부터 시작한다.\r\n    for (int i = 2; i &lt;= n; i++) {\r\n        // j가 9라 j+1이 10인경우, j가 0일 경우 j-1이 -1이 되어  인덱스를 벗어난다.\r\n        // 0,9일때는 예외처리를 해준다.\r\n        for (int j = 0; j &lt;= 9; j++) {\r\n            if (j == 0) dp[i][j] = dp[i - 1][j + 1] % max;\r\n            else if (j + 1 == 10) dp[i][j] = dp[i - 1][j - 1] % max;\r\n            else dp[i][j] = (dp[i - 1][j - 1] % max + dp[i - 1][j + 1] % max) % max;\r\n        }\r\n    }\r\n\r\n    int result = 0;\r\n\r\n    // 다 계산하고 모듈러 연산을 해줄 경우 값의 크기를 감당할 수 없으므로  모듈러 연산의 성질을 이용해서 계산할 때마다 해준다.\r\n    // (a+b) % c = (a%c+b%c)%c : 값들을 매번 업데이트 해주는 방법\r\n    for (int i = 0; i &lt;= 9; i++) { result = (result + dp[n][i]) % max; }\r\n\r\n    std::cout &lt;&lt; result % max;  // 최종답안 : 최종결과에 모듈러를 나눠준 값\r\n\r\n    return 0;\r\n}\r\n','2020-03-28 12:51:34',153),(12171820,'BJ',10844,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n//int n;\r\nvector &lt;int&gt; bb;\r\nint sum = 0;\r\nvoid next(int i,int n)\r\n{\r\n    n--;\r\n    if (n == 0)\r\n    {\r\n        sum++;\r\n        bb.pop_back();\r\n        return;\r\n    \r\n    }\r\n    if (bb[i] == 0)\r\n    {\r\n    \r\n        bb.push_back(1);\r\n        next(i+1 ,n);\r\n    }\r\n    else if ((0&lt; bb[i]) &&(bb[i] &lt; 9))\r\n    {\r\n        \r\n        bb.push_back(bb[i] - 1);\r\n        next(i+1 ,n);\r\n        bb.push_back(bb[i] + 1);\r\n        next(i+1 ,n);\r\n    }\r\n    else if (bb[i] == 9)\r\n    {\r\n    \r\n        bb.push_back(8);\r\n        next(i+1 ,n);\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    cin &gt;&gt; n;\r\n\r\n    for (int i = 1; i &lt;= 9; i++)\r\n    {\r\n        bb.push_back(i);\r\n        next(0,n);\r\n        bb.clear();\r\n    }\r\n    cout &lt;&lt; sum &lt;&lt; endl;\r\n\r\n}','2020-03-28 14:36:08',154),(12171820,'BJ',2565,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n\r\n\r\nvector &lt;pair&lt;int,int&gt;&gt; elec;\r\nbool compare(pair&lt;int,int&gt;a ,pair&lt;int,int&gt;b)\r\n{\r\n    return a.first &lt; b.first;\r\n}\r\n\r\nint main()\r\n{\r\n    int a[101];\r\n    int N;\r\n    int A, B;\r\n    cin &gt;&gt; N;\r\n    int res = 0;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; A &gt;&gt; B;\r\n        elec.push_back({ A,B });\r\n    }\r\n\r\n    sort(elec.begin(), elec.end(), compare);\r\n    \r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        a[i] = 1;\r\n        int len = 1;\r\n        for (int j = i + 1; j &lt; N; j++)\r\n        {\r\n            if (elec[i].second &lt; elec[j].second)\r\n            {\r\n                len = max(len,( a[i] + a[j]));\r\n            }\r\n        }\r\n        a[i] = len;\r\n        res = max(len , res );\r\n    }\r\n    cout &lt;&lt; N - res &lt;&lt; endl;\r\n}','2020-03-28 14:37:30',155),(12161746,'BJ',2565,'#include&lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nstruct st{\r\n    int first;\r\n    int second;\r\n};\r\n\r\nint N;\r\nst line[101];\r\nint cnt = 0;\r\nint result = 1;\r\n\r\nbool cpr(st A, st B)\r\n{\r\n    return A.first &lt; B.first;    //오름차순으로 정렬\r\n}\r\n\r\nint code()\r\n{\r\n    sort(line, line + N + 1, cpr);    //line부터 line+n+1 까지 함수 기준 정렬\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        line[i].second = 1;        //1개부터 시작.\r\n        for (int j = 0; j &lt; i; j++)\r\n        {\r\n            if (line[j].second &lt; line[i].second)\r\n                result = max(result, line[i].second + line[j].second);    //j는 i의 직전 값\r\n        }\r\n        cnt = max(cnt, result);    //최대 개수 출력\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; line[i].first &gt;&gt; line[i].second;        //첫번째 전봇대와 두번째 전봇대 차례대로 입력\r\n    }\r\n    code();\r\n    cout &lt;&lt; N - cnt;            //최소 개수 출력\r\n}','2020-03-28 14:45:01',156),(12161746,'BJ',14890,'//아직 다 못했슴다ㅜ\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint x, y, N, L, start, D;\r\nint runway[101][101];\r\nint visit[101];\r\nint current[10][10];\r\nint cnt = 0;\r\n\r\nvoid col()\r\n{\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        visit[start] = 1; //방문 후 1로 바꾸기\r\n        for (int j = 0; j &lt; i; j++)\r\n        {\r\n            if (visit[i] == 1) continue;        //방문확인\r\n            if (runway[i][j] == runway[i][j + 1])    //1. 높이가 모두 같을 때\r\n            {\r\n                \r\n            }\r\n            //2. 높이 1칸 차이나는거 찾기\r\n            else if (runway[i][j + 1] - runway[i][j] == 1)\r\n            {\r\n                D = runway[i][j];\r\n                //3. i번부터 L-i+1까지의 길이가 L인지 찾기\r\n                for (int k = 0; k &lt; L; k++)\r\n                {\r\n                    runway[i][k] -\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid row()\r\n{\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        visit[start] = 1; //방문 후 1로 바꾸기\r\n        for (int j = 0; j &lt; i; j++)\r\n        {\r\n            if (visit[i] == 1) continue;        //방문확인\r\n            if (runway[i][j] == runway[i + 1][j])    //1. 높이가 모두 같을 때\r\n            {\r\n                cnt++;\r\n            }\r\n            //2. 높이 1칸 차이나는거 찾기\r\n            else if (runway[i + 1][j] - runway[i][j] == 1)\r\n            {\r\n                D = runway[i][j];\r\n                //3. i번부터 L-i+1까지의 길이가 L인지 찾기\r\n                for (int k = 0; k &lt; L; k++)\r\n                {\r\n                    runway[i][k] -\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; L;\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= N; j++)\r\n        {\r\n            cin &gt;&gt; runway[i][j];\r\n            runway[i][j] = runway[j][i];\r\n        }\r\n    }\r\n    cout;\r\n}','2020-03-28 14:45:59',157),(12161783,'BJ',10844,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint dp[101][10];\r\nint main() {\r\n\r\n    int n;\r\n    cin &gt;&gt; n;\r\n\r\n    for (int i = 1; i &lt;= 9; i++) {\r\n        dp[1][i] = 1;\r\n    }\r\n\r\n    for (int i = 2; i &lt;= n; i++) {\r\n        for (int j = 0; j &lt;= 9; j++) {\r\n            if (j == 0) {\r\n                dp[i][j] = dp[i - 1][j + 1] % 1000000000;\r\n            }\r\n            else if (j == 9) {\r\n                dp[i][j] = dp[i - 1][j - 1] % 1000000000; \r\n            }\r\n            else {\r\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000000;\r\n            }\r\n        }\r\n    }\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i &lt;= 9; i++) {\r\n        sum = (sum + dp[n][i]) % 1000000000;\r\n    }\r\n\r\n    cout &lt;&lt; sum ;\r\n\r\n    return 0;\r\n}','2020-03-28 14:53:04',158),(12161777,'BJ',2565,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n\r\n    int N, elec1, elec2, dp[100] = {};\r\n    vector&lt;pair&lt;int, int&gt;&gt;v;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; elec1 &gt;&gt; elec2;\r\n        v.push_back(make_pair(elec1, elec2)); //전깃줄 1,2 이어진상태\r\n    }\r\n    sort(v.begin(), v.end()); //elec1의 전깃줄을 오름차순으로 소팅\r\n\r\n    dp[0] = 1;\r\n    for (int i = 1; i &lt; N; i++) {\r\n        int a = 0;\r\n        for (int j = 0; j &lt; i; j++)\r\n            if (v[j].second &lt; v[i].second)\r\n                a = max(a, dp[j]);\r\n        dp[i] = a + 1;\r\n    }\r\n    int x = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        x = max(dp[i], x);\r\n    }\r\n    cout &lt;&lt; N - x;\r\n\r\n    return 0;\r\n}\r\n\r\n','2020-03-28 15:54:16',159),(12181853,'BJ',14890,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;cstring&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n#define MAX 101\r\n\r\nint N; // 지도의 가로 세로 길이\r\nint L; // 경사로의 길이\r\nint map[MAX][MAX]; // int map[a][b] = c -&gt; a열 b행은 높이가 c이다\r\n                   // 길을 지나기 위해서는 높이가 모두 동일해야 함\r\n                   // 경사로를 통해 낮은 칸과 높은 칸을 연결 가능\r\n                   // 경사로는 높이 차이가 1인 낮은 칸과 높은 칸을 연결해준다\r\n                   // 경사로는 바닥과 접하게 놓아야 한다\r\n                   // 경사로는 겹치게 놓아서는 안된다\r\n                   // 경사로는 기울이게 놓아서도 안된다\r\nbool visited[MAX];\r\nint cnt = 0; // 출력하는 지나갈 수 있는 길의 개수\r\nint LEN = 0; // 낮아지는 칸의 개수 (길이)\r\n\r\n\r\nvoid runway_row(int y)\r\n{\r\n    int current = map[y][1]; // 좌표로 쳤을 떄 현재 내가 있는 위치의 좌표는 (y, 1)\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        if (map[y][i] != current) // 1부터 N까지 한 row를 모두 탐색할 때 기준점은 제외\r\n        {\r\n            if (!(abs(map[y][i] - current) &lt;= 1)) // current를 기준으로 map[y][i] - 기준점의 차이가 1보다 크다면\r\n            {\r\n                return; // 조건 불충족 리턴\r\n            }\r\n\r\n            if (map[y][i] &lt; current) // 기준점에 대해서 다른 모든 높이보다 기준점의 값이 제일 작을 때, \r\n            {\r\n                LEN = -1;\r\n                for (int j = i; j &lt; i + L; j++) // visited[i] ~ visited[i + L]로 방문하지 않은 i ~ i + L로 경사로가 놓일 수 있는 지점을 발견\r\n                {\r\n                    if (!visited[j] && j &lt;= N) // 아직 탐색하지 않은 지점에 그 지점은 지도의 범위 내에 있어야 하므로\r\n                    {\r\n                        visited[j] = true; // 지점을 방문함으로 체크!\r\n                        if (LEN == -1) // LEN == -1이므로 낮은 점이 존재함!\r\n                        {\r\n                            LEN = map[y][j]; // 경사로가 놓일 수 있는 지점을 모두 탐색하엿고, 그 값을 LEN에 지정\r\n                            continue;\r\n                        }\r\n\r\n                        if (LEN != -1 && map[y][j] != LEN) // LEN != 1이고 각 map[y][j]가 != LEN이면 -&gt; 즉 낮은 지점이 존재하지 않는다\r\n                        {\r\n                            return; // 조건 불충족 리턴\r\n                        }\r\n                    }\r\n                    else // 이미 탐색한 지점이라면, 혹은 범위 외의 부분이라면\r\n                    {\r\n                        return; // 조건 불충족 리턴\r\n                    }\r\n                }\r\n                i += L - 1; // 기준점보다 작은 값을 가지는 인덱스 i에 L - 1을 더해준다. 즉 경사로가 놓일 수 있는 지점의 바로 전!\r\n                if (i &gt;= N) // 이 때 더해진 값으로 i가 범위밖으로 벗어나면\r\n                    break; // 탈출잼~\r\n            }\r\n            else // map[y][i]가 current보다 클 경우\r\n            {\r\n                LEN = -1;\r\n                for (int j = i - 1; j &gt; i - 1 - L; j--)\r\n                {\r\n                    if (!visited[j] && j &gt;= 0)\r\n                    {\r\n                        visited[j] = true;\r\n                        if (LEN == -1)\r\n                        {\r\n                            LEN = map[y][j];\r\n                            continue;\r\n                        }\r\n\r\n                        if (LEN != -1 && map[y][j] != LEN)\r\n                        {\r\n                            return;\r\n                        }\r\n                    }\r\n                    else // 방문한 지점일 경우\r\n                    {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            current = map[y][i]; // 다음 칸으로 기준점 넘겨 탐색\r\n        }\r\n    }\r\n    cnt++;\r\n}\r\n\r\nvoid runway_col(int  x)\r\n{\r\n    int current = map[1][x];\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        if (map[i][x] != current)\r\n        {\r\n            if (!(abs(map[i][x] - current) &lt;= 1))\r\n            {\r\n                return;\r\n            }\r\n\r\n            if (map[i][x] &lt; current)\r\n            {\r\n                int LEN = -1;\r\n                for (int j = i; j &lt; i + L; j++)\r\n                {\r\n                    if (!visited[j] && j &lt;= N)\r\n                    {\r\n                        visited[j] = true;\r\n                        if (LEN == -1)\r\n                        {\r\n                            LEN = map[j][x];\r\n                            continue;\r\n                        }\r\n\r\n                        if (LEN != -1 && map[j][x] != LEN)\r\n                        {\r\n                            return;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        return;\r\n                    }\r\n                }\r\n                i += L - 1;\r\n                if (i &gt;= N)\r\n                    break;\r\n            }\r\n            else\r\n            {\r\n                LEN = -1;\r\n                for (int j = i - 1; j &gt; i - 1 - L; j--)\r\n                {\r\n                    if (!visited[j] && j &gt;= 0)\r\n                    {\r\n                        visited[j] = true;\r\n                        if (LEN == -1)\r\n                        {\r\n                            LEN = map[j][x];\r\n                            continue;\r\n                        }\r\n\r\n                        if (LEN != -1 && map[j][x] != LEN)\r\n                        {\r\n                            return;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            current = map[i][x];\r\n        }\r\n    }\r\n    cnt++;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    cin &gt;&gt; N &gt;&gt; L;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= N; j++)\r\n        {\r\n            cin &gt;&gt; map[i][j];\r\n            //scanf(&quot;%d&quot;, &map[i][j]);\r\n        }\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        memset(visited, false, sizeof(visited));\r\n        runway_row(i);\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        memset(visited, false, sizeof(visited));\r\n        runway_col(i);\r\n    }\r\n\r\n    cout &lt;&lt; cnt &lt;&lt; endl;\r\n}','2020-03-28 16:38:03',160),(12181751,'BJ',1912,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint main()\r\n{\r\n    int N;\r\n    int N_[100001] = { 0 };\r\n    int ans[100001] = { 0 };\r\n    scanf(&quot;%d&quot;, &N);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &N_[i]);\r\n        if (i == 0)\r\n            ans[i] = N_[i];\r\n        else\r\n            ans[i] = max(ans[i - 1] + N_[i], N_[i]);//이전부터 차곡차곡 잘 쌓여져 있는게 더 큰지 내 수가 더 큰지 비교해서 넣으면 무조건 이어진다\r\n    }\r\n    sort(ans, ans + N);//중간에 끊기게 되니까 sort로 큰 값이 뒤에 가도록 한다\r\n    cout &lt;&lt; ans[N - 1] &lt;&lt; endl;\r\n}','2020-03-30 12:29:22',161),(12151536,'BJ',1495,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint n, s, m;\r\nint v[101];\r\nint dp[101][1050] = { 0 };\r\n\r\nint main() {\r\n    cin &gt;&gt; n &gt;&gt; s &gt;&gt; m;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        cin &gt;&gt; v[i];\r\n    }\r\n\r\n    if (s + v[0] &lt;= m)dp[0][s + v[0]] = 1;\r\n    if (s - v[0] &gt;= 0)dp[0][s - v[0]] = 1;\r\n\r\n    for (int i = 1; i &lt; n; i++) {\r\n        for (int j = 0; j &lt;= m; j++) {\r\n            if (dp[i - 1][j] == 0)continue;\r\n            if (j + v[i] &lt;= m)dp[i][j + v[i]] = 1;\r\n            if (j - v[i] &gt;= 0)dp[i][j - v[i]] = 1;\r\n        }\r\n    }\r\n\r\n    int ans = -1;\r\n    for (int i = m; i &gt;= 0; i--) {\r\n        if (dp[n-1][i] == 1) {\r\n            if(ans &lt; i)\r\n            ans = i;\r\n        }\r\n    }\r\n    printf(&quot;%d&quot;, ans);\r\n}','2020-03-30 15:42:14',162),(12151629,'BJ',1495,'N, S, M = map(int, input().split())\r\nvol = list(map(int, input().split()))\r\nmy_map = [[0 for _ in range(M+1)] for _ in range(N+1)]\r\nmy_map[0][S] = 1\r\nfor idx, i in enumerate(vol):\r\n    for volume, j in enumerate(my_map[idx]):\r\n        if j == 1:\r\n            if volume - i &gt;= 0:\r\n                my_map[idx+1][volume-i] = 1\r\n            if volume + i &lt;= M:\r\n                my_map[idx+1][volume+i] = 1\r\nfor i in range(M, -1, -1):\r\n    if my_map[-1][i] == 1:\r\n        print(i)\r\n        break\r\n    if i == 0:\r\n        print(-1)\r\n','2020-03-30 17:50:57',163),(12151629,'BJ',1535,'N = int(input())\r\nL, J = [list(map(int, input().split())), list(map(int, input().split()))]\r\nHP = [0 for _ in range(101)]\r\nfor idx, cost in enumerate(L):\r\n    if 100 - cost &lt;= 0 :\r\n        pass\r\n    else:\r\n        for idx2, i in enumerate(HP):\r\n            if i &gt; 0:\r\n                if idx2-cost &gt; 0:\r\n                    if HP[idx2-cost] &lt; i+J[idx]:\r\n                        HP[idx2-cost] = i+J[idx]\r\n        if HP[100-cost] &gt; 0:\r\n            if HP[100-cost] &lt; J[idx]:\r\n                HP[100-cost] = J[idx]\r\n        else:\r\n            HP[100 - cost] = J[idx]\r\nprint(max(HP))','2020-03-30 18:15:12',164),(12151526,'BJ',1106,'#include&lt;iostream&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;math.h&gt;\r\nusing namespace std;\r\nint C, N;\r\nint dp[1001];\r\nint res = 987654321;\r\nstruct st {\r\n    int money;\r\n    int num;\r\n};\r\nst city[20];\r\nint main() {\r\n    cin &gt;&gt; C &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; city[i].money &gt;&gt; city[i].num;\r\n    }\r\n    for (int i = 1; i &lt;= C; i++) {\r\n        dp[i] = 987654321;\r\n    }\r\n    for (int i = 0; i &lt;= C; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            if (i + city[j].num &gt;= C) {\r\n                res = min(res, dp[i] + city[j].money);\r\n            }\r\n            else {\r\n                dp[i + city[j].num] = min(dp[i + city[j].num], dp[i] + city[j].money);\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-03-31 22:27:28',165),(12151551,'BJ',1106,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint dp[1001] = { 0 };\r\nvector&lt; pair&lt;int,int&gt; &gt; v;\r\n\r\nint main() {\r\n    int C, N;\r\n    cin &gt;&gt; C &gt;&gt; N;\r\n    for (int i = 1; i &lt;= 1000; i++) dp[i] = 1000000;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int a, b;\r\n        cin &gt;&gt; a &gt;&gt; b;\r\n        v.push_back({ a,b });\r\n        dp[b] = a;\r\n    }\r\n    int result = 1000000;\r\n    for (int i = 0; i &lt;= C; i++) {\r\n        for (int j = 0; j &lt; v.size(); j++) {\r\n            if (i + v[j].second &gt;= C) result = min(result,dp[i]+v[j].first);\r\n            else dp[i + v[j].second] = min(dp[i + v[j].second],dp[i] + v[j].first);\r\n        }\r\n    }\r\n\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}','2020-04-01 01:25:03',166),(12151616,'BJ',1013,'#include&lt;iostream&gt;\r\n#include&lt;string&gt;\r\nusing namespace std;\r\nint N;\r\nstring str;\r\nbool valid(int s, int e);\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    while (N--) {\r\n        cin &gt;&gt; str;\r\n        cout &lt;&lt; (valid(0, str.size()) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;\r\n    }\r\n    return 0;\r\n}\r\nbool valid(int s, int e) {\r\n    bool ans = false;\r\n    if (s == e) return true;\r\n    if (s+2 &lt; e) {\r\n        if (str[s] == &#39;1&#39; && str[s + 1] == &#39;0&#39; && str[s + 2] == &#39;0&#39;) { // 100+1+\r\n            int stage = 0;\r\n            for (int i = s + 3; i &lt; e; i++) {\r\n                if (stage == 0) { // check 0+ end\r\n                    if (str[i] == &#39;1&#39;) stage = 1;\r\n                }\r\n                if (stage == 1) {\r\n                    if (str[i] == &#39;0&#39;) {\r\n                        ans |= valid(i, e);\r\n                        break;\r\n                    }\r\n                    else {\r\n                        ans |= valid(i+1, e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (s+1 &lt; e) {\r\n        if (str[s] == &#39;0&#39; && str[s + 1] == &#39;1&#39;) {    // 01\r\n            ans |= valid(s + 2, e);\r\n        }\r\n    }\r\n    return ans;\r\n}','2020-04-01 11:20:37',167),(12151526,'BJ',14500,'#include&lt;iostream&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\nint N, M;\r\nint map[500][500];\r\nint res;\r\nint dx[4] = { 1,0,-1,0 };\r\nint dy[4] = { 0,1,0,-1 };\r\nvoid te(int a, int x, int y, int dd, int mama) {\r\n    if (a == 4) {\r\n        res = max(res, mama);\r\n    }\r\n    else if (a == 0) {\r\n        mama += map[x][y];\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            if (x + dx[i] &gt;= 0 && x + dx[i] &lt; N&&y + dy[i] &gt;= 0 && y + dy[i] &lt; M) {\r\n                te(a + 1, x + dx[i], y + dy[i], i, mama);\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int ma = mama;\r\n            for (int j = 0; j &lt; 3; j++) {\r\n                if (x + dx[(i + j) % 4] &gt;= 0 && x + dx[(i + j) % 4] &lt; N&&y + dy[(i + j) % 4] &gt;= 0 && y + dy[(i + j) % 4] &lt; M) {\r\n                    ma += map[x + dx[(i + j) % 4]][y + dy[(i + j) % 4]];\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            res = max(res, ma);\r\n        }\r\n    }\r\n    else {\r\n        mama += map[x][y];\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            if (i != (dd + 2) % 4) {\r\n                if (x + dx[i] &gt;= 0 && x + dx[i] &lt; N&&y + dy[i] &gt;= 0 && y + dy[i] &lt; M) {\r\n                    te(a + 1, x + dx[i], y + dy[i], i, mama);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            te(0, i, j, -1, 0);\r\n        }\r\n    }\r\n    cout &lt;&lt; res;\r\n}','2020-04-01 22:45:20',168),(12151526,'BJ',1013,'#include&lt;iostream&gt;\r\n#include&lt;string&gt;\r\n#include&lt;vector&gt;\r\nusing namespace std;\r\nint T;\r\nvector&lt;string&gt; ve;\r\nvoid test(string s) {\r\n    int va1 = 0; int va2 = 0; int va3 = 0;\r\n    for (int i = 0; i &lt; s.size(); i++) {\r\n        if (va1 == 0 && va2 == 0 && va3 == 0) {\r\n            if (s[i] == &#39;1&#39;) {\r\n                va1 = 1;\r\n            }\r\n            else if (s[i] == &#39;0&#39;) {\r\n                va3 = 1;\r\n            }\r\n            if (i == s.size() - 1) {\r\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n                return;\r\n            }\r\n        }\r\n        else if (va1 == 1) {\r\n            if (s[i] == &#39;1&#39;) {\r\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n                return;\r\n            }\r\n            else if (s[i] == &#39;0&#39;) {\r\n                va1 = 2;\r\n                if (i == s.size() - 1) {\r\n                    cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        else if (va1 == 2) {\r\n            if (s[i] == &#39;1&#39;) {\r\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n                return;\r\n            }\r\n            else if (s[i] == &#39;0&#39;) {\r\n                va1 = 3;\r\n                if (i == s.size() - 1) {\r\n                    cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        else if (va1 == 3) {\r\n            if (s[i] == &#39;1&#39;) {\r\n                va1 = 0; va2 = 1;\r\n                if (i == s.size() - 1) {\r\n                    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                if (i == s.size() - 1) {\r\n                    cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        else if (va2 == 1) {\r\n            if (s[i] == &#39;0&#39;) {\r\n                va2 = 0; va3 = 1;\r\n            }\r\n            else if (s[i] == &#39;1&#39;) {\r\n                va2 = 2;\r\n                if (i == s.size() - 1) {\r\n                    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        else if (va2 == 2) {\r\n            if (s[i] == &#39;0&#39;) {\r\n                va2 = 3;\r\n            }\r\n            else {\r\n                if (i == s.size() - 1) {\r\n                    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        else if (va2 == 3) {\r\n            if (s[i] == &#39;0&#39;) {\r\n                va1 = 3; va2 = 0;\r\n            }\r\n            else if (s[i] == &#39;1&#39;) {\r\n                va1 = 0; va2 = 0; va3 = 0;\r\n            }\r\n        }\r\n        else if (va3 == 1) {\r\n            if (s[i] == &#39;1&#39;) {\r\n                va1 = 0; va2 = 0; va3 = 0;\r\n            }\r\n            else {\r\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt;endl;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (va1 == 0 && va2 == 0 && va3 == 0) {\r\n        cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\r\n    }\r\n    else {\r\n        cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n    }\r\n    return;\r\n}\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int i = 0; i &lt; T; i++) {\r\n        string st;\r\n        cin &gt;&gt; st;\r\n        ve.push_back(st);\r\n    }\r\n    for (int i = 0; i &lt; T; i++) {\r\n        test(ve[i]);\r\n    }\r\n}','2020-04-05 16:22:46',169),(12151526,'BJ',2174,'#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;queue&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;math.h&gt;\r\nusing namespace std;\r\nint map[101][101];\r\nint N, M, A, B;\r\nint dy[4] = { 1,0,-1,0 };\r\nint dx[4] = { 0,1,0,-1 };\r\nstruct st {\r\n    int num;\r\n    int order;\r\n    int repeat;\r\n};\r\nstruct lo {\r\n    int x;\r\n    int y;\r\n    int d;\r\n};\r\nst com[101];\r\nlo robo[100];\r\nvoid L(int a, int b) {\r\n    for (int i = 0; i &lt; b; i++) {\r\n        robo[a].d = (robo[a].d + 3) % 4;\r\n    }\r\n}\r\nvoid R(int a, int b) {\r\n    for (int i = 0; i &lt; b; i++) {\r\n        robo[a].d = (robo[a].d + 1) % 4;\r\n    }\r\n}\r\nbool F(int a, int b) {\r\n    for (int i = 0; i &lt; b; i++) {\r\n        int x = robo[a].x + dx[robo[a].d];\r\n        int y = robo[a].y + dy[robo[a].d];\r\n        if (x == 0 || y == 0 || x &gt; A || y &gt; B) {\r\n            cout &lt;&lt; &quot;Robot &quot; &lt;&lt; a &lt;&lt; &quot; crashes into the wall&quot;;\r\n            return false;\r\n        }\r\n        else if (map[y][x] == 0) {\r\n            map[robo[a].y][robo[a].x] = 0;\r\n            robo[a].x = x; robo[a].y = y;\r\n            map[robo[a].y][robo[a].x] = a;\r\n\r\n        }\r\n        else if (map[y][x] != 0) {\r\n            cout &lt;&lt; &quot;Robot &quot; &lt;&lt; a &lt;&lt; &quot; crashes into robot &quot; &lt;&lt; map[y][x];\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nint main() {\r\n    cin &gt;&gt; A &gt;&gt; B;\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        char ch;\r\n        cin &gt;&gt; robo[i].x &gt;&gt; robo[i].y &gt;&gt; ch;\r\n        if (ch == &#39;N&#39;) robo[i].d = 0;\r\n        else if (ch == &#39;E&#39;) robo[i].d = 1;\r\n        else if (ch == &#39;S&#39;) robo[i].d = 2;\r\n        else if (ch == &#39;W&#39;) robo[i].d = 3;\r\n        map[robo[i].y][robo[i].x] = i;\r\n    }\r\n    for (int i = 0; i &lt; M; i++) {\r\n        char ch;\r\n        cin &gt;&gt; com[i].num &gt;&gt; ch &gt;&gt; com[i].repeat;\r\n        if (ch == &#39;L&#39;) com[i].order = 0;\r\n        else if (ch == &#39;R&#39;) com[i].order = 1;\r\n        else if (ch == &#39;F&#39;) com[i].order = 2;\r\n    }\r\n    for (int i = 0; i &lt; M; i++) {\r\n        if (com[i].order == 0) {\r\n            L(com[i].num, com[i].repeat);\r\n        }\r\n        else if (com[i].order == 1) {\r\n            R(com[i].num, com[i].repeat);\r\n        }\r\n        else if (com[i].order == 2) {\r\n            bool va = F(com[i].num, com[i].repeat);\r\n            if (va == false) return 0;\r\n        }\r\n    }\r\n    cout &lt;&lt; &quot;OK&quot;;\r\n    return 0;\r\n}','2020-04-02 18:57:16',170),(12151536,'BJ',1013,'#include &lt;iostream&gt;\r\n#include &lt;string.h&gt;\r\nusing namespace std;\r\n\r\nchar word[201];\r\nbool code[100110];\r\nint T;\r\n\r\nint main() {\r\n\r\n    cin &gt;&gt; T;\r\n    for (int t = 0; t &lt; T; t++) {\r\n        scanf(&quot;%s&quot;, word);\r\n        int n = strlen(word);\r\n        int count = 0;\r\n        int case1_count = 0; //100패턴 측정\r\n        int case2_count = 0; //100패턴 이후 1등장 체크\r\n        for (int i = 0; i &lt; n; i++) {\r\n            if (word[i] == &#39;0&#39; && count == 0 && case1_count == 0 && case2_count == 0) //처음꺼가 0\r\n                count++;\r\n            else if (word[i] == &#39;1&#39; && count == 0 && case1_count == 0 && case2_count == 0) //처음꺼가 1\r\n                case1_count++;\r\n            //====================================== //01이나 00 체크해주는 부분\r\n            else if (word[i] == &#39;1&#39; && count == 1)\r\n                count = 0;\r\n            else if (word[i] == &#39;0&#39; && count == 1) {\r\n                code[t] = false;\r\n                break;\r\n            }\r\n            //====================================== //100패턴 체크\r\n            else if (case1_count == 1 || case1_count == 2) {\r\n                if (word[i] == &#39;1&#39;) {\r\n                    code[t] = false;\r\n                    break;\r\n                }\r\n                else case1_count++;\r\n            }\r\n            else if (case1_count &gt; 2 && case2_count == 0) {\r\n                if (word[i] == &#39;1&#39;) {\r\n                    case1_count = 0;\r\n                    case2_count++;\r\n                }\r\n                else case1_count++;\r\n            }\r\n            if (case2_count != 0) { //100+ 이후 1등장 했을 때\r\n                if (word[i + 1] == &#39;0&#39;) { //그다음이 0이면 패턴끝\r\n                    case2_count = 0;\r\n                    case1_count = 0;\r\n                }\r\n                else if (word[i + 1] == &#39;1&#39; && word[i + 2] == &#39;0&#39; && word[i + 3] == &#39;0&#39;) { //그다음으로 100나오면 패턴끝\r\n                    case2_count = 0;\r\n                    case1_count = 0;\r\n                }\r\n            }\r\n            if (n &gt; 1 && i == n - 1)code[t] = true;\r\n            if (i == n - 1 && case1_count != 0)code[t] = false;\r\n        }\r\n    }\r\n    //출력\r\n    for (int i = 0; i &lt; T; i++) {\r\n        if (code[i] == true)printf(&quot;YESinha_univ&quot;);\r\n        else printf(&quot;NOinha_univ&quot;);\r\n    }\r\n\r\n}','2020-04-02 22:34:50',171),(12171820,'BJ',9251,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;istream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    string a;\r\n    string b;\r\n\r\n    getline(cin,a);\r\n    getline(cin, b);\r\n\r\n    int dp;\r\n    int answer = 0;\r\n    for (int z = 0; z &lt; a.size(); z++) // z번째 부터 시작하며 a의 마지막 문자에서 시작할때까지의 모든 연속하는 문자열 탐색\r\n    {\r\n        dp = 0;\r\n        for (int i = z; i &lt; a.size(); i++)//z번째 일때 다음 문자로 이동후 탐색\r\n        {\r\n            for (int j = i; j &lt; a.size(); j++)//문자를 이동해 보며 확인해보기\r\n            {\r\n                if (a[i] == b[j])\r\n                {\r\n                    dp++;\r\n                    break;\r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        answer = max(answer, dp);\r\n    }\r\n    cout &lt;&lt; answer;\r\n}','2020-04-02 23:35:52',172),(12171820,'BJ',1912,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int a[100001];\r\n    int N; // 입력받을 숫자의 개수\r\n    int sum = 0; // ~부터 ~까지의 합을 구할 예정\r\n    \r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; a[i];\r\n    }\r\n    int temp = a[0]; // 학 회차마다 들어갈 최대값\r\n    int answer = a[0]; // 정답\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = i; j &lt; N; j++)\r\n        {\r\n            sum += a[j];\r\n            \r\n            temp = max(temp, sum);\r\n            \r\n        }\r\n        sum = 0;\r\n        answer = max(answer, temp);\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n\r\n}','2020-04-02 23:36:45',173),(12151536,'BJ',1106,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\npair &lt;int, int&gt; ad[21];\r\nint dp[1001][1001];\r\n\r\nint main() {\r\n    int c, n;\r\n    cin &gt;&gt; c &gt;&gt; n;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        cin &gt;&gt; ad[i].second &gt;&gt; ad[i].first; //second : 가격, first : 명 수\r\n    }\r\n    sort(ad, ad + n + 1);\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= c; j++) {\r\n            dp[0][j] = 100000;\r\n            if (j%ad[i].first == 0) { //다 넣을 수 있음\r\n                dp[i][j] = min(dp[i - 1][j], j / ad[i].first * ad[i].second); //전에 꺼랑 다 넣을 떄\r\n                int a = (j - ad[i].first &gt; 0) ? j - ad[i].first : 0;\r\n                dp[i][j] = min(dp[i][j], dp[i][a] + ad[i].second); //다 넣지 않고 하나 넣고 나머지 딴걸로 채움\r\n            }\r\n            else { //다 못 넣음, 인원이 남는다\r\n                int a = (j - ad[i].first &gt; 0) ? j - ad[i].first : 0;\r\n                dp[i][j] = min((j / ad[i].first + 1) * ad[i].second, dp[i][a] + ad[i].second); //지금 껄로 다 넣을 때 vs 하나 넣고 나머지\r\n                dp[i][j] = min(dp[i][j], dp[i - 1][j]); //전에껄로 싹다 한거\r\n            }\r\n        }\r\n    }\r\n    printf(&quot;%d&quot;, dp[n][c]);\r\n}','2020-04-03 16:32:11',174),(12161746,'BJ',1912,'#include&lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n#define MAX 100001\r\n\r\nint N;\r\nint arr[MAX];\r\nint result = -10000;\r\nint before = 0;\r\n\r\nvoid Continue()\r\n{\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        before = before + arr[i];\r\n        result = max(result, before);\r\n\r\n        //뒤에 있는 수랑 비교\r\n        if (before &lt; 0)        before = 0;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; arr[i];\r\n    }\r\n    Continue();\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n}\r\n','2020-04-03 18:17:02',175),(12161777,'BJ',1912,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint sum[100001] = {};\r\nint arr[100001] = {};\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    //int max = 0; //비교를 위한 지표\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; arr[i];\r\n    }\r\n    sum[0] = arr[0];\r\n\r\n    for (int i = 1; i &lt; N; i++){\r\n        sum[i] = arr[i];\r\n        if (sum[i] &lt; sum[i - 1] + arr[i])\r\n        {\r\n            sum[i] = sum[i - 1] + arr[i];\r\n        }\r\n    }\r\n    int result = sum[0];\r\n    for (int i = 1; i &lt; N; i++) {\r\n        if (result &lt; sum[i]) { result = sum[i]; }\r\n    }\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-04-04 11:16:57',176),(12161777,'BJ',9251,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\nint dp[1001][1001];  // i까지의 string1, j까지의 string2\r\n\r\nint main()\r\n{\r\n    string s1, s2;\r\n    cin &gt;&gt; s1 &gt;&gt; s2;\r\n    \r\n    for (int i = 1; i &lt;= s1.size(); i++) {\r\n        for (int j = 1; j &lt;= s2.size(); j++) {\r\n            if (s1[i - 1] == s2[j - 1]) {        //비교 문자열 내용이 같다면\r\n                dp[i][j] = dp[i - 1][j - 1] + 1;\r\n            }\r\n            else{                                //비교 문자열이 내용이 다르다면\r\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[s1.size()][s2.size()] &lt;&lt; endl;\r\n    return 0;\r\n}','2020-04-04 16:03:15',177),(12161783,'BJ',2174,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\nint map[101][101];\r\nint A, B;\r\nint N, M;\r\nint cnt = 0;\r\nstruct ro {\r\n    int x, y, d;\r\n};\r\n\r\n\r\nro rob[101];\r\n\r\n//방향 동1 남2 서3 북4\r\nint turn(char mname, int dir) {\r\n    if (mname == &#39;L&#39;) {\r\n        if (dir == 1) {\r\n            return dir = 4;\r\n        }\r\n        else  return dir = dir - 1;\r\n    }\r\n\r\n    if (mname == &#39;R&#39;) {\r\n        if (dir == 4) {\r\n            return dir = 1;\r\n        }\r\n        else return dir = dir + 1;\r\n    }\r\n}\r\n//방향 동1 남2 서3 북4\r\nint dx[5] = { 0,1,0,-1,0 };\r\nint dy[5] = { 0,0,-1,0,1 };\r\n\r\n//방향 동1 남2 서3 북4\r\nint move(int robn, int mname, int mn) {\r\n\r\n    for (int i = 0; i &lt; mn; i++) {\r\n        int idx = rob[robn].x + dx[rob[robn].d];\r\n        int idy = rob[robn].y + dy[rob[robn].d];\r\n\r\n        if (idx &lt; 1 || idy&lt;1 || idx&gt;A || idy&gt;B) {\r\n            cout &lt;&lt; &quot;Robot &quot; &lt;&lt; robn &lt;&lt; &quot; crashes into the wall&quot; &lt;&lt; endl;\r\n            cnt = 1;\r\n            return 0;\r\n        }\r\n        else if (map[idx][idy] != 0) {\r\n            cout &lt;&lt; &quot;Robot &quot; &lt;&lt; robn &lt;&lt; &quot; crashes into robot &quot; &lt;&lt; map[idx][idy] &lt;&lt; endl;\r\n            cnt = 1;\r\n            return 0;\r\n        }\r\n        else {\r\n            map[rob[robn].x][rob[robn].y] = 0;\r\n            rob[robn].x = idx;\r\n            rob[robn].y = idy;\r\n            map[idx][idy] = robn;\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nint main() {\r\n\r\n    cin &gt;&gt; A &gt;&gt; B;\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n\r\n    char dir;\r\n\r\n\r\n    //방향 동1 남2 서3 북4\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; rob[i].x &gt;&gt; rob[i].y &gt;&gt; dir;\r\n        if (dir == &#39;E&#39;) rob[i].d = 1;\r\n        else if (dir == &#39;S&#39;) rob[i].d = 2;\r\n        else if (dir == &#39;W&#39;) rob[i].d = 3;\r\n        else if (dir == &#39;N&#39;) rob[i].d = 4;\r\n\r\n        map[rob[i].x][rob[i].y] = i;\r\n    }\r\n\r\n\r\n    int robn, mn;\r\n    char mname;\r\n\r\n    for (int k = 0; k &lt; M; k++) {\r\n        cin &gt;&gt; robn &gt;&gt; mname &gt;&gt; mn;\r\n\r\n        if (mname == &#39;F&#39;) {\r\n            move(robn, mname, mn);\r\n            if (cnt == 1)return 0;\r\n        }\r\n        else {\r\n            for (int j = 0; j &lt; mn; j++) {\r\n\r\n                rob[robn].d = turn(mname, rob[robn].d);\r\n            }\r\n\r\n        }\r\n    }\r\n    cout &lt;&lt; &quot;OK&quot;;\r\n    return 0;\r\n}','2020-04-04 16:21:36',178),(12161783,'BJ',9251,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n\r\nint dp[1001][1001];\r\n\r\nint main() {\r\n   string s1, s2;\r\n   \r\n   \r\n   cin &gt;&gt; s1 &gt;&gt; s2;\r\n\r\n\r\n   for (int i = 1; i &lt;= s1.size(); i++) {\r\n      for (int j = 1; j &lt;= s2.size(); j++) {\r\n         if (s1[i - 1] == s2[j - 1]) {\r\n            dp[i][j] += dp[i - 1][j - 1] + 1;\r\n         \r\n         }\r\n         else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\r\n      \r\n      }\r\n      \r\n   }\r\n\r\n   cout &lt;&lt; dp[s1.size()][s2.size()] ;\r\n   \r\n   return 0;\r\n}','2020-04-04 16:22:22',179),(12161783,'BJ',1912,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n\r\nint arr[100001];\r\nint dp[100001];\r\n\r\nint main() {\r\n   int n;\r\n   cin &gt;&gt; n;\r\n\r\n   \r\n\r\n   for (int i = 1; i &lt;= n; i++) {\r\n      cin &gt;&gt; arr[i];\r\n      \r\n      \r\n      if (i == 1) { dp[1]=arr[1]; }\r\n\r\n      else  {dp[i] = max(dp[i], dp[i - 1] + arr[i]);}\r\n   }\r\n\r\n   int ans = dp[0];\r\n   for (int i = 1; i &lt;= n; i++) {\r\n      if (ans &lt; dp[i]) {\r\n         ans = dp[i];\r\n      }\r\n   }\r\n\r\n   cout &lt;&lt; ans;\r\n   return 0;\r\n}','2020-04-04 16:22:46',180),(12181853,'BJ',2174,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define MAX 100\r\n\r\nstruct Info\r\n{\r\n    int x, y; // 로봇의 초기 위치의 x좌표, y좌표\r\n    int DIR;\r\n};\r\n\r\nInfo robot[MAX];\r\n\r\nstruct setting\r\n{\r\n    int num;\r\n    char Order;\r\n    int repeat;\r\n};\r\n\r\nsetting store[MAX];\r\n\r\nint A, B, N, M;\r\nint map[MAX][MAX];\r\n// 로봇의 처음 위치 map[x][y] = i로 로봇의 index, 즉 이동하는 로봇의 번호\r\n// 로봇이 이동을 하고 난 위치 map[nx][ny] = 이동하는 로봇의 인덱스 번호\r\n// 로봇이 이동을 하고 나면 처음 위치의 map[x][y]를 0으로 바꿔준다\r\nchar init_DIR;\r\nint x, y, nx, ny;\r\nint dir;\r\nint dx[] = { 0, 1, 0, -1 };\r\nint dy[] = { 1, 0, -1, 0 };\r\n\r\nvoid simulation()\r\n{\r\n    cin &gt;&gt; A &gt;&gt; B;\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; robot[i].y &gt;&gt; robot[i].x &gt;&gt; init_DIR;\r\n\r\n        robot[i].x = (B - robot[i].x);\r\n        robot[i].y = (robot[i].y - 1);\r\n\r\n        if (init_DIR == &#39;E&#39;) { robot[i].DIR = 0; }\r\n        else if (init_DIR == &#39;S&#39;) { robot[i].DIR = 1; }\r\n        else if (init_DIR == &#39;W&#39;) { robot[i].DIR = 2; }\r\n        else if (init_DIR == &#39;N&#39;) { robot[i].DIR = 3; }\r\n        map[robot[i].x][robot[i].y] = i;\r\n    }\r\n    for (int i = 1; i &lt;= M; i++) \r\n    {\r\n        cin &gt;&gt; store[i].num &gt;&gt; store[i].Order &gt;&gt; store[i].repeat;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    for (int i = 1; i &lt;= M; i++) {\r\n        int rep_num = store[i].repeat;\r\n\r\n        while (rep_num--) { // repeat횟수만큼 돌리기\r\n            if (store[i].Order == &#39;F&#39;) \r\n            { // 내려진 명령이 F일 경우 -&gt; 향하고 있는 방향을 기준으로 앞으로 한 칸 이동\r\n                x = robot[store[i].num].x;\r\n                y = robot[store[i].num].y;\r\n                dir = robot[store[i].num].DIR;\r\n                nx = x + dx[dir]; \r\n                ny = y + dy[dir];\r\n\r\n                if (nx &lt; 0 || ny &lt; 0 || nx &gt;= B || ny &gt;= A) \r\n                { // 이동한 로봇의 범위가 범위 밖으로 나가게 되면\r\n                    cout &lt;&lt; &quot;Robot &quot; &lt;&lt; store[i].num &lt;&lt; &quot; crashes into the wall&quot; &lt;&lt; endl; // 충돌 출력\r\n                    return;\r\n                }\r\n                else if (map[nx][ny] != 0) \r\n                { // 로봇이 이동한 후의 map[nx][ny]의 값이 0이 아닐 경우 -&gt; 즉, 로봇끼리 충돌하였을 경우\r\n                    cout &lt;&lt; &quot;Robot &quot; &lt;&lt; store[i].num &lt;&lt; &quot; crashes into robot &quot; &lt;&lt; map[nx][ny] &lt;&lt; endl;\r\n                    return;\r\n                }\r\n                else if (nx &gt;= 0 && ny &gt;= 0 && nx &lt; B && ny &lt; A) \r\n                { // 이동한 로봇의 범위가 범위 내에 존재한다면\r\n                    map[x][y] = 0; // 로봇의 현재 위치에서 map[x][y] = 0으로 설정\r\n                    robot[store[i].num].x = nx; // 이동하는 로봇 store[i].num번째의 로봇의 이동한 위치 nx\r\n                    robot[store[i].num].y = ny; // 이동하는 로봇 store[i].num번째의 로봇의 이동한 위치 ny\r\n                    map[nx][ny] = store[i].num; // 로봇의 이동한 후 도착한 위치에서 map[nx][ny] = 이동한 로봇의 번호\r\n                }\r\n            }\r\n            else if (store[i].Order == &#39;L&#39;) \r\n            {\r\n                dir = robot[store[i].num].DIR;\r\n                robot[store[i].num].DIR = (dir + 3) % 4;\r\n            }\r\n            else if (store[i].Order == &#39;R&#39;) \r\n            {\r\n                dir = robot[store[i].num].DIR;\r\n                robot[store[i].num].DIR = (dir + 1) % 4;\r\n            }\r\n        }    \r\n    }\r\n    cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;\r\n}\r\n\r\nint main()\r\n{\r\n    simulation();\r\n    solve();\r\n    return 0;\r\n}','2020-04-04 17:15:19',181),(12181853,'BJ',1912,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int n, sum, ans;\r\n    cin &gt;&gt; n;\r\n    int num[100000];\r\n    for (int i = 0; i &lt; n; i++) {\r\n        cin &gt;&gt; num[i];\r\n    }\r\n    sum = 0, ans = -1000;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        sum += num[i];\r\n        ans = sum &gt; ans ? sum : ans;\r\n        if (sum &lt; 0)\r\n            sum = 0;\r\n    }\r\n    cout &lt;&lt; ans;\r\n}\r\n','2020-04-04 17:11:15',182),(12181751,'BJ',2174,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nconst int baek = 101;\r\nvector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; robot_location[baek];//처음 로보트의 좌표와 방향\r\nvector&lt;pair&lt;char,int&gt;&gt; robot_order[baek];//주문과 숫자를 저장\r\nint dx[4] = { 1,0,-1,0 };\r\nint dy[4] = { 0,1,0,-1 };\r\nint A, B;\r\nint N, M;\r\n\r\nint direction(char d)\r\n{\r\n    int dir;\r\n    if (d == &#39;N&#39;)\r\n        dir = 0;\r\n    else if (d == &#39;E&#39;)\r\n        dir = 1;\r\n    else if (d == &#39;S&#39;)\r\n        dir = 2;\r\n    else if (d == &#39;W&#39;)\r\n        dir = 3;\r\n    return dir;\r\n}\r\n\r\nint robot(int num,int start,int end)\r\n{\r\n    for (int i = start; i &lt; end-1; i++)\r\n    {\r\n        if (robot_order[num].at(i).first == &#39;L&#39;)\r\n        {\r\n            robot_location[num].back().second -= robot_order[num].at(i).second;\r\n            if (robot_location[num].back().second &lt; 0)\r\n            {\r\n                robot_location[num].back().second *= -1;\r\n                robot_location[num].back().second %= 4;\r\n                if (robot_location[num].back().second == 1)\r\n                    robot_location[num].back().second = 3;\r\n                else if (robot_location[num].back().second == 3)\r\n                    robot_location[num].back().second = 1;\r\n            }\r\n        }\r\n        else if (robot_order[num].at(i).first == &#39;R&#39;)\r\n        {\r\n            robot_location[num].back().second += robot_order[num].at(i).second;\r\n            robot_location[num].back().second %= 4;\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; robot_order[num].at(end-1).second; i++)\r\n    {\r\n        int nx = robot_location[num].back().first.first + dx[robot_location[num].back().second];\r\n        int ny = robot_location[num].back().first.second + dy[robot_location[num].back().second];\r\n        if (nx &gt;= A || ny &gt;= B || nx &lt; 0 || ny &lt; 0)\r\n            return 1;\r\n        for (int j = 1; j &lt; num; j++)\r\n        {\r\n            if ((nx == robot_location[j].back().first.first) && (ny == robot_location[j].back().first.second))\r\n                return 2*j;\r\n        }\r\n        robot_location[num].back().first.first = nx;\r\n        robot_location[num].back().first.second = ny;\r\n    }\r\n    return 0;\r\n}\r\nint main()\r\n{\r\n    scanf(&quot;%d %d&quot;, &A, &B);\r\n    scanf(&quot;%d %d&quot;, &N, &M);\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        int x, y;\r\n        char d;\r\n        scanf(&quot;%d %d %c&quot;, &x, &y, &d);\r\n        robot_location[i].push_back({ { x,y }, direction(d) });\r\n    }\r\n    int check=0;\r\n    for (int i = 0; i &lt; M; i++)\r\n    {\r\n        int num, cnt;\r\n        char order;\r\n        scanf(&quot;%d %c %d&quot;, &num, &order, &cnt);//로봇순서 주문이름 횟수\r\n        robot_order[num].push_back({ order,cnt });\r\n    }\r\n    int start = 0;\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= robot_order[i].size(); j++)\r\n        {\r\n            char order = robot_order[i].back().first;\r\n            if (order == &#39;F&#39;)\r\n            {\r\n                check = robot(i,start,j);\r\n                if (check != 0)\r\n                {\r\n                    if (check == 1)\r\n                        cout &lt;&lt; &quot;Robot &quot;&lt;&lt;i&lt;&lt;&quot; crashes into the wall&quot; &lt;&lt; endl;\r\n                    else if (check != 1 || check != 0)\r\n                        cout &lt;&lt; &quot;Robot&quot;&lt;&lt; i &lt;&lt;&quot; crashes into robot &quot;&lt;&lt;check/2 &lt;&lt; endl;\r\n                    return 0;\r\n                }\r\n                start = j;\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;\r\n}','2020-04-04 17:19:36',183),(12161783,'BJ',2174,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\nint map[100][100];\r\nint A, B;\r\nint N, M;\r\nint cnt = 0;\r\n\r\nstruct ro {\r\n    int x, y, d;\r\n};\r\n\r\nro rob[101];\r\n\r\n//방향 동1 남2 서3 북4\r\nint turn(char mname, int dir) {\r\n    if (mname == &#39;L&#39;) {\r\n        if (dir == 1) {\r\n            return dir = 4;\r\n        }\r\n        else  return dir = dir - 1;\r\n    }\r\n\r\n    if (mname == &#39;R&#39;) {\r\n        if (dir == 4) {\r\n            return dir = 1;\r\n        }\r\n        else return dir = dir + 1;\r\n    }\r\n}\r\n//방향 동1 남2 서3 북4\r\nint dx[5] = { 0,1,0,-1,0 };\r\nint dy[5] = { 0,0,-1,0,1 };\r\n\r\n//방향 동1 남2 서3 북4\r\nvoid move(int robn, int mname, int mn) {\r\n\r\n    for (int i = 0; i &lt; mn; i++) {\r\n        int idx = rob[robn].x + dx[rob[robn].d];\r\n        int idy = rob[robn].y + dy[rob[robn].d];\r\n\r\n        if (idx &lt; 1 || idy&lt;1 || idx&gt;A || idy&gt;B) {\r\n            cout &lt;&lt; &quot;Robot &quot; &lt;&lt; robn &lt;&lt; &quot; crashes into the wall&quot; &lt;&lt; endl;\r\n            return;\r\n        }\r\n        else if (map[idx][idy] != 0) {\r\n            cout &lt;&lt; &quot;Robot &quot; &lt;&lt; robn &lt;&lt; &quot; crashes into robot &quot; &lt;&lt; map[idx][idy] &lt;&lt; endl;\r\n            return;\r\n        }\r\n        else {\r\n            map[rob[robn].x][rob[robn].y] = 0;\r\n            rob[robn].x = idx;\r\n            rob[robn].y = idy;\r\n            map[idx][idy] = robn;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nint main() {\r\n\r\n    cin &gt;&gt; A &gt;&gt; B;\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n\r\n    char dir;\r\n\r\n\r\n    //방향 동1 남2 서3 북4\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; rob[i].x &gt;&gt; rob[i].y &gt;&gt; dir;\r\n        if (dir == &#39;E&#39;) rob[i].d = 1;\r\n        else if (dir == &#39;S&#39;) rob[i].d = 2;\r\n        else if (dir == &#39;W&#39;) rob[i].d = 3;\r\n        else if (dir == &#39;N&#39;) rob[i].d = 4;\r\n\r\n        map[rob[i].x][rob[i].y] = i;\r\n    }\r\n\r\n\r\n    int robn, mn;\r\n    char mname;\r\n\r\n    for (int k = 0; k &lt; M; k++) {\r\n        cin &gt;&gt; robn &gt;&gt; mname &gt;&gt; mn;\r\n\r\n        if (mname == &#39;F&#39;)\r\n        {\r\n            for (int i = 0; i &lt; mn; i++) {\r\n                int idx = rob[robn].x + dx[rob[robn].d];\r\n                int idy = rob[robn].y + dy[rob[robn].d];\r\n\r\n                if (idx &lt; 1 || idy&lt;1 || idx&gt;A || idy&gt;B) {\r\n                    cout &lt;&lt; &quot;Robot &quot; &lt;&lt; robn &lt;&lt; &quot; crashes into the wall&quot; &lt;&lt; endl;\r\n                    for(int jj=k+1;jj&lt;M;jj++)\r\n                        cin &gt;&gt; robn &gt;&gt; mname &gt;&gt; mn;\r\n                    return 0;\r\n                }\r\n                else if (map[idx][idy] != 0) {\r\n                    cout &lt;&lt; &quot;Robot &quot; &lt;&lt; robn &lt;&lt; &quot; crashes into robot &quot; &lt;&lt; map[idx][idy] &lt;&lt; endl;\r\n                    for (int jj = k + 1; jj &lt; M; jj++)\r\n                        cin &gt;&gt; robn &gt;&gt; mname &gt;&gt; mn;\r\n                    return 0;\r\n                }\r\n                else {\r\n                    map[rob[robn].x][rob[robn].y] = 0;\r\n                    rob[robn].x = idx;\r\n                    rob[robn].y = idy;\r\n                    map[idx][idy] = robn;\r\n                }\r\n\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (int j = 0; j &lt; mn; j++) {\r\n\r\n                rob[robn].d = turn(mname, rob[robn].d);\r\n            }\r\n\r\n        }\r\n    }\r\n    cout &lt;&lt; &quot;OK&quot;;\r\n    return 0;\r\n}','2020-04-04 17:53:53',184),(12151551,'BJ',14500,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint arr[501][501] = { 0 };\r\nbool map[501][501] = { 0 };\r\nint result[5] = { 0 };\r\nint N, M;\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,-1,0,1 };\r\nint re = 0;\r\n\r\nbool check(int i, int j) {\r\n    return (i &lt; N&& i &gt;= 0 && j &lt; M&& j &gt;= 0);\r\n}\r\n\r\nvoid find(int index, int score, int i, int j) {\r\n    int nx, ny = 0;\r\n    if (index == 4) {\r\n        re = max(re,score);\r\n    }\r\n    else {\r\n        for (int k = 0; k &lt; 4; k++) {\r\n            nx = i + dx[k];\r\n            ny = j + dy[k];\r\n            if (check(nx, ny) && !map[nx][ny]) {\r\n                map[nx][ny] = true;\r\n                find(index + 1, score + arr[nx][ny], nx, ny);\r\n                map[nx][ny] = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid chi(int i, int j, int score) {\r\n    if (map[i - 1][j]) {\r\n        if (check(i, j + 1) && check(i + 1, j)) find(4, score + arr[i][j + 1] + arr[i + 1][j], i, j);\r\n        if (check(i, j - 1) && check(i + 1, j)) find(4, score + arr[i][j - 1] + arr[i + 1][j], i, j);\r\n    }\r\n    if (map[i][j - 1]) {\r\n        if (check(i, j + 1) && check(i + 1, j)) find(4, score + arr[i][j + 1] + arr[i + 1][j], i, j);\r\n        if (check(i, j + 1) && check(i - 1, j)) find(4, score + arr[i][j + 1] + arr[i - 1][j], i, j);\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) cin &gt;&gt; arr[i][j];\r\n    }\r\n\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            map[i][j] = true;\r\n            for (int k = 0; k &lt; 4; k++) {\r\n                int nx = i + dx[k];\r\n                int ny = j + dy[k];\r\n                if (check(nx, ny)) {\r\n                    map[nx][ny] = true;\r\n                    find(2, arr[i][j] + arr[nx][ny], nx, ny);\r\n                    chi(nx, ny, arr[i][j] + arr[nx][ny]);\r\n                    map[nx][ny] = false;\r\n                }\r\n            }\r\n            map[i][j] = false;\r\n        }\r\n    }\r\n    cout &lt;&lt; re &lt;&lt; endl;\r\n\r\n}','2020-04-06 02:44:09',187),(12151551,'BJ',1013,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nvector&lt;string&gt; v;\r\nint T;\r\n\r\nbool test(string input) {\r\n    int group1 = 0;\r\n    int group2 = 0;\r\n    int group1_2 = 0;\r\n    int group1_3 = 0;\r\n    int success = 0;\r\n    for (int i = 1; i &lt; input.size(); i++) {\r\n        if (group1 == 0 && group2 == 0) {\r\n            if (input[i - 1] == &#39;1&#39; && input[i] == &#39;0&#39;) {\r\n                group1 = 1;\r\n                success = 0;\r\n            }\r\n            else if (input[i - 1] == &#39;0&#39; && input[i] == &#39;1&#39;) {\r\n                group2 = 1;\r\n                success = 1;\r\n            }\r\n            else return false;\r\n        }\r\n        else if (group1 == 1 && group1_2 == 0 && group1_3 == 0) {\r\n            if (input[i] == &#39;1&#39;) return false;\r\n            if (i == input.size() - 1) return false;\r\n            group1_2 = 1;\r\n            success = 0;\r\n        }\r\n        else if (group1 == 1 && group1_2 == 1 && group1_3 == 0) {\r\n            if (input[i] == &#39;1&#39;) {\r\n                group1_3 = 1;\r\n                success = 1;\r\n            }\r\n            else {\r\n                if (i == input.size() - 1) return false;\r\n            }\r\n        }\r\n        else if (group1 == 1 && group1_2 == 1 && group1_3 &gt;= 1) {\r\n            if (input[i] == &#39;1&#39;) group1_3++;\r\n            else if (input[i] == &#39;0&#39; && group1_3 &gt; 1) {\r\n                if (input[i + 1] == &#39;1&#39;) {\r\n                    group1_3 = 0;\r\n                    group1 = 0;\r\n                    group1_2 = 0;\r\n                    success = 1;\r\n                }\r\n                else {\r\n                    group1_3 = 0;\r\n                    group1 = 1;\r\n                    group1_2 = 0;\r\n                    success = 0;\r\n                }\r\n            }\r\n            else if (input[i] == &#39;0&#39; && group1_3 == 1) {\r\n                group1_3 = 0;\r\n                group1 = 0;\r\n                group1_2 = 0;\r\n                success = 0;\r\n            }\r\n        }\r\n        else if (group2 == 1) {\r\n            if (i == input.size() - 1) return false;\r\n            group2 = 0;\r\n        }\r\n    }\r\n    if (success == 1)return true;\r\n    else return false;\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; T;\r\n    for (int i = 0; i &lt; T; i++) {\r\n        string input;\r\n        cin &gt;&gt; input;\r\n        v.push_back(input);\r\n    }\r\n    for (int i = 0; i &lt; T; i++) {\r\n        bool result = test(v[i]);\r\n        if (result == false) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\r\n        else if (result == true) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\r\n    }\r\n}\r\n','2020-04-06 17:32:05',188),(12151536,'BJ',14500,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint n, m;\r\nint map[501][501];\r\nint y[4] = { 0,0,1,-1 };\r\nint x[4] = { 1,-1,0,0 };\r\nint ans[501][501];\r\npair&lt;int, int&gt; step[5];\r\npair&lt;int, int&gt; step1[5];\r\nint max_ans;\r\n\r\nint cal_step() {\r\n    int value = 0;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        value += map[step[i].first][step[i].second];\r\n    }\r\n    return value;\r\n}\r\n\r\nint cal_step1() {\r\n    int value = 0;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        value += map[step1[i].first][step1[i].second];\r\n    }\r\n    return value;\r\n}\r\n\r\nvoid dfs(int col, int row, int cnt) {\r\n    if (cnt &gt; 3) {\r\n        max_ans = max(max_ans, cal_step());\r\n        return;\r\n    }\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        int new_y = col + y[i];\r\n        int new_x = row + x[i];\r\n        if (new_y &gt;= 0 && new_y &lt;= n && new_x &gt;= 0 && new_x &lt;= m) { //범위를 안벗어나고\r\n            if (new_y == step[cnt - 2].first && new_x == step[cnt - 2].second) continue; //이전에 선택한것이 아닌\r\n            step[cnt].first = new_y;\r\n            step[cnt].second = new_x;\r\n            dfs(new_y, new_x, cnt + 1); //다음값 선택\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid special(int col, int row) {\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        int new_y = col + y[i];\r\n        int new_x = row + x[i]; //세번째 블락\r\n        if (new_y &gt;= 0 && new_y &lt;= n && new_x &gt;= 0 && new_x &lt;= m) { //범위를 안벗어나고\r\n            if (new_y == step1[0].first && new_x == step1[0].second) continue;\r\n            step1[2].first = new_y;\r\n            step1[2].second = new_x;\r\n            for (int j = 0; j &lt; 4; j++) {\r\n                new_y = col + y[j];\r\n                new_x = row + x[j];\r\n                if (new_y &gt;= 0 && new_y &lt;= n && new_x &gt;= 0 && new_x &lt;= m) {\r\n                    if (new_y == step1[0].first && new_x == step1[0].second)continue;\r\n                    if (new_y == step1[2].first && new_x == step1[2].second)continue;\r\n                    step1[3].first = new_y;\r\n                    step1[3].second = new_x;\r\n                    max_ans = max(max_ans, cal_step1());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int temp_y;\r\n    int temp_x;\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= m; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n        }\r\n    }\r\n\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= m; j++) {\r\n            //ans[i][j] = map[i][j]; //현재값 더함\r\n            step[0].first = i; //y좌표\r\n            step[0].second = j; //x좌표\r\n            step1[0].first = i; //y좌표\r\n            step1[0].second = j; //x좌표\r\n            dfs(i, j, 1);\r\n            int idx = 0;\r\n            int next = map[i][j];\r\n            for (int k = 0; k &lt; 4; k++) { //두번째 블락까지고름\r\n                int new_y = i + y[k];\r\n                int new_x = j + x[k];\r\n                step1[1].first = new_y;\r\n                step1[1].second = new_x;\r\n                special(new_y,new_x);\r\n            }\r\n        }\r\n    }\r\n    printf(&quot;%d&quot;, max_ans);\r\n}','2020-04-06 16:49:10',189),(12151616,'BJ',1495,'#include&lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nbool dp[101][1001];\r\nint N, S, M, vol;\r\nusing namespace std;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; S &gt;&gt; M;\r\n    dp[0][S] = true;\r\n    int ans = S;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        cin &gt;&gt; vol;\r\n        for (int j = 0; j &lt;= M; j++) {\r\n            if (dp[i - 1][j]) {\r\n                if (j + vol &lt;= M) dp[i][j + vol] = true;\r\n                if (j - vol &gt;= 0) dp[i][j - vol] = true;\r\n            }\r\n        }\r\n    }\r\n    for (int i = M; i &gt;=0; i--) {\r\n        if (dp[N][i]) {\r\n            cout &lt;&lt; i;\r\n            return 0;\r\n        }\r\n    }\r\n    cout &lt;&lt; -1;\r\n    return 0;\r\n}','2020-04-06 17:31:44',190),(12151536,'BJ',1660,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n#define MAX 300001\r\n\r\nint n, m;\r\nvector &lt;int&gt; p(1);\r\nint dp[MAX];\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; n;\r\n    int value = 0;\r\n    int val = 0;\r\n    int idx = 1;\r\n    while (true) {\r\n        value += idx;\r\n        val += value;\r\n        if (val &gt; n)break;\r\n        p.push_back(val);\r\n        idx++;\r\n    }\r\n    for (int i = 1; i &lt;= p.size() - 1; i++) {//p.size() - 1\r\n        for (int j = 1; j &lt;= n; j++) {\r\n            if (i == 1) {\r\n                dp[j] = j;\r\n            }\r\n            else {\r\n                if (p[i] &lt;= j) { //p\r\n                    dp[j] = min(dp[j], j / p[i] + dp[j - j / p[i] * p[i]]); //p\r\n                    dp[j] = min(dp[j], dp[j - p[i]] + 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[n]; //p.size() - 1\r\n}','2020-04-07 23:47:11',191),(12151551,'BJ',1660,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint square[300001] = { 0 };\r\nint dp[300001] = { 0 };\r\nvector&lt;int&gt; v;\r\n\r\nint main() {\r\n    int start = 1;\r\n    square[start] = 1;\r\n    for (int i = 2; i &lt;= 300000; i++) {\r\n        if (start + i &gt; 300000) break;\r\n        square[start + i] = 1;\r\n        start = start + i;\r\n    }\r\n\r\n    for (int i = 1; i &lt;= 300000; i++) dp[i] = 999999;\r\n\r\n    start = 1;\r\n    dp[start] = 1;\r\n    v.push_back(start);\r\n    for (int i = 2; i &lt;= 300000; i++) {\r\n        if (square[i] == 1 && start + i &lt;= 300001) {\r\n            dp[start + i] = 1;\r\n            start = start + i;\r\n            v.push_back(start);\r\n        }\r\n    }\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; v.size(); i++) {\r\n        for (int j = v[i]; j &lt;= N; j++) {\r\n            dp[j] = min(dp[j], 1 + dp[j - v[i]]);\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[N] &lt;&lt; endl;\r\n\r\n}','2020-04-09 01:48:09',192),(12171820,'BJ',1309,'#include &lt;iostream&gt;\r\n\r\n\r\nusing namespace std;\r\n\r\nint x[100001];\r\nint a1[100001];\r\nint a2[100001]; //  int main함수 내에서는 메모리 초과로 전역변수로 설정해야 함\r\n\r\nint main()\r\n{\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n\r\n    x[1] = 1;\r\n    a1[1] = 1;\r\n    a2[1] = 1;\r\n\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        x[i] = (x[i - 1] + a1[i - 1] + a2[i - 1])%9901;\r\n        a1[i] = (x[i - 1] + a2[i - 1])%9901;\r\n        a2[i] = (x[i - 1] + a1[i - 1])%9901;\r\n    }\r\n\r\n    cout &lt;&lt; (x[N] + a1[N] + a2[N]) % 9901 &lt;&lt; endl;\r\n}','2020-04-09 21:15:16',193),(12151551,'BJ',1301,'#include&lt;bits/stdc++.h&gt;\r\nusing namespace std;\r\n\r\nint beez[7]= { 0 };\r\nint N;\r\nlong long cache[11][11][11][11][11][7][7];\r\n\r\nlong long find(int first, int second, int third, int fourth, int fifth, int be, int bbe) {\r\n    if (first == 0 && second == 0 && third == 0 && fourth == 0 && fifth == 0) return 1;\r\n    if (first &lt; 0 || second &lt; 0 || third &lt; 0 || fourth &lt; 0 || fifth &lt; 0) return 0;\r\n    long long &result = cache[first][second][third][fourth][fifth][be][bbe];\r\n    if (result != -1) return result;\r\n    result = 0;\r\n    if (first &gt;= 1 && be != 1 && bbe != 1) result = find(first - 1, second, third, fourth, fifth, 1, be);\r\n    if (second &gt;= 1 && be != 2 && bbe != 2) result += find(first, second-1, third, fourth, fifth, 2, be);\r\n    if (third &gt;= 1 && be != 3 && bbe != 3) result += find(first, second, third-1, fourth, fifth, 3, be);\r\n    if (fourth &gt;= 1 && be != 4 && bbe != 4) result += find(first, second, third, fourth-1, fifth, 4, be);\r\n    if (fifth &gt;= 1 && be != 5 && bbe != 5) result += find(first, second, third, fourth, fifth-1,5, be);\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    memset(cache, -1, sizeof(cache));\r\n    scanf(&quot;%d&quot;,&N);\r\n    for (int i = 1; i &lt;= N; i++) scanf(&quot;%d&quot;, &beez[i]);\r\n    printf(&quot;%lldinha_univ&quot;, find(beez[1], beez[2], beez[3], beez[4], beez[5], -1, -1));\r\n    return 0;\r\n\r\n}\r\n\r\n// 스스로 못풀겠어서 좀 참고했는데 아직도 잘 몰것음','2020-04-11 17:19:30',194),(12151526,'BJ',1660,'#include&lt;iostream&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;vector&gt;\r\nusing namespace std;\r\nint N;\r\nint dp[121];\r\nint dp2[121];\r\nint mid = 120;\r\nint d[300001];\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    dp[1] = 1;\r\n    dp2[1] = 1;\r\n    for (int i = 2; i &lt;= 120; i++) {\r\n        dp[i] = dp[i - 1] + i;\r\n        dp2[i] = dp2[i - 1] + dp[i];\r\n    }\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        d[i] = 99999;\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 1; j &lt;= 120; j++) {\r\n            if (i + dp2[j] &lt;= N) {\r\n                d[i + dp2[j]] = min(d[i] + 1, d[i + dp2[j]]);\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; d[N];\r\n}','2020-04-13 14:18:40',195),(12151526,'BJ',15684,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint map[31][11];\r\nint map2[31][11];\r\nint N, H, M;\r\nint res;\r\nbool cha = false;\r\nstruct st {\r\n    int a;\r\n    int b;\r\n};\r\nvector&lt;st&gt; ve;\r\nbool test() {\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        int va = i;\r\n        for (int j = 1; j &lt;= H; j++) {\r\n            if (map2[j][va] != 0) {\r\n                va = map2[j][va];\r\n            }\r\n        }\r\n        if (va != i) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nvoid ladder1() {\r\n    for (int i = 0; i &lt; ve.size(); i++) {\r\n        map2[ve[i].a][ve[i].b] = ve[i].b + 1;\r\n        map2[ve[i].a][ve[i].b + 1] = ve[i].b;\r\n        cha = test();\r\n        if (cha == true) {\r\n            res = 1;\r\n            return;\r\n        }\r\n        map2[ve[i].a][ve[i].b] = 0;\r\n        map2[ve[i].a][ve[i].b + 1] = 0;\r\n    }\r\n}\r\nvoid ladder2() {\r\n    for (int i = 0; i &lt; ve.size(); i++) {\r\n        map2[ve[i].a][ve[i].b] = ve[i].b + 1;\r\n        map2[ve[i].a][ve[i].b + 1] = ve[i].b;\r\n        for (int j = i + 1; j &lt; ve.size(); j++) {\r\n            if (map2[ve[j].a][ve[j].b] == 0 && map2[ve[j].a][ve[j].b + 1] == 0) {\r\n                map2[ve[j].a][ve[j].b] = ve[j].b + 1;\r\n                map2[ve[j].a][ve[j].b + 1] = ve[j].b;\r\n                cha = test();\r\n                if (cha == true) {\r\n                    res = 2;\r\n                    return;\r\n                }\r\n                map2[ve[j].a][ve[j].b] = 0;\r\n                map2[ve[j].a][ve[j].b + 1] = 0;\r\n            }\r\n        }\r\n        map2[ve[i].a][ve[i].b] = 0;\r\n        map2[ve[i].a][ve[i].b + 1] = 0;\r\n    }\r\n}\r\nvoid ladder3() {\r\n    for (int i = 0; i &lt; ve.size(); i++) {\r\n        map2[ve[i].a][ve[i].b] = ve[i].b + 1;\r\n        map2[ve[i].a][ve[i].b + 1] = ve[i].b;\r\n        for (int j = i + 1; j &lt; ve.size(); j++) {\r\n            if (map2[ve[j].a][ve[j].b] == 0 && map2[ve[j].a][ve[j].b + 1] == 0) {\r\n                map2[ve[j].a][ve[j].b] = ve[j].b + 1;\r\n                map2[ve[j].a][ve[j].b + 1] = ve[j].b;\r\n                for (int k = j + 1; k &lt; ve.size(); k++) {\r\n                    if (map2[ve[k].a][ve[k].b] == 0 && map2[ve[k].a][ve[k].b + 1] == 0) {\r\n                        map2[ve[k].a][ve[k].b] = ve[k].b + 1;\r\n                        map2[ve[k].a][ve[k].b + 1] = ve[k].b;\r\n                        cha = test();\r\n                        if (cha == true) {\r\n                            res = 3;\r\n                            return;\r\n                        }\r\n                        map2[ve[k].a][ve[k].b] = 0;\r\n                        map2[ve[k].a][ve[k].b + 1] = 0;\r\n                    }\r\n                }\r\n                map2[ve[j].a][ve[j].b] = 0;\r\n                map2[ve[j].a][ve[j].b + 1] = 0;\r\n            }\r\n        }\r\n        map2[ve[i].a][ve[i].b] = 0;\r\n        map2[ve[i].a][ve[i].b + 1] = 0;\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; H;\r\n    for (int i = 0; i &lt; M; i++) {\r\n        int a, b;\r\n        cin &gt;&gt; a &gt;&gt; b;\r\n        map[a][b] = b + 1;\r\n        map[a][b + 1] = b;\r\n        map2[a][b] = map[a][b];\r\n        map2[a][b + 1] = map[a][b + 1];\r\n    }\r\n    for (int i = 1; i &lt;= H; i++) {\r\n        for (int j = 1; j &lt; N; j++) {\r\n            if (map[i][j] == 0 && map[i][j + 1] == 0) {\r\n                ve.push_back({ i,j });\r\n            }\r\n        }\r\n    }\r\n    cha = test();\r\n    if (cha == false)ladder1();\r\n    if (cha == false)ladder2();\r\n    if (cha == false)ladder3();\r\n    if (cha == false) {\r\n        cout &lt;&lt; -1;\r\n    }\r\n    else {\r\n        cout &lt;&lt; res;\r\n    }\r\n}','2020-04-13 15:19:26',196),(12161783,'BJ',1309,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint dp[100001][3] = { 0 }; // 이전기준 0 빈거,1왼쪽,2오른쪽\r\n//성인이 코드 봤는데 전역변수 초과..\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n\r\n    dp[1][0] = 1;// 우리안에 없어도 1가지 경우이기때문에 1로초기화\r\n    dp[1][1] = 1;\r\n    dp[1][2] = 1;\r\n    \r\n    for (int i = 2; i &lt;= N; i++) {\r\n        dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2])%9901;\r\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2])%9901;\r\n        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1])%9901;\r\n        \r\n    }\r\n\r\n    cout &lt;&lt; (dp[N][0] + dp[N][1] + dp[N][2])%9901 &lt;&lt; endl;\r\n    \r\n}','2020-04-13 20:18:51',197),(12181751,'BJ',1535,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nstruct ppair\r\n{\r\n    int a, b;\r\n};\r\nint N;\r\nppair get_loss[21];\r\nint answer[101] = { 0 };\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    \r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        int c;\r\n        scanf(&quot;%d&quot;,&c);\r\n        get_loss[i].a = c;\r\n    }\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        int c;\r\n        scanf(&quot;%d&quot;,&c );\r\n        get_loss[i].b = c;\r\n    }\r\n    \r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int k = 99; k &gt;= 0; k--)\r\n        {\r\n            if (get_loss[i].a + k &lt; 100)\r\n                answer[get_loss[i].a + k] = max(answer[get_loss[i].a + k], get_loss[i].b + answer[k]);    \r\n        }\r\n    }\r\n    \r\n    cout &lt;&lt; answer[99] &lt;&lt; endl;\r\n}','2020-04-13 21:44:40',198),(12181751,'BJ',1309,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint answer[100001] = { 0 };\r\nint Zero[100001] = { 0 };\r\nint Left[100001] = { 0 };\r\nint Right[100001] = { 0 };\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    Zero[1] = 1; Left[1] = 1; Right[1] = 1;\r\n    answer[1] = 3;\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        Zero[i] = (Zero[i - 1] + Left[i - 1] + Right[i - 1])%9901;\r\n        //cout &lt;&lt; Zero[i] &lt;&lt; &quot; &quot;;\r\n        Left[i] = (Zero[i - 1] + Right[i - 1]) % 9901;\r\n        //cout &lt;&lt; Left[i] &lt;&lt; &quot; &quot;;\r\n        Right[i] = (Zero[i - 1] + Left[i - 1]) % 9901;\r\n        //cout &lt;&lt; Right[i] &lt;&lt; &quot; &quot;;\r\n        answer[i] = ((Zero[i] + Left[i] + Right[i])) % 9901;\r\n        //cout &lt;&lt; endl;\r\n    }\r\n    cout &lt;&lt; answer[N] &lt;&lt; endl;\r\n}','2020-04-13 22:33:48',199),(12161777,'BJ',1535,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint N;\r\nint L[21];\r\nint J[21];\r\nint dp[21][101];\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++) {cin &gt;&gt; L[i];}\r\n    for (int i = 1; i &lt;= N; i++) {cin &gt;&gt; J[i];}\r\n    \r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int l = 1; l &lt; 100; l++) {\r\n            dp[i][l] = dp[i - 1][l]; // 첫행렬은 dp는 0으로 초기화 이후의 dp현재값은 전사람의 dp값으로 받음  \r\n            if (L[i] &lt;= l && dp[i - 1][l - L[i]] + J[i] &gt; dp[i][l]) { // i번째 체력깎이는게 라이프보다 작고,얻는 기쁨의 가치가 dp보다 크다면\r\n                dp[i][l] = dp[i - 1][l-L[i]] + J[i]; // 새로운 dp값으로 update (이때의 값은 최대 joy값)\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[N][99] &lt;&lt; endl;  // 2차원 배열 중 마지막값인 결과값 출력 \r\n    return 0;\r\n}\r\n','2020-04-14 17:43:42',200),(12161777,'BJ',1309,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nconst int mod = 9901;\r\n\r\nint N;\r\nint dp[100001][4]; // [사자를 배치하는 경우의수][배치 방식] &gt; 배치를 하냐? 왼쪽? 오른쪽?\r\n            \r\nint main() {\r\n    cin &gt;&gt; N;\r\n\r\n    dp[1][1] = 1; //배치 안함\r\n    dp[1][2] = 1; // 왼쪽\r\n    dp[1][3] = 1; // 오른쪽\r\n\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        dp[i][1] = dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3];\r\n        dp[i][2] = dp[i - 1][1] + dp[i - 1][3];\r\n        dp[i][3] = dp[i - 1][1] + dp[i - 1][2];\r\n\r\n        dp[i][1] %= mod;\r\n        dp[i][2] %= mod;\r\n        dp[i][3] %= mod;\r\n    }\r\n    cout &lt;&lt; ((dp[N][1] + dp[N][2] + dp[N][3]) % mod) &lt;&lt; endl;\r\n    return 0;\r\n}','2020-04-14 18:01:13',201),(12151636,'BJ',1021,'import java.util.Scanner;\r\n\r\nclass queue1 {\r\n    int top;\r\n    int[] queue;\r\n    int size;\r\n    int f;\r\n    int b;\r\n\r\n    public queue1() {\r\n        top = -1;\r\n        queue = new int[10000];\r\n        size = 0;\r\n        f = 1;\r\n        b = 0;\r\n    }\r\n\r\n    public int size() {\r\n        return size;\r\n    }\r\n\r\n    public int empty() {\r\n        if (size == 0)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    public int front() {\r\n        if (empty() == 1)\r\n            return -1;\r\n        else\r\n            return queue[f];\r\n    }\r\n\r\n    public int back() {\r\n        if (empty() == 1)\r\n            return -1;\r\n        else\r\n            return queue[b];\r\n    }\r\n\r\n    public void pop_front() {\r\n        size = size - 1;\r\n        f = f + 1;\r\n    }\r\n\r\n    public void pop_back() {\r\n        size = size - 1;\r\n        b = b - 1;\r\n    }\r\n\r\n    public void push_back(int s) {\r\n        size = size + 1;\r\n        b = b + 1;\r\n        queue[b] = s;\r\n    }\r\n\r\n    public void push_front(int s) {\r\n        int queue2[] = new int[10000];\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            queue2[i] = queue[i];\r\n        }\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            queue[i + 1] = queue2[i];\r\n        }\r\n        queue[1] = s;\r\n        size = size + 1;\r\n        b = b + 1;\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void rotate(queue1 st, queue1 result, int result_sum, int sum) {\r\n        queue1 v1 = new queue1();\r\n        queue1 v2 = new queue1();\r\n        int v1_cnt = 0;\r\n        int v2_cnt = 0;\r\n        if (result.empty() == 1) {\r\n            System.out.println(sum);\r\n            return;\r\n        } else {\r\n            if (st.front() == result.front()) {\r\n                st.pop_front();\r\n                result.pop_front();\r\n                sum = sum + result_sum;\r\n                result_sum = 0;\r\n                rotate(st,result,result_sum,sum);\r\n            } else {\r\n                while (st.empty() == 0) {\r\n                    v1.push_back(st.front());\r\n                    v2.push_back(st.front());\r\n                    st.pop_front();\r\n\r\n                }\r\n                while (v2.front() != result.front()) {\r\n                    v2_cnt = v2_cnt + 1;\r\n                    v2.push_back(v2.front());\r\n                    v2.pop_front();\r\n\r\n                }\r\n                while (v1.front() != result.front()) {\r\n                    v1_cnt = v1_cnt + 1;\r\n                    v1.push_front(v1.back());\r\n                    v1.pop_back();\r\n                }\r\n                if (v2_cnt &lt;= v1_cnt)\r\n                    rotate(v2, result, v2_cnt, sum);\r\n                else\r\n                    rotate(v1, result, v1_cnt, sum);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        queue1 st = new queue1();\r\n        queue1 result = new queue1();\r\n        int s;\r\n        Scanner sc = new Scanner(System.in);\r\n        int str = sc.nextInt();\r\n        for (int i = 1; i &lt;= str; i++)\r\n            st.push_back(i);\r\n        int st2 = sc.nextInt();\r\n        for (int i = 0; i &lt; st2; i++) {\r\n            int st3 = sc.nextInt();\r\n            result.push_back(st3);\r\n        }\r\n        int result_sum = 0;\r\n        int sum = 0;\r\n        rotate(st, result, result_sum, sum);\r\n    }\r\n\r\n}','2020-04-16 17:49:00',202),(12151536,'BJ',15684,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n\r\nint n, m, h;\r\nint map[31][11];\r\nint res = 10000000;\r\n\r\nbool ladder() { //사다리타기\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        int row = i;\r\n        int col = 1;\r\n        for (int j = 1; j &lt;= h; j++) {\r\n            if (map[col][row - 1] == 1)row--; //오른쪽에서 왼쪽\r\n            else if(map[col][row] == 1) row++;\r\n            col++; //한칸내려가기\r\n        }\r\n        if (i != row)return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid make_ladder1(int col, int row, int cnt) {\r\n    for (int i = col; i &lt;= h; i++) {\r\n        for (int j = 1; j &lt;= n; j++) {\r\n            if (i == col && j &lt; row)continue;\r\n            if (map[i][j] == 1 || map[i][j + 1] == 1 || map[i][j - 1] == 1)continue;\r\n            if (j + 1 &gt; n)continue;\r\n            map[i][j] = 1;\r\n            if (ladder())res = 1; //사다리타기가 성공하면 생성한 사다리 개수 저장\r\n            map[i][j] = 0;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid make_ladder2(int col, int row, int cnt) {\r\n    if (cnt == 2) {\r\n        if (ladder())res = 2; //사다리타기가 성공하면 생성한 사다리 개수 저장\r\n        return;\r\n    }\r\n    for (int i = col; i &lt;= h; i++) {\r\n        for (int j = 1; j &lt;= n; j++) {\r\n            if (i == col && j &lt; row)continue;\r\n            if (map[i][j] == 1 || map[i][j + 1] == 1 || map[i][j - 1] == 1)continue;\r\n            if (j + 1 &gt; n)continue;\r\n            map[i][j] = 1;\r\n            make_ladder2(i, j + 1, cnt + 1);\r\n            map[i][j] = 0;\r\n        }\r\n    }\r\n}\r\n\r\nvoid make_ladder3(int col, int row, int cnt) {\r\n    if (cnt == 3) {\r\n        if (ladder())res = 3; //사다리타기가 성공하면 생성한 사다리 개수 저장\r\n        return;\r\n    }\r\n    for (int i = col; i &lt;= h; i++) {\r\n        for (int j = 1; j &lt;= n; j++) {\r\n            if (i == col && j &lt; row)continue;\r\n            if (map[i][j] == 1 || map[i][j + 1] == 1 || map[i][j - 1] == 1)continue;\r\n            if (j + 1 &gt; n)continue;\r\n            map[i][j] = 1;\r\n            make_ladder3(i, j + 1, cnt + 1);\r\n            map[i][j] = 0;\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;\r\n    int row, col;\r\n    for (int i = 1; i &lt;= m; i++) {\r\n        cin &gt;&gt; col &gt;&gt; row;\r\n        if (row + 1 &lt;= n)map[col][row] = 1;\r\n    }\r\n    if (ladder())cout &lt;&lt; 0;\r\n    else {\r\n        make_ladder1(1, 1, 0);\r\n        if (res == 10000000) {\r\n            make_ladder2(1, 1, 0);\r\n            if (res == 10000000) {\r\n                make_ladder3(1, 1, 0);\r\n                if (res == 10000000)res = -1;\r\n            }\r\n        }\r\n        cout &lt;&lt; res;\r\n    }\r\n}','2020-04-18 18:42:15',203),(12151551,'BJ',15684,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\npair&lt;int, int&gt; map[30][30];\r\nint N, M, H;\r\nint fin = 0;\r\n\r\nbool down() {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int j = i;\r\n        int q = 0;\r\n        while (q &lt; H) {\r\n            if (map[q][j].second == 1 && map[q][j + 1].first == 1) {\r\n                q++;\r\n                j++;\r\n            }\r\n            else if (map[q][j].first == 1 && map[q][j - 1].second == 1) {\r\n                q++;\r\n                j--;\r\n            }\r\n            else q++;\r\n        }\r\n        if (j != i) return 0;\r\n    }\r\n    return 1;\r\n\r\n}\r\n\r\nvoid find(int index, int count,int a) {\r\n    if (fin == 1) return;\r\n    if (index == count) {\r\n        if (down() == true) {\r\n            cout &lt;&lt; count &lt;&lt; endl;\r\n            fin = 1;\r\n            return;\r\n        }\r\n        return;\r\n    }\r\n    for (int i = a; i &lt; H; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            if (fin == 1) return;\r\n            if (map[i][j].first == 0 && map[i][j].second == 0 && j+1&lt;N) {\r\n                map[i][j].second = 1;\r\n                map[i][j + 1].first = 1;\r\n                find(index + 1, count,i);\r\n                map[i][j].second = 0;\r\n                map[i][j + 1].first = 0;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\nvoid solve() {\r\n    if (down() == 1) {\r\n        cout &lt;&lt; 0 &lt;&lt; endl;\r\n        return;\r\n    }\r\n    else {\r\n        for (int i = 1; i &lt;= 4; i++) {\r\n            if (fin == 1) return;\r\n            if (i == 4) {\r\n                cout &lt;&lt; -1 &lt;&lt; endl;\r\n                return;\r\n            }\r\n            find(0, i,0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; H;\r\n    for (int i = 0; i &lt; M; i++) {\r\n        int a, b;\r\n        cin &gt;&gt; a &gt;&gt; b;\r\n        map[a-1][b-1].second = 1;\r\n        map[a-1][b].first = 1;\r\n    }\r\n    solve();\r\n    return 0;\r\n}\r\n\r\n','2020-04-19 03:54:24',204),(12171820,'BJ',1759,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint L; // 암호의 길이\r\n    \r\nint C; // 처음 입력받을 문자열의 길이\r\n\r\nbool con[15];\r\nint a=0; // 모음의 개수\r\nint b=0; // 자음의 개수\r\n\r\nvector &lt;char&gt; eng; // 입력받을 영어의 길이\r\nvoid seearch(int idx, int cnt)\r\n{\r\n    \r\n    if (cnt == L)\r\n    {\r\n        for (int i = 0; i &lt; C; i++)\r\n        {\r\n            if (con[i]==true)\r\n            {\r\n                if (eng[i] == &#39;a&#39; || eng[i] == &#39;e&#39; || eng[i] == &#39;i&#39; || eng[i] == &#39;o&#39; || eng[i] == &#39;u&#39; || eng[i] == &#39;w&#39;)\r\n                    a++;\r\n                else\r\n                    b++;\r\n            }\r\n        }\r\n        if (a &gt; 1 && b &gt; 2)\r\n        {\r\n            for (int i = 0; i &lt; C; i++)\r\n            {\r\n                if (con[i] == true)\r\n                {\r\n                    cout &lt;&lt; eng[i];\r\n                }\r\n            }\r\n        }\r\n        a = 0;\r\n        b = 0;\r\n        return;\r\n\r\n\r\n    }\r\n    for (int i = idx; i &lt; C; i++)\r\n    {\r\n        if (con[i] != true)\r\n        {\r\n            con[i] == true;\r\n        }\r\n        \r\n\r\n        seearch(i, cnt + 1);\r\n        con[i] == false;\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; L &gt;&gt; C;\r\n    for (int i = 1; i &lt;= C; i++)\r\n    {\r\n        char temp;\r\n        cin &gt;&gt; temp;\r\n        eng.push_back(temp);\r\n\r\n    }\r\n\r\n    sort(eng.begin(), eng.end());\r\n    seearch(0, 0);\r\n}','2020-04-21 13:49:34',205),(12161746,'BJ',1535,'//1535 안녕\r\n//틀렸습니당.. 고치고 있습니당..\r\n#include&lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint dp[101] = { 0 };\r\nint arrL[20] = { 0 };    //체력\r\nint arrH[20] = { 0 };    //기쁨\r\nint rst;\r\n\r\nvoid health()\r\n{\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j =99; j &gt;= arrL[i]; j--)    //100일때 0이니까 99부터\r\n        {\r\n            if (dp[j] != 0)        //값이 있을 때\r\n            {\r\n                if (dp[j] - arrL[j] &gt; 0)\r\n                {\r\n                    dp[j] = arrH[i] + dp[j - arrL[i]];\r\n                }\r\n            }\r\n        }\r\n        dp[100 - arrL[i]] = max(dp[100 - arrL[i]], arrH[i]);\r\n    }\r\n    for (int i = 0; i &lt;=100; i++)\r\n    {\r\n        rst = max(rst, dp[i]);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++)    //깎이는 체력\r\n        cin &gt;&gt; arrL[i];\r\n    for (int i = 1; i &lt;= N; i++)    //그만큼 얻는 기쁨\r\n    {\r\n        cin &gt;&gt; arrH[i];\r\n    }\r\n    health();\r\n    cout &lt;&lt; rst &lt;&lt; endl;\r\n}','2020-04-22 13:30:18',206),(12181853,'BJ',1759,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;map&gt;\r\nusing namespace std;\r\n\r\n#define MAX 15\r\n\r\nint L, C; // 서로 다른 L개의 알파벳과 문자의 종류 C가지\r\nchar alphabet[MAX]; // 입력받은 알파벳\r\nvector&lt;char&gt; vowel; // 모음\r\nvector&lt;char&gt; consonant; // 자음\r\nvector&lt;string&gt; code; // 결과\r\nmap&lt;string, bool&gt; visited; // 문자열에 대해서 방문하였으면 .count에서 true, 아니면 false를 반환\r\n// map&lt;string, bool&gt;에서 key값은 key, bool이 value가 된다.\r\n// map&lt;string, bool&gt; M에서 M.count(s)는 key값이 string s와 동일하느냐에 따라 동일하면 true, 동일하지 않으면 false를 반환 \r\n\r\n// 모든 조합을 시도해본다.\r\nvoid PW(int idx1, int idx2, int cnt1, int cnt2, string s)\r\n{    \r\n    if (s.length() == L && cnt1 &gt;= 1 && cnt2 &gt;= 2)\r\n    // 입력받은 문자의 길이가 L을 만족하여 자음이 최고 1개 이상. 모음이 최소 2개 이상임을 만족할 경우\r\n    {\r\n        sort(s.begin(), s.end()); // 사전순으로 정렬\r\n\r\n        if (!visited.count(s)) // key값 s에 대해 code 벡터에 넣지 않은 문자열일 경우\r\n        { \r\n            visited[s] = true; // 이 문자열을 true값으로 바꿔준다.\r\n            code.push_back(s); // 이 문자열을 code에 추가한다.\r\n        }\r\n        return;\r\n    }\r\n    \r\n    if (s.length() == L)\r\n        return;\r\n\r\n    for (int i = idx1 + 1; i &lt; vowel.size(); i++) // 문자에 사용되었을 모음의 개수만큼\r\n    {\r\n        PW(i, idx2, cnt1 + 1, cnt2, s + vowel[i]); // 입력받은 문자 alphabet에서 모음의 index를 하나씩 증가시키면서 string 문자열에 추가\r\n    }\r\n    for (int i = idx2 + 1; i &lt; consonant.size(); i++) // 문자에 사용되었을 자음의 개수만큼\r\n    {\r\n        PW(idx1, i, cnt1, cnt2 + 1, s + consonant[i]); // 입력받은 문자 alphabet에서 자음의 index를 하나씩 증가시키면서 string 문자열에 추가\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    cin &gt;&gt; L &gt;&gt; C;\r\n\r\n    for (int i = 0; i &lt; C; i++)\r\n    {\r\n        cin &gt;&gt; alphabet[i];\r\n\r\n        if (alphabet[i] == &#39;a&#39; || alphabet[i] == &#39;e&#39; || alphabet[i] == &#39;i&#39; || alphabet[i] == &#39;o&#39; || alphabet[i] == &#39;u&#39;)\r\n        {\r\n            vowel.push_back(alphabet[i]);\r\n        }\r\n        else\r\n        {\r\n            consonant.push_back(alphabet[i]);\r\n        }\r\n    }\r\n    sort(vowel.begin(), vowel.end());\r\n\r\n    sort(consonant.begin(), consonant.end());\r\n\r\n    PW(-1, -1, 0, 0, &quot;&quot;);\r\n\r\n    sort(code.begin(), code.end());\r\n\r\n    for (int i = 0; i &lt; code.size(); i++)\r\n    {\r\n        cout &lt;&lt; code[i] &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n    return 0;\r\n}','2020-04-23 17:17:20',207),(12181853,'BJ',16236,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\n#define MAX 20\r\n\r\nstruct shark\r\n{\r\n    int x, y;\r\n};\r\n\r\nshark DIR[4] = { { 0, -1 }, { -1, 0 }, { 1, 0 }, { 0, 1 } };\r\n\r\n\r\nstruct Info\r\n{\r\n    int time;\r\n    int x, y;\r\n};\r\n\r\nInfo;\r\n\r\n\r\nint fish_bowl[MAX][MAX];\r\nbool visited[MAX][MAX];\r\n\r\nint main(void)\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    int N;\r\n    cin &gt;&gt; N;\r\n\r\n    pair&lt;int, int&gt; start;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; N; j++)\r\n        {\r\n            cin &gt;&gt; fish_bowl[j][i];\r\n\r\n            if (fish_bowl[j][i] == 9) // 아기 상어의 위치\r\n            {\r\n                start = { j,i };\r\n                fish_bowl[j][i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; q;\r\n    // pair&lt;int, int&gt; = start\r\n    // &lt;pair&lt;int, int&gt;, int&gt; = start, shark_size\r\n    q.push({ { start }, 2 }); // 첫 시작에서 아기상어는 start점에 위치하고 크기는 2이다.\r\n\r\n    int num_fish; // 아기 상어가 잡아먹은 생선의 수\r\n    int duration; // 아기 상어가 도움을 요청하기 전까지의 시간\r\n\r\n    while (!q.empty())\r\n    {\r\n        int x = q.front().first.first;\r\n        int y = q.front().first.second;\r\n        int shark_size = q.front().second;\r\n        q.pop();\r\n\r\n        memset(visited, false, sizeof(visited));\r\n\r\n        priority_queue&lt;Info&gt; Route;\r\n        Route.push({ 0, x, y });\r\n        visited[x][y] = true;\r\n\r\n        while (!Route.empty())\r\n        {\r\n\r\n        }\r\n    }\r\n}','2020-04-23 17:57:22',208),(12181751,'BJ',1759,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint code_num;\r\nint num_arr;\r\nint num_array[16] = { 0 };\r\nint vowel[] = { 1,5,9,15,21,0 };\r\nint answer[16] = { 0 };\r\nint alpa(char text)\r\n{\r\n    if (text == &#39;a&#39;)\r\n        return 1;\r\n    else if (text == &#39;b&#39;)\r\n        return 2;\r\n    else if (text == &#39;c&#39;)\r\n        return 3;\r\n    else if (text == &#39;d&#39;)\r\n        return 4;\r\n    else if (text == &#39;e&#39;)\r\n        return 5;\r\n    else if (text == &#39;f&#39;)\r\n        return 6;\r\n    else if (text == &#39;g&#39;)\r\n        return 7;\r\n    else if (text == &#39;h&#39;)\r\n        return 8;\r\n    else if (text == &#39;i&#39;)\r\n        return 9;\r\n    else if (text == &#39;j&#39;)\r\n        return 10;\r\n    else if (text == &#39;k&#39;)\r\n        return 11;\r\n    else if (text == &#39;l&#39;)\r\n        return 12;\r\n    else if (text == &#39;m&#39;)\r\n        return 13;\r\n    else if (text == &#39;n&#39;)\r\n        return 14;\r\n    else if (text == &#39;o&#39;)\r\n        return 15;\r\n    else if (text == &#39;p&#39;)\r\n        return 16;\r\n    else if (text == &#39;q&#39;)\r\n        return 17;\r\n    else if (text == &#39;r&#39;)\r\n        return 18;\r\n    else if (text == &#39;s&#39;)\r\n        return 19;\r\n    else if (text == &#39;t&#39;)\r\n        return 20;\r\n    else if (text == &#39;u&#39;)\r\n        return 21;\r\n    else if (text == &#39;v&#39;)\r\n        return 22;\r\n    else if (text == &#39;w&#39;)\r\n        return 23;\r\n    else if (text == &#39;x&#39;)\r\n        return 24;\r\n    else if (text == &#39;y&#39;)\r\n        return 25;\r\n    else if (text == &#39;z&#39;)\r\n        return 26;\r\n}\r\n\r\nvoid secret_code(int vo,int con,int cnt)\r\n{\r\n    if (cnt == code_num)\r\n    {\r\n        for (int i = 0; i &lt; code_num; i++)\r\n            cout &lt;&lt; answer[i];\r\n        cout &lt;&lt; endl;\r\n    }\r\n    else {\r\n        for (int i = 0; i &lt; num_arr; i++)\r\n        {\r\n            int v;\r\n            for (v = 0; v &lt; 6; v++)\r\n            {\r\n                if(cnt==code_num-1 && )\r\n                if (num_array[i] == vowel[v])\r\n                {\r\n                    answer[cnt] = num_array[i];\r\n                    secret_code(vo + 1, con, cnt + 1);\r\n                    break;\r\n                }\r\n            }\r\n            if (v == 5)\r\n            {\r\n                answer[cnt] = num_array[i];\r\n                secret_code(vo, con + 1, cnt + 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d %d&quot;, &code_num, &num_arr);\r\n    for (int i = 0; i &lt; num_arr; i++)\r\n    {\r\n        char text;\r\n        scanf(&quot;%c&quot;, &text);\r\n        num_array[i]=alpa(text);\r\n    }\r\n    sort(num_array, num_array + num_arr);\r\n    return 0;\r\n}\r\n//코드 마무리중 ㅜㅜㅜ','2020-04-23 18:00:06',209),(12161783,'BJ',1759,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n#include&lt;string&gt;\r\n#include&lt;algorithm&gt;\r\n\r\nint L, C;\r\nchar arr[16];\r\n\r\n\r\n\r\nvoid dfs(string str, int ss, int mocnt, int jacnt, int cnt) {\r\n    if (ss == L) {\r\n        if (mocnt &gt;= 1 && jacnt &gt;= 2){\r\n            cout &lt;&lt; str &lt;&lt; endl;\r\n            return;\r\n        }\r\n    \r\n    }\r\n\r\n    //for(int i = rcnt;i&lt;C;i++)\r\n    \r\n    for (int i = cnt; i &lt; C; i++)\r\n    {\r\n        if (arr[i] == &#39;a&#39; || arr[i] == &#39;e&#39; || arr[i] == &#39;i&#39; || arr[i] == &#39;o&#39; || arr[i] == &#39;u&#39;) {\r\n            dfs(str + arr[i],ss+1, mocnt + 1, jacnt, i + 1);\r\n        }\r\n        //e\r\n        else {\r\n            dfs(str + arr[i],ss+1, mocnt, jacnt + 1, i + 1);\r\n        }\r\n\r\n    }\r\n}\r\nint main() {\r\n\r\n    cin &gt;&gt; L &gt;&gt; C;;\r\n    for (int i = 0; i &lt; C; i++) {\r\n        cin &gt;&gt; arr[i];\r\n    }\r\n\r\n    sort(arr, arr + C);\r\n    dfs(&quot;&quot;,0,0,0,0);\r\n    return 0;\r\n}\r\n\r\n','2020-04-23 18:00:08',210),(12181751,'BJ',16236,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint dx[] = { 0,-1,0,1 };//상좌하우\r\nint dy[] = { -1,0,1,0 };\r\nint N;\r\nqueue&lt;pair&lt;int,int&gt;&gt; shark;\r\nint N_N[21][21] = { 0 };\r\nint visited[21][21] = { 0 };\r\n\r\nvoid fishing()\r\n{\r\n    while (1)\r\n    {\r\n        int cx = shark.back().first;\r\n        int cy = shark.back().second;\r\n        shark.pop();\r\n        for (int i = 0; i &lt; 4; i++)\r\n        {\r\n            int nx = cx + dx[i];\r\n            int ny = cy + dy[i];\r\n            if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N)\r\n                continue;\r\n            shark.push({ nx,ny });\r\n        }\r\n        if(shark.size()&gt;1)\r\n\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    int cnt = 0;\r\n    for (int y = 0; y &lt; N; y++)\r\n    {\r\n        for (int x = 0; x &lt; N; x++)\r\n        {\r\n            scanf(&quot;%d %d&quot;,&N_N[x][y]);            \r\n            if (N_N[x][y] != 0 && N_N[x][y] &lt; 2)\r\n                cnt++;\r\n            if (N_N[x][y] == 9)\r\n                shark.push({ x,y });\r\n        }\r\n    }\r\n    if (cnt == 0)\r\n        return 0;\r\n}\r\n//bfs로 생각은 했는데 최단거리로 찾아가는거에서 막혀서 그 이후로 못건드렸어요ㅠㅠㅠㅠㅠㅠㅠ','2020-04-23 18:01:54',211),(12161746,'BJ',1759,'\r\n#include&lt;iostream&gt;\r\n#include&lt;vector&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nvector &lt;char&gt; ConS;        //자음\r\nvector &lt;char&gt; Vowel;    //모음\r\nint L, C;\r\nchar text[20];\r\nbool check[20] = { 0 };\r\nstring result;\r\n\r\nint find(int index, int f, char *te) {\r\n    if (index == L) {\r\n        for (int i = 0; i &lt; L; i++) cout &lt;&lt; te[i] &lt;&lt; &quot; &quot;;\r\n        cout &lt;&lt; endl;\r\n        return 0;\r\n    }\r\n    for (int i = 0; i &lt; C; i++) {\r\n        if (!check[i]) {\r\n            check[i] = true;\r\n            f++;\r\n            te[index] = text[i];\r\n            find(index + 1, f, te);\r\n        }\r\n    }\r\n}\r\n\r\n/*void passCode()\r\n{\r\n    if()\r\n    for (int i = 0; i &lt; C; i++)\r\n    {\r\n        if (text[i] == &#39;a&#39; || &#39;e&#39; || &#39;i&#39; || &#39;o&#39; || &#39;u&#39;)\r\n            Vowel.push_back(6);\r\n        else\r\n            ConS.push_back(20);\r\n    }\r\n    for (int i = 0; i &lt; ; i++)\r\n    {\r\n\r\n        sort(ConS, Vowel);\r\n    }\r\n}\r\n*/\r\nint main()\r\n{\r\n    cin &gt;&gt; L &gt;&gt; C;\r\n    for (int i = 0; i &lt; C; i++)\r\n    {\r\n        cin &gt;&gt; text[i];\r\n    }\r\n    passCode();\r\n\r\n}','2020-04-23 18:06:27',212),(12161783,'BJ',11057,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint dp[11][1001]    ; // 0~9수,n번째 자리수 \r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; 10; i++) {\r\n        dp[i][1] = 1;\r\n    }\r\n\r\n    for (int j = 2; j &lt;= N;j++) {\r\n        for (int i = 0; i &lt; 10; i++) {\r\n            for (int k=0; k + i &lt; 10; k++) {\r\n                dp[i][j] += dp[i + k][j - 1];\r\n            //    cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;  j=&quot; &lt;&lt; j &lt;&lt; endl;\r\n            //cout &lt;&lt; &quot;dp[i][j]=&quot; &lt;&lt; dp[i][j] &lt;&lt; endl;\r\n                dp[i][j] = dp[i][j] % 10007;\r\n            }\r\n        }\r\n    }\r\n\r\n    int ans = 0;\r\n    for (int i = 0; i &lt; 10; i++) {\r\n        ans= ans+dp[i][N];\r\n    }\r\n    cout &lt;&lt; ans % 10007 &lt;&lt; endl;\r\n    \r\n    return 0;\r\n}','2020-04-26 20:22:35',213),(12151629,'BJ',1695,'# 오답\r\n\r\nN = int(input())\r\nmy_list = list(map(int, input().split()))\r\nj = len(my_list)-1\r\nanswer1 = 0\r\nfor i in range(int(len(my_list)/2)+1):\r\n    # print(i, j, answer1)\r\n    if my_list[i] == my_list[j]:\r\n        j -= 1\r\n    else:\r\n        answer1 += 1\r\nmy_list.reverse()\r\nj = len(my_list)-1\r\nanswer2 = 0\r\nfor i in range(int(len(my_list)/2)+1):\r\n    # print(i, j, answer2)\r\n    if my_list[i] == my_list[j]:\r\n        j -= 1\r\n    else:\r\n        answer2 += 1\r\nif answer1 &lt; answer2:\r\n    print(answer1)\r\nelse:\r\n    print(answer2)\r\n\r\n','2020-04-27 13:33:51',214),(12181853,'BJ',11057,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define MAX 1001\r\n\r\nint N;\r\nint NUM[11][MAX]; // NUM[A][B] -&gt; A : 맨첫자리 수, B : 자리수\r\nint cnt = 0;\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; 10; i++)\r\n    {\r\n        NUM[i][1] = 1; // 한자리수에 대해서 \r\n    }\r\n\r\n    // 두 자리수 이상부터\r\n    for (int j = 2; j &lt;= N; j++)\r\n    {\r\n        for (int i = 0; i &lt; 10; i++)\r\n        {\r\n            for (int k = 0; k + i &lt; 10; k++)\r\n            {\r\n                NUM[i][j] += NUM[i + k][j - 1];\r\n\r\n                NUM[i][j] %= 10007;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i &lt; 10; i++)\r\n    {\r\n        cnt += NUM[i][N];\r\n    }\r\n\r\n    cout &lt;&lt; cnt % 10007 &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-04-27 21:39:51',215),(12181853,'BJ',1915,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n#define MAX 1001\r\n\r\nint N;\r\nint M;\r\n\r\nstring NUM[MAX];\r\nint Square[MAX][MAX]; // -&gt; N X M\r\n\r\nint Square_area(void)\r\n{\r\n    int side = 0;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= M; j++)\r\n        {\r\n            if (i == 1 || j == 1)\r\n            {\r\n                Square[i][j] = NUM[i][j] - &#39;0&#39;;\r\n            }\r\n            else if (NUM[i][j] == &#39;1&#39;)\r\n            {\r\n                Square[i][j] = min(min(Square[i][j - 1], Square[i - 1][j - 1]), Square[i - 1][j]) + 1;\r\n            }\r\n            side = max(side, Square[i][j]);\r\n        }\r\n    }\r\n    return side * side;\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    cin &gt;&gt; M;\r\n\r\n    if (N &lt; 1 || N &gt; MAX || M &lt; 1 || M &gt; MAX)\r\n    {\r\n        exit(-1);\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        cin &gt;&gt; NUM[i];\r\n    }\r\n\r\n    cout &lt;&lt; Square_area() &lt;&lt; endl;\r\n    \r\n    return 0;\r\n}','2020-04-27 23:34:23',216),(12151601,'BJ',11057,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    int d[1000][10] = { 0 };\r\n    for (int i = 0; i &lt; 10; i++) {\r\n        d[0][i] = 1;\r\n    }\r\n    for (int i = 0; i &lt; N - 1; i++) {\r\n        for (int j = 0; j &lt; 10; j++) {\r\n            for (int k = j; k &lt; 10; k++) {\r\n                d[i + 1][j] += d[i][k];\r\n                d[i + 1][j] %= 10007;\r\n            }\r\n        }\r\n    }\r\n    int ans = 0;\r\n    for (int i = 0; i &lt; 10; i++) {\r\n        ans += d[N - 1][i];\r\n        ans %= 10007;\r\n    }\r\n    cout &lt;&lt; ans;\r\n}','2020-04-28 01:59:41',217),(12161777,'BJ',11057,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int dp[1001][10];\r\n    int mod = 10007;\r\n\r\n    int n;\r\n    cin &gt;&gt; n;\r\n\r\n    for (int i = 0; i &lt;= 9; i++)\r\n    {\r\n        dp[1][i] = 1; //dp1행 초기화\r\n    }\r\n\r\n    for (int i = 2; i &lt;= n; i++) // i : 숫자의 길이\r\n    {\r\n        for (int j = 0; j &lt;= 9; j++) // j : 가장 오른쪽의 숫자   ex : xxxj\r\n        {\r\n            if (j == 0)\r\n            {\r\n                dp[i][j] = dp[i - 1][j];  // 맨끝자리가 0이라면 이전의 값까지가 오르막수\r\n            } \r\n            else\r\n            {\r\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n            }\r\n            dp[i][j] %= mod;\r\n        }\r\n    }\r\n\r\n    for (int i = 2; i &lt;= n; i++) \r\n    {\r\n        for (int j = 0; j &lt;= 9; j++) \r\n        {\r\n            cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;\r\n        }\r\n        cout &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n\r\n    int result = 0;\r\n    for (int i = 0; i &lt;= 9; i++)\r\n    {\r\n        result = (result + dp[n][i]) % mod;\r\n    }\r\n\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-04-28 17:35:38',218),(12151551,'BJ',11057,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint arr[1001][10] = { 0 };\r\n\r\nvoid make() {\r\n    for (int i = 0; i &lt;= 9; i++) arr[1][i] = 1;\r\n    for (int i = 2; i &lt;= 1000; i++) {\r\n        for (int j = 0; j &lt;= 9; j++) {\r\n            for (int k = j; k &lt;= 9; k++) {\r\n                arr[i][j] += arr[i - 1][k];\r\n                arr[i][j] %= 10007;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    make();\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    int sum = 0;\r\n    for (int i = 0; i &lt;= 9; i++) sum += arr[N][i];\r\n    cout &lt;&lt; sum%10007 &lt;&lt; endl;\r\n}','2020-04-28 17:42:48',219),(12161783,'BJ',1915,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n#include &lt;algorithm&gt;\r\n\r\nint map[1001][1001]={0};\r\nint n, m;\r\nint i, j;\r\nint one;\r\nint anscheck=0;\r\nint anscheck2 = 0;\r\n\r\nvoid find(int x,int y,int cnt) {\r\n    for (i = 0; i &lt; cnt-x; i++) {\r\n        for (j = 0; j &lt; cnt-y; j++) {\r\n        anscheck += map[x + i][y + j];\r\n    }\r\n    }\r\n\r\n    if (anscheck == cnt * cnt) {\r\n        anscheck2 = anscheck;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    for (i = 0; i &lt; n ; i++) {    \r\n        for (j = 0; j &lt; m; j++) {\r\n            scanf_s(&quot;%1d&quot;, &one);\r\n            map[i][j] = one;\r\n        }\r\n    }\r\n    \r\n    int ans=0;\r\n\r\n\r\n    for (int r = 0; r &lt; n; r++) {\r\n\r\n        for (int c = 0; c &lt; m; c++) {\r\n            for (i = 1; i &lt; min(n, m)-min(r,c) ; i++) {\r\n                find(r, c, i);\r\n                ans=max(ans, anscheck);\r\n            }\r\n        }\r\n    }\r\n\r\n    cout&lt;&lt; ans;\r\n\r\n\r\n\r\n        /*\r\n    for (i = 0; i &lt; n; i++) {\r\n        for (j = 0; j &lt; m; j++) {\r\n            cout &lt;&lt; map[i][j];\r\n        }\r\n        cout &lt;&lt; endl;\r\n    }*/\r\n\r\n    return 0;\r\n}','2020-04-28 18:02:59',220),(12181751,'BJ',11057,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint n;\r\nint num[1001][10] = { 0 };\r\nint answer = 0;\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; 10; i++)\r\n        num[1][i] = 1;\r\n    for (int aa = 2; aa &lt;= n; aa++)\r\n    {\r\n        for (int i = 0; i &lt; 10; i++)\r\n        {\r\n            for (int j = i; j &lt; 10; j++)\r\n            {\r\n                num[aa][i] += (num[aa - 1][j]%10007);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; 10; i++)\r\n        answer += (num[n][i]%10007);\r\n    cout &lt;&lt; answer%10007 &lt;&lt; endl;\r\n}','2021-01-10 03:21:51',221),(12171820,'BJ',1915,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n\r\nint a[1001][1001];\r\nint n;\r\nint m;\r\nint answer;\r\nint temp = 0;\r\nvoid add()\r\n{\r\n    for (int i = 1; i &lt; n; i++)\r\n    {\r\n        for (int j = 1; j &lt; m; j++)\r\n        {\r\n            if (((a[i - 1][j] != 0) && (a[i][j - 1] != 0)) && (a[i - 1][j - 1] != 0) && (a[i][j] != 0))\r\n            {\r\n\r\n                a[i][j] = min({ a[i - 1][j], a[i][j - 1], a[i - 1][j - 1]\r\n                    }) + 1;;\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        for (int j = 0; j &lt; m; j++)\r\n        {\r\n            cin &gt;&gt; a[i][j];\r\n\r\n        }\r\n    }\r\n    add();\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        for (int j = 0; j &lt; m; j++)\r\n        {\r\n            temp = max(a[i][j], temp);\r\n        }\r\n    }\r\n    //for (int i = 0; i &lt; n; i++)\r\n    //{\r\n        //for (int j = 0; j &lt; m; j++)\r\n        {\r\n        //    cout &lt;&lt; a[i][j]&lt;&lt;&quot; &quot;;\r\n        }\r\n        //cout &lt;&lt; endl;\r\n    //}\r\n\r\n    cout &lt;&lt; temp*temp;\r\n}','2020-04-28 18:53:51',222),(12181751,'BJ',1915,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint N, M;\r\nint N_M[1001][1001] = { 0 };\r\nint dp[1001][1001] = { 0 };\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int y = 0; y &lt; N; y++)\r\n    {\r\n        for (int x = 0; x &lt; M; x++)\r\n        {\r\n            scanf(&quot;%d&quot;,&N_M[y][x]);\r\n            dp[y][x] = N_M[y][x];\r\n        }\r\n    }\r\n    int MAX;\r\n    for (int y = 0; y &lt; N; y++)\r\n    {\r\n        for (int x = 0; x &lt; M; x++)\r\n        {\r\n            if (N_M[y][x] == 1)\r\n            {\r\n                MAX = min(min(dp[y - 1][x - 1], dp[y - 1][x]), dp[y][x - 1]);\r\n                dp[y][x] = MAX + 1;\r\n            }\r\n        }\r\n    }\r\n    MAX = 0;\r\n    for (int y = 0; y &lt; N; y++)\r\n    {\r\n        for (int x = 0; x &lt; M; x++)\r\n        {\r\n            if (MAX &lt; dp[y][x])\r\n                MAX = dp[y][x];\r\n        }\r\n    }\r\n    cout &lt;&lt; MAX * MAX &lt;&lt; endl;\r\n}','2020-04-28 18:52:59',223),(12151551,'BJ',1915,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;cmath&gt;\r\nusing namespace std;\r\n\r\nint arr[1002][1002] = { 0 };\r\n\r\nint main() {\r\n    int n, m;\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= m; j++) scanf(&quot;%1d&quot;, &arr[i][j]);\r\n    }\r\n    int result = 0;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= m; j++) {\r\n            if (arr[i][j] != 0) {\r\n                //if (i - 1 &gt;= 0 && i + 1 &lt; n && j - 1 &gt;= 0 && j + 1 &lt; m) {\r\n                    if (arr[i - 1][j] != 0 && arr[i][j - 1] != 0 && arr[i - 1][j - 1] != 0) {\r\n                        arr[i][j] = min(arr[i - 1][j], min(arr[i][j - 1], arr[i - 1][j - 1])) + 1;\r\n                    }\r\n                //}\r\n            }\r\n            result = max(result, arr[i][j]);\r\n        }\r\n    }\r\n    cout &lt;&lt; pow(result,2) &lt;&lt; endl;\r\n}','2020-04-28 18:35:49',224),(12151601,'BJ',1915,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint d[1001][1001];\r\nint dx[] = { 0,-1,-1 };\r\nint dy[] = { -1,0,-1 };\r\n\r\nint main() {\r\n    int n, m, ans = 0;\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= m; j++) {\r\n            scanf(&quot;%1d&quot;, &d[i][j]);\r\n        }\r\n    }\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        for (int j = 1; j &lt;= m; j++) {\r\n            int len = 1000;\r\n            bool square = true;\r\n            if (!d[i][j]) continue;\r\n            for (int n = 0; n &lt; 3; n++) {\r\n                int nx = i + dx[n];\r\n                int ny = j + dy[n];\r\n                if (!d[nx][ny]) {\r\n                    square = false;\r\n                    break;\r\n                }\r\n                else {\r\n                    len = d[nx][ny] &lt; len ? d[nx][ny] : len;\r\n                }\r\n            }\r\n            if(square)\r\n                d[i][j] = len + 1;\r\n            ans = d[i][j] &gt; ans ? d[i][j] : ans;\r\n        }\r\n    }\r\n    cout &lt;&lt; ans * ans;\r\n}\r\n','2020-04-28 18:55:58',225),(12161746,'BJ',11057,'//오르막수\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint dp[1001][11];        //dp[N][M] : [M]으로 끝나는 [N]자리수\r\nint result = 0;\r\n\r\nvoid main()\r\n{\r\n    int N,idx;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; 10; i++)    //한자리인 경우\r\n    {\r\n        dp[1][i] = 1;                //i로 끝나는 한자리수-&gt;한개씩있으므로 1로 초기화\r\n    }\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 2; j &lt;= N; j++)\r\n        {\r\n            for (int k = 0; k &lt;= j; k++)\r\n            {\r\n                dp[i][j] += dp[i - 1][k];    //이전 자리수의 합을 더해준다.\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i &lt;= 9; i++)\r\n    {\r\n        result += dp[N][i];\r\n    }\r\n    cout &lt;&lt; result%10007 &lt;&lt; endl;\r\n}','2020-04-29 02:05:17',226),(12151551,'BJ',10164,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint dp[18][18] = { 0 };\r\nint dp2[18][18] = { 0 };\r\nint N, M, K;\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n    int x, y = 0;\r\n    int cnt = 0;\r\n    if (K == 0) {\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            for (int j = 1; j &lt;= M; j++) {\r\n                if (i == 1 && j == 1) continue;\r\n                else if (i == 1 && j == 2) dp2[i][j] = 1;\r\n                else if (j == 1 && i == 2) dp2[i][j] = 1;\r\n                else if (i == 1)dp2[i][j] = dp2[i][j - 1];\r\n                else if (j == 1)dp2[i][j] = dp2[i - 1][j];\r\n                else dp2[i][j] = dp2[i - 1][j] + dp2[i][j - 1];\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (int i = 1; i &lt;= N; i++) {\r\n            for (int j = 1; j &lt;= M; j++) {\r\n                cnt++;\r\n                if (cnt == K) {\r\n                    x = i;\r\n                    y = j;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        for (int i = 1; i &lt;= x; i++) {\r\n            for (int j = 1; j &lt;= y; j++) {\r\n                if (i == 1 && j == 1) continue;\r\n                else if (i == 1 && j == 2) dp[i][j] = 1;\r\n                else if (j == 1 && i == 2) dp[i][j] = 1;\r\n                else if (i == 1)dp[i][j] = max(dp[i][j], dp[i][j - 1]);\r\n                else if (j == 1)dp[i][j] = max(dp[i][j], dp[i - 1][j]);\r\n                else dp[i][j] = max(dp[i][j], dp[i - 1][j] + dp[i][j - 1]);\r\n            }\r\n        }\r\n\r\n        for (int i = x; i &lt;= N; i++) {\r\n            for (int j = y; j &lt;= M; j++) {\r\n                if (i == x && j == y) continue;\r\n                else if (i == x && j == y + 1) dp2[i][j] = 1;\r\n                else if (j == y && i == x + 1) dp2[i][j] = 1;\r\n                else if (i == x)dp2[i][j] = dp2[i][j - 1];\r\n                else if (j == y)dp2[i][j] = dp2[i - 1][j];\r\n                else dp2[i][j] = dp2[i - 1][j] + dp2[i][j - 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    if (K == 0) {\r\n        cout &lt;&lt; dp2[N][M] &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n    else {\r\n        cout &lt;&lt; dp[x][y] * dp2[N][M] &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n}','2020-05-23 20:13:26',227),(12171820,'BJ',10164,'#include &lt;iostream&gt;    \r\n#include &lt;cmath&gt;\r\nusing namespace std;\r\n\r\nint factorial(int n)\r\n{\r\n    int sum = 1;\r\n    for (int i = 1; i &lt;= n; i++)\r\n    {\r\n        sum *= i;\r\n    }\r\n    return sum;\r\n\r\n}\r\nint main()\r\n{\r\n    int N;//\r\n    int M; // (1 ≤ N, M ≤ 15\r\n    int K; //곡 거쳐야 하는 위치 \r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n    int M_x = K / M ;\r\n    int N_y =abs( K - M)-1;\r\n\r\n    int M_L = N - K / M;\r\n    int N_L = M - abs(K - M)-1;\r\n    \r\n\r\n    if (K == 0)\r\n    {\r\n        cout &lt;&lt; factorial(M + N) / (factorial(M) * factorial(N));\r\n    }\r\n    else if(K != 0)\r\n    {\r\n        cout &lt;&lt; (factorial(N_y + M_x) / (factorial(M_x) * factorial(N_y))) * (factorial(N_L + M_L) / (factorial(M_L) * factorial(N_L)));\r\n    }\r\n\r\n}','2020-05-24 20:27:07',228),(12161783,'BJ',1043,'//내가 생각하고있는 예제코드는 맞는데 틀렸다고 나옴\r\n\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N, M;\r\nint tMn;//true man number\r\nint tMa[50] = { 0 };//true man array\r\nint pMn;//party man number\r\nint pMna[50]; \r\nint pMa[50][50];//party man array, [n번째 파티],[참석]\r\nint tMp[50];//진실을 알고있는 파티\r\nint tMp_cnt = 0;\r\nint cnt = 0;\r\nint cnt2 = 0;\r\n\r\n\r\nint find() {\r\n    int a, b, c,d;\r\n    \r\n    for (a = 0; a &lt; M; a++) {\r\n        for (b = 0; b &lt; pMna[a]; b++) {\r\n            for (c = 0; c &lt; tMp_cnt; c++) {\r\n                for (d = 0; d &lt; pMna[c]; d++) {\r\n                    if (pMa[a][b] == pMa[tMp[c]][d]) return cnt++;\r\n                }\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\nint find2() {\r\n    int a, b,c;\r\n    for (a = 0; a &lt; M; a++) {\r\n        for (b = 0; b &lt; pMna[a]; b++) {\r\n            for (c = 0; c &lt; tMn; c++) {\r\n                if (pMa[a][b] == tMa[c]) return cnt2++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    cin &gt;&gt; tMn;\r\n\r\n    int i, j, l;\r\n    for (i = 0; i &lt; tMn; i++) {\r\n        cin &gt;&gt; tMa[i];\r\n    }\r\n\r\n    for (i = 0; i &lt; M; i++) {\r\n        cin &gt;&gt; pMn;\r\n        pMna[i] = pMn;\r\n\r\n        for (j = 0; j &lt; pMn; j++) {\r\n            cin &gt;&gt; pMa[i][j];\r\n\r\n\r\n            //파티참석인원중에서 진실을 아는 자가 있으면 그파티 저장\r\n            for (l = 0; l &lt; tMn; l++) {\r\n                if (pMa[i][j] == tMa[l]) {\r\n                    tMp[tMp_cnt] = i;\r\n                    tMp_cnt++;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n    find();\r\n    find2();\r\n    cout &lt;&lt; M-cnt-cnt2;\r\n}\r\n','2020-05-25 15:52:22',229),(12161783,'BJ',10164,'// 팩토리얼(곱여러번) 하는건 쉽게 범위초과 하므로 다른방법을 생각해야함\r\n// %나 / 연산으로 좌표구할때 나누어떨어지는수 조심\r\n// 팩토리얼로구현한 코드도 추가함\r\n\r\n\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nlong long dp[17][17];\r\n\r\nvoid printdp() {\r\n    for (int a = 1; a &lt; 16; a++) {\r\n        for (int b = 1; b &lt; 16; b++) {\r\n            cout &lt;&lt; dp[a][b] &lt;&lt; &quot; &quot;;\r\n        }\r\n        cout &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    int N, M, K;\r\n    int Kr, Kc; //k를 받았을때 0표시의 r,c좌표\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n\r\n\r\n    long long first, second; // (Kr,Kc) 기준으로 첫번째 , 두번째 : 결과값은 곱한것\r\n\r\n\r\n    Kr = (K / M)+1;//0,0말고 1,1부터시작\r\n    \r\n    \r\n    Kc = K % M;\r\n    if (Kc == 0) {\r\n        Kc = M;\r\n        Kr = K / M;\r\n    }\r\n    int i, j;\r\n\r\n    for (i = 1; i &lt;= 15; i++) {\r\n        dp[i][1] = 1;\r\n        dp[1][i] = 1;\r\n    } // 초딩때했던 경로문제 위쪽변 다 1\r\n\r\n        if (K == 0) {\r\n            for (i = 2; i &lt;= N; i++) {\r\n                for (j = 2; j &lt;= M; j++) {\r\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n                }\r\n            }\r\n            cout &lt;&lt; dp[N][M];\r\n        }\r\n\r\n        else {\r\n            for (i = 2; i &lt;= Kr; i++) {\r\n                for (j = 2; j &lt;= Kc; j++) {\r\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n                }\r\n            }\r\n            first = dp[Kr][Kc];\r\n\r\n\r\n            \r\n            for (i = 0; i &lt; 16; i++) {\r\n                for (j = 0; j &lt; 16; j++) {\r\n                    dp[i][j] = 0;\r\n                }\r\n            }\r\n            \r\n            for (i = Kr; i &lt;= 15; i++) dp[i][Kc] = 1;\r\n            for (i = Kc; i &lt;= 15; i++) dp[Kr][i] = 1;\r\n\r\n            for (i = Kr + 1; i &lt;= N; i++) {\r\n                for (j = Kc + 1; j &lt;= M; j++) {\r\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n                }\r\n            }\r\n            second = dp[N][M];\r\n\r\n\r\n            cout &lt;&lt; first * second &lt;&lt; endl;\r\n        }\r\n//        printdp();\r\n    \r\n    return 0;\r\n\r\n}\r\n\r\n/*팩토리얼로 푸는경우 범위초과\r\nint fac(int num) {\r\n    int result = 1;\r\n    for (int i = 1; i &lt;= num; i++) result = result * i;\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    int N, M, K;\r\n    int Kr, Kc; // K를 받았을때 O표시의 r,c좌표\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n    Kr = (K / M) + 1;  //0,0말고 1,1부터시작\r\n    Kc = K % M;\r\n    if (K == 0) cout &lt;&lt; fac(N + M - 2) / (fac(N - 1) * fac(M - 1));\r\n    else cout &lt;&lt; (fac(Kr - 1 + Kc - 1) / (fac(Kr - 1) * fac(Kc - 1))) * (fac(N - Kr + M - Kc) / (fac(N - Kr) * fac(M - Kc)));\r\n\r\n\r\n    return 0;\r\n}\r\n\r\n*/','2020-05-27 22:24:07',230),(12161746,'BJ',10164,'#include&lt;iostream&gt;\r\nusing namespace std;\r\nint N, M, k, cnt;\r\nint dst[15][15] = { 0 };\r\nint start[15][15] = { 0 };\r\nint final[15][15] = { 0 };\r\nint arr[15][15] = { 0 };\r\nint pos = 1;\r\n\r\nvoid grid()\r\n{\r\n    int x, y;\r\n    if (k == 0)\r\n    {\r\n\r\n        final[1][2] = 1; final[2][1] = 1;\r\n        for (int i = 1; i &lt;= N; i++)\r\n        {\r\n            for (int j = 1; j &lt;= M; j++)\r\n            {\r\n                if ((i == 1 && j == 1) || (i == 1 && j == 2) || (i == 2 && j == 1)) continue;\r\n\r\n                else if (i == 1)\r\n                {\r\n                    final[1][j] = final[i][j - 1];\r\n                }\r\n                else if (j == 1)\r\n                {\r\n                    final[i][1] = final[i - 1][j];\r\n                }\r\n                else\r\n                    final[i][j] = final[i - 1][j] + final[i][j - 1];\r\n            }\r\n        }\r\n        cout &lt;&lt; final[N][M] &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n    else\r\n    {\r\n        for (int i = 1; i &lt;= N; i++)\r\n        {\r\n            for (int j = 1; j &lt;= M; j++)\r\n            {\r\n                if (arr[i][j] == k)\r\n                {\r\n                    x = i;\r\n                    y = j;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        dst[1][2] = 1; dst[2][1] = 1;\r\n        for (int i = 1; i &lt;= x; i++)\r\n        {\r\n            for (int j = 1; j &lt;= y; j++)\r\n            {\r\n                if ((i == 1 && j == 1) || (i == 1 && j == 2) || (i == 2 && j == 1)) continue;\r\n                dst[i][j] = dst[i][j - 1] + dst[i - 1][j];\r\n            }\r\n        }\r\n\r\n        final[x + 1][y] = 1; final[x][y + 1] = 1;\r\n        for (int i = x; i &lt;= N; i++)\r\n        {\r\n            for (int j = y; j &lt;= M; j++)\r\n            {\r\n                if ((i == x && j == y) || (i == x && j == y + 1) || (i == x + 1 && j == y)) continue;\r\n                final[i][j] = final[i][j - 1] + final[i - 1][j];\r\n            }\r\n        }\r\n        cout &lt;&lt; dst[x][y] * final[N][M] &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; k;\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= M; j++)\r\n        {\r\n            arr[i][j] = pos++;\r\n        }\r\n    }\r\n    grid();\r\n    return 0;\r\n}','2020-05-28 01:01:22',231),(12161777,'BJ',10164,'#include &lt;iostream&gt;\r\n#include &lt;cstring&gt;\r\nusing namespace std;\r\nint n, m, k;\r\nint field[16][16];\r\nint dp[16][16];\r\n\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\r\n    int ky, kx;\r\n    int num = 1;  //1~n*m 초기화\r\n    dp[0][1] = 1;\r\n    for(int i = 1; i &lt;= n; i++){\r\n        for(int j = 1; j &lt;= m; j++){\r\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n            if(num++ == k){\r\n                ky = i;\r\n                kx = j;\r\n            }\r\n        }\r\n    }\r\n    if(k == 0)\r\n    {\r\n        cout &lt;&lt; dp[n][m];\r\n        return 0;\r\n    }\r\n    int my = n - ky + 1;\r\n    int mx = m - kx + 1;\r\n    cout &lt;&lt; dp[ky][kx] * dp[my][mx];\r\n\r\n    return 0;\r\n}','2020-05-29 17:34:32',232),(12181853,'BJ',10164,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define MAX 15\r\n\r\nint dp[MAX][MAX];\r\nint x, y;\r\n\r\nint calculation(int n, int m)\r\n{\r\n    if (n == 1)\r\n        return 1;\r\n    if (m == 1)\r\n        return 1;\r\n    return dp[n][m] = calculation(n - 1, m) + calculation(n, m - 1);\r\n}\r\n\r\nint main()\r\n{\r\n    int M, N, K;\r\n\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n\r\n    int num = 1;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= M; j++)\r\n        {\r\n            if (K = num)\r\n            {\r\n                x = i; y = j;\r\n            }\r\n            dp[i][j] = num++;\r\n        }\r\n    }\r\n    if (!K)\r\n        cout &lt;&lt; calculation(N, M);\r\n    else\r\n        cout &lt;&lt; calculation(x, y) * calculation(N - x + 1, M - y + 1);\r\n\r\n}','2020-05-29 17:41:12',233),(12181751,'BJ',1043,'//틀렸습니다.ㅜㅜ\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nint t_peo, party;\r\nint tru_per;\r\nint tru_peo[50] = { 0 };\r\nvector&lt;int&gt; tru_party;\r\nvector&lt;int&gt; party_peo[50];\r\nint main()\r\n{\r\n    cin &gt;&gt; t_peo &gt;&gt; party;\r\n    cin &gt;&gt; tru_per;\r\n    for (int i = 0; i &lt; tru_per; i++)\r\n    {\r\n        cin &gt;&gt; tru_peo[i];\r\n    }\r\n    for (int i = 0; i &lt; party; i++)\r\n    {\r\n        int peo;\r\n        cin &gt;&gt; peo;\r\n        for (int j = 0; j &lt; peo; j++)\r\n        {\r\n            int c;\r\n            cin &gt;&gt; c;\r\n            party_peo[c].push_back(i);\r\n        }\r\n    }\r\n    int rent = tru_per;\r\n    int person;\r\n    for (int tt = 0; tt &lt; tru_per; tt++)\r\n    {\r\n        for (int i = 0; i &lt; t_peo; i++)\r\n        {\r\n            person = tru_peo[tt]+i;\r\n            if (person &gt;= t_peo) person = person - t_peo;\r\n            for (int g = 0; g &lt; tru_per; g++)\r\n            {\r\n                if (i == tru_peo[g])\r\n                {\r\n                    tru_peo[rent] = i;\r\n                    rent++;\r\n                    for (int k = 0; k &lt; party_peo[i].size(); k++)\r\n                    {\r\n                        tru_party.push_back(party_peo[i][k]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; party - tru_party.size() &lt;&lt; endl;\r\n}','2020-05-29 17:56:06',234),(12181751,'BJ',10164,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint N, M, K;\r\nint N_M[17][17] = { 0 };\r\n\r\nvoid Plus(int startx, int endx, int starty, int endy)\r\n{\r\n    for (int i = starty; i &lt;= endy; i++)\r\n    {\r\n        for (int j = startx; j &lt;= endx; j++)\r\n        {\r\n            if (i == 1 || j == 1)\r\n            {\r\n                if (i == 1 && j == 1)\r\n                    continue;\r\n                N_M[i][j] = 1;\r\n            }\r\n            else\r\n                N_M[i][j] = N_M[i - 1][j] + N_M[i][j - 1];\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\r\n    \r\n    int obj_x = (K % M);\r\n    if (obj_x==0) obj_x = M;\r\n    int obj_y = K / M;\r\n    if (K % M==0) obj_y = K/M-1;\r\n    cout &lt;&lt; obj_x &lt;&lt;&quot; &quot;&lt;&lt;obj_y &lt;&lt; endl;\r\n    int answer = 0;\r\n    \r\n    if (K == 0)\r\n    {\r\n        Plus(1, M, 1, N);\r\n        answer += N_M[N][M];\r\n    }\r\n    else\r\n    {\r\n        Plus(1, obj_x, 1, obj_y);\r\n        answer += N_M[obj_y][obj_x];\r\n        //cout &lt;&lt; N_M[obj_y][obj_x] &lt;&lt; endl;\r\n        Plus(1, M-obj_x+1,1, N-obj_y+1);\r\n        //cout &lt;&lt; N_M[N - obj_y + 1][M - obj_x + 1] &lt;&lt; endl;\r\n        answer += N_M[N - obj_y + 1][M - obj_x + 1];\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N+1; i++)\r\n    {\r\n        for (int j = 1; j &lt;= M + 1; j++)\r\n        {\r\n\r\n            cout &lt;&lt; N_M[i][j] &lt;&lt; &quot; &quot;;\r\n\r\n        }\r\n        cout &lt;&lt; endl;\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2020-05-29 18:16:33',235),(12171820,'BJ',11051,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\nint N, K;\r\nint dp[1001][1001];\r\nint main()\r\n{\r\n\r\n\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    dp[1][0] = 1;\r\n    dp[1][1] = 1;\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        for (int j = 0; j &lt;= i; j++)\r\n        {\r\n            if ((j == 0) && (j == i))\r\n                dp[i][j] = 1;\r\n            else\r\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 10007;\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[N][K];\r\n}','2020-06-01 23:06:54',236),(12161783,'BJ',11051,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint dp[1000][1000];\r\nint N, K;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    int    A = N - K + 1;\r\n    int    B = K + 1;\r\n    // result = (A+B)! /(A!*B!)\r\n\r\n    for (int i = 1; i &lt;= A; i++) dp[i][1] = 1;\r\n    for (int i = 1; i &lt;= B; i++) dp[1][i] = 1;\r\n    for (int i = 2; i &lt;= A; i++) {\r\n        for (int j = 2; j &lt;= B; j++) {\r\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n            dp[i][j] = dp[i][j] % 10007;\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[A][B];\r\n    return 0;\r\n}','2020-06-02 21:18:12',237),(12161783,'BJ',2688,'#include&lt;iostream&gt;\r\nusing namespace std;\r\n\r\nlong long dp[10][64];\r\nint main() {\r\n    int T, n;\r\n    cin &gt;&gt; T;\r\n\r\n    for (int t = 0; t &lt; T; t++) {\r\n        cin &gt;&gt; n;\r\n        \r\n        for (int i = 0; i &lt; 10; i++) {\r\n            \r\n            for (int j = 0; j &lt; 64; j++) {\r\n                dp[i][j] = 0;\r\n        }\r\n            dp[i][1] = 1;\r\n        }\r\n\r\n        for (int j = 2; j &lt;= n; j++) {\r\n            for (int i = 0; i &lt; 10; i++) {\r\n                for (int k = 0; k + i &lt; 10; k++) {\r\n                    dp[i][j] += dp[i + k][j - 1];\r\n                    dp[i][j] = dp[i][j];\r\n                }\r\n            }\r\n        }\r\n        long long ans = 0;\r\n        for (int i = 0; i &lt; 10; i++) {\r\n            ans = ans + dp[i][n];\r\n        }\r\n\r\n        cout &lt;&lt; ans &lt;&lt; endl;\r\n    }\r\n\r\n    return 0;\r\n}','2020-06-02 21:42:39',238),(12151601,'BJ',9251,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint d[1001][1001];\r\n\r\nint main() {\r\n    string a = &quot;|&quot;, b = &quot;&&quot;;\r\n    string A, B;\r\n    cin &gt;&gt; A &gt;&gt; B;\r\n    A = a + A;\r\n    B = b + B;\r\n    int asize = A.size(), bsize = B.size();\r\n    for (int i = 1; i &lt; asize; i++) {\r\n        for (int j = 1; j &lt; bsize; j++) {\r\n            int same = A[i] == B[j] ? 1 : 0;\r\n            d[i][j] = max(max(d[i - 1][j], d[i][j - 1]), d[i - 1][j - 1] + same);\r\n        }\r\n    }\r\n    cout &lt;&lt; d[asize - 1][bsize - 1];\r\n\r\n}','2020-06-22 18:01:50',239),(12151601,'BJ',15684,'// 시간초과\r\n\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nbool ladder[30][10];\r\nint N, H, M, answer = 100;\r\n\r\n// 배열복사\r\nvoid copyarr(bool arr1[30][10], bool arr2[30][10]) {\r\n    for (int i = 0; i &lt; H; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            arr2[i][j] = arr1[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// 처음 시작 세로줄에서 사다리 맨 밑까지 내려가는 동작\r\nvoid down(int& x, int& y) {\r\n    while (x &lt; H) {\r\n        if (y - 1 &gt;= 0 && ladder[x][y - 1]) y--;\r\n        else if (ladder[x][y]) y++;\r\n        x++;\r\n    }\r\n}\r\n\r\n// i번에서 시작해 i번에서 끝나는지 체크하는 함수\r\nbool check() {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int x = 0;\r\n        int y = i;\r\n        down(x, y);\r\n        if (y != i) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// 사다리를 전부 추가해보는 함수\r\nvoid makeladder(int cnt) {\r\n    if (cnt &gt; 3) return;\r\n    else if (!check()) {\r\n        bool _ladder[30][10] = { false };\r\n        copyarr(ladder, _ladder);\r\n\r\n        for (int i = 0; i &lt; H; i++) {\r\n            for (int j = 0; j &lt; N - 1; j++) {\r\n                if (ladder[i][j + 1] || ladder[i][j] || (j - 1 &gt;= 0 && ladder[i][j - 1])) continue;\r\n                ladder[i][j] = true;\r\n                makeladder(cnt + 1);\r\n                copyarr(_ladder, ladder);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        answer = cnt &lt; answer ? cnt : answer;\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; H;\r\n    for (int i = 0; i &lt; M; i++) {\r\n        int a, b;\r\n        cin &gt;&gt; a &gt;&gt; b;\r\n        ladder[a - 1][b - 1] = true;\r\n    }\r\n\r\n    makeladder(0);\r\n    answer = answer &gt; 3 ? -1 : answer;\r\n    cout &lt;&lt; answer;\r\n    return 0;\r\n}','2020-09-26 18:55:11',240),(12151601,'BJ',2688,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nlong long d[64][11] = { 0, };\r\n\r\nlong long dp(int n) {\r\n    if (d[n - 1][10] != 0) return d[n - 1][10];\r\n    for (int i = 0; i &lt; 10; i++) d[0][i] = 1;\r\n    d[0][10] = 10;\r\n    for (int i = 1; i &lt; n; i++) {\r\n        if (d[i][10] != 0) continue;\r\n        for (int j = 0; j &lt; 10; j++) {\r\n            for (int k = 0; k &lt;= j; k++) {\r\n                d[i][j] += d[i - 1][k];\r\n            }\r\n            d[i][10] += d[i][j];\r\n        }\r\n    }\r\n    return d[n - 1][10];\r\n}\r\n\r\nint main() {\r\n    int T, n;\r\n    cin &gt;&gt; T;\r\n    while (T--) {\r\n        cin &gt;&gt; n;\r\n        cout &lt;&lt; dp(n) &lt;&lt; endl;\r\n    }\r\n}','2020-10-06 20:14:20',241),(12151601,'BJ',11051,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint d[1001][1001];\r\n\r\nint main() {\r\n    int N, K;\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    d[0][0] = 1;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 0; j &lt;= i; j++) {\r\n            if (j == 0) d[i][j] = d[i - 1][j];\r\n            else if (j == i) d[i][j] = d[i - 1][j - 1];\r\n            else d[i][j] = (d[i - 1][j - 1] + d[i - 1][j]) % 10007;\r\n        }\r\n    }\r\n    cout &lt;&lt; d[N][K];\r\n}','2020-10-06 20:35:19',242),(12151601,'BJ',3190,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint N; // 맵 크기\r\nint board[100][100]; // 맵\r\nqueue&lt;pair&lt;int, char&gt;&gt; dir; // 방향전환 리스트\r\n\r\n// 0,1,2,3 순으로 시계방향\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\n\r\nint dummy() {\r\n    queue&lt;pair&lt;int, int&gt;&gt; snake;\r\n    snake.push({ 0,0 });\r\n    pair&lt;int, int&gt; cur = { 0,0 }; // 현재 머리 위치\r\n    board[0][0] = 1;\r\n    int d = 1; // 현재 방향\r\n    int time = 0; // 시간\r\n    pair&lt;int, char&gt; di = dir.front(); // 다음번 방향이 바뀌는 시간과 방향\r\n    dir.pop();\r\n    while (1) {\r\n        // 시간이 되면 좌회전 또는 우회전을 하도록 방향을 바꿔줌.\r\n        if (time == di.first) {\r\n            switch (di.second) {\r\n            case &#39;L&#39;:\r\n                d = (d + 3) % 4;\r\n                break;\r\n            case &#39;D&#39;:\r\n                d = (d + 1) % 4;\r\n                break;\r\n            }\r\n            if (!dir.empty()) {\r\n                di = dir.front();\r\n                dir.pop();\r\n            }\r\n        }\r\n        time++;\r\n        int nx = cur.first + dx[d]; // 다음 진행할 머리의 행\r\n        int ny = cur.second + dy[d]; // 다음 진행할 머리의 열\r\n\r\n        // 보드 벽과 만나면 리턴\r\n        if (nx &gt;= N || nx &lt; 0 || ny &lt; 0 || ny &gt;= N)\r\n            return time;\r\n\r\n        // 뱀 몸체와 만나면 리턴\r\n        if (board[nx][ny] == 1)\r\n            return time;\r\n\r\n        // 사과가 아닌 경우\r\n        if (board[nx][ny] != 2) {\r\n            pair&lt;int, int&gt; last = snake.front(); // 줄어드는 꼬리 위치\r\n            board[last.first][last.second] = 0; // 맵에서 줄어든 꼬리 0으로 변경\r\n            snake.pop(); // 큐에서 꼬리 제거\r\n        }\r\n        board[nx][ny] = 1; // 맵에서 머리가 진행한 좌표 1로 변경\r\n        cur = { nx,ny }; // 현재 위치도 변경\r\n        snake.push(cur); // 머리가 지나간 위치를 큐에 push\r\n    }\r\n}\r\n\r\nint main() {\r\n    int K, L, r, c, X;\r\n    char C;\r\n    cin &gt;&gt; N;\r\n    cin &gt;&gt; K;\r\n    for (int i = 0; i &lt; K; i++) {\r\n        cin &gt;&gt; r &gt;&gt; c;\r\n        board[r - 1][c - 1] = 2;\r\n    }\r\n    cin &gt;&gt; L;\r\n    for (int i = 0; i &lt; L; i++) {\r\n        cin &gt;&gt; X &gt;&gt; C;\r\n        dir.push({ X,C });\r\n    }\r\n    cout &lt;&lt; dummy();\r\n}','2020-11-06 23:52:05',243),(12181751,'BJ',11051,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\nint n = 0;\r\nint r = 0;\r\nint dp[1001][1001] = { 0 };\r\nint main()\r\n{\r\n    cin &gt;&gt; n &gt;&gt; r;\r\n    for (int i = 1; i &lt;= n; i++)\r\n    {\r\n        dp[i][0] = 1;\r\n        dp[i][i] = 1;\r\n    }\r\n    for (int i = 1; i &lt; n; i++)\r\n    {\r\n        for (int j = 1; j &lt; n; j++)\r\n        {\r\n            dp[i + 1][j] = dp[i][j - 1]%10007 + dp[i][j]%10007;\r\n        }\r\n    }\r\n    cout &lt;&lt; dp[n][r]%10007 &lt;&lt; endl;\r\n    return 0;\r\n}','2020-10-13 21:48:57',244),(12151551,'BJ',2688,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n\r\nint main() {\r\n    long long total[65] = { 0 };\r\n    total[1] = 10;\r\n    long long cal[65][10] = { 0 };\r\n    for (int i = 0; i &lt; 10; i++) cal[1][i] = 1;\r\n    for (int i = 2; i &lt;= 64; i++) {\r\n        long long to_cal = total[i-1];\r\n        long long sum_to = 0;\r\n        for (int j = 0; j &lt; 10; j++) {\r\n            if (j == 0) cal[i][j] = to_cal;\r\n            else cal[i][j] = cal[i][j - 1] - cal[i - 1][j - 1];\r\n            sum_to += cal[i][j];\r\n        }\r\n        total[i] = sum_to;\r\n    }\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    for (int i = 0; i &lt; T; i++) {\r\n        int n;\r\n        cin &gt;&gt; n;\r\n        cout &lt;&lt; total[n] &lt;&lt; &quot;inha_univ&quot;;\r\n    }\r\n    return 0;\r\n}','2020-11-02 22:59:12',246),(12151551,'BJ',11051,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint arr[1001][1001] = { 0 };\r\n\r\nint main() {\r\n    arr[0][0] = 1;\r\n    for (int i = 1; i &lt;= 1000; i++) {\r\n        for (int j = 0; j &lt;= 1000; j++) {\r\n            if (j == 0) arr[i][j] = arr[i - 1][j];\r\n            else if (i == j) arr[i][j] = arr[i - 1][j - 1];\r\n            else if (i &lt; j) continue;\r\n            else arr[i][j] = (arr[i-1][j - 1] + arr[i-1][j]) % 10007;\r\n        }\r\n    }\r\n\r\n    int N, K;\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n    cout &lt;&lt; arr[N][K]&lt;&lt; &quot;inha_univ&quot;;\r\n    return 0;\r\n}','2020-11-03 23:43:21',247),(12181853,'BJ',3190,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\n#define MAX 100\r\n#define L_MAX 100\r\n\r\nstruct CUR_DIR\r\n{\r\n    int curX;\r\n    int curY;\r\n};\r\n\r\nCUR_DIR curDir[MAX];\r\n\r\nint N; // 보드의 크기\r\nint K; // 사과의 개수\r\nint Col, Row; // 사과가 놓인 열, 행\r\nint L; // 뱀의 방향 변환 횟수\r\nint X; // 게임 시작 시간으로부터 지난 시간 (초)\r\nchar C; // 뱀의 이동 방향\r\nint Time; // 게임이 최종적으로 끝나는 시간\r\nqueue&lt;pair&lt;int, char&gt;&gt; DIR;\r\n\r\nint Board[MAX][MAX]; // 최대의 정사각 보드\r\nint Length = 1; // 뱀의 시작 길이\r\nint dx[4] = { 0, 0, -1, 1 };\r\nint dy[4] = { 1, -1, 0, 0 };\r\n// 순서대로 Right -&gt; Left -&gt; Up -&gt; Down\r\n// 뱀은 처음에 오른쪽을 향한다.\r\n// 뱀은 시작시에 맨위 맨좌측에 위치한다.\r\n\r\nint solve(int N, int K, int L)\r\n{\r\n    queue&lt;pair&lt;int, int&gt;&gt; Body;\r\n    Body.push({ 0, 0 }); // 뱀의 시작 위치 push\r\n    pair&lt;int, int&gt; curPosition = { 0, 0 };\r\n\r\n    Board[0][0] = true;\r\n    Time = 0;\r\n\r\n    curDir-&gt;curX = 0;\r\n    curDir-&gt;curY = 0;\r\n\r\n    pair&lt;int, char&gt; Info = DIR.front();\r\n    DIR.pop();\r\n\r\n    for (;;)\r\n    {\r\n        if (Time == Info.first)\r\n        {\r\n            if (Info.second == &#39;L&#39;)\r\n            {\r\n                if (curDir-&gt;curX == 0 && curDir-&gt;curY == 0)\r\n                {\r\n                    curDir-&gt;curX = 2;\r\n                    curDir-&gt;curY = 2;\r\n                }\r\n                else if (curDir-&gt;curX == 1 && curDir-&gt;curY == 1)\r\n                {\r\n                    curDir-&gt;curX = 3;\r\n                    curDir-&gt;curY = 3;\r\n                }\r\n                else if (curDir-&gt;curX == 2 && curDir-&gt;curY == 2)\r\n                {\r\n                    curDir-&gt;curX = 1;\r\n                    curDir-&gt;curY = 1;\r\n                }\r\n                else if (curDir-&gt;curX == 3 && curDir-&gt;curY == 3)\r\n                {\r\n                    curDir-&gt;curX = 0;\r\n                    curDir-&gt;curY = 0;\r\n                }\r\n            }\r\n            else if (Info.second == &#39;D&#39;)\r\n            {\r\n                if (curDir-&gt;curX == 0 && curDir-&gt;curY == 0)\r\n                {\r\n                    curDir-&gt;curX = 3;\r\n                    curDir-&gt;curY = 3;\r\n                }\r\n                else if (curDir-&gt;curX == 1 && curDir-&gt;curY == 1)\r\n                {\r\n                    curDir-&gt;curX = 2;\r\n                    curDir-&gt;curY = 2;\r\n                }\r\n                else if (curDir-&gt;curX == 2 && curDir-&gt;curY == 2)\r\n                {\r\n                    curDir-&gt;curX = 0;\r\n                    curDir-&gt;curY = 0;\r\n                }\r\n                else if (curDir-&gt;curX == 3 && curDir-&gt;curY == 3)\r\n                {\r\n                    curDir-&gt;curX = 1;\r\n                    curDir-&gt;curY = 1;\r\n                }\r\n            }\r\n            if (!DIR.empty())\r\n            {\r\n                Info = DIR.front();\r\n                DIR.pop();\r\n            }\r\n        }\r\n        Time++;\r\n\r\n        int nx = curPosition.first + dx[curDir-&gt;curX];\r\n        int ny = curPosition.second + dy[curDir-&gt;curY];\r\n\r\n        if (Board[nx][ny] == true) // 자기 자신과 부딪힌 상태\r\n        {\r\n            return Time;\r\n        }\r\n        if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= N) // 벽에 부딪힌 상황\r\n        {\r\n            return Time;\r\n        }\r\n        if (Board[nx][ny] != 100) // 뱀이 이동한 위치에 사과가 없었을 경우!\r\n        {\r\n            pair&lt;int, int&gt; Tail = Body.front();\r\n            Board[Tail.first][Tail.second] = false;\r\n            Body.pop();\r\n        }\r\n        Board[nx][ny] = true; // 뱀의 머리가 존재하는 위치에 true 값\r\n        curPosition = { nx, ny };\r\n        Body.push({ nx, ny });\r\n\r\n       /* for (int i = 0; i &lt; N; i++)\r\n        {\r\n            for (int j = 0; j &lt; N; j++)\r\n            {\r\n                cout &lt;&lt; Board[i][j] &lt;&lt; &quot; &quot;;\r\n            }\r\n            cout &lt;&lt; endl;\r\n        }*/\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    cin &gt;&gt; K;\r\n    for (int i = 0; i &lt; K; i++)\r\n    {\r\n        cin &gt;&gt; Row &gt;&gt; Col;\r\n        Board[Row - 1][Col - 1] = 100;\r\n    }\r\n\r\n    cin &gt;&gt; L;\r\n    for (int i = 0; i &lt; L; i++)\r\n    {\r\n        cin &gt;&gt; X &gt;&gt; C;\r\n        DIR.push({ X, C });\r\n    }\r\n\r\n    cout &lt;&lt; solve(N, K, L);\r\n\r\n    return 0;\r\n}','2020-11-07 02:42:32',248),(12161783,'BJ',3190,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\n\r\nint N, K, L;\r\nint map[101][101]; //1 사과 2 지렁이 -1 벽\r\n\r\nint X[101];\r\nchar C[101];\r\n\r\nint ans;\r\n\r\nqueue&lt;pair&lt;int, int&gt;&gt; q;//지렁이있는곳 first : 꼬리 , 선입선출\r\nint sol() {\r\n    int d = 0;\r\n    // 0 :오 1:아래 2:왼 3:위\r\n    int dx[4] = { 1,0,-1,0 };\r\n    int dy[4] = { 0,1,0,-1 };\r\n    int left[4] = { 3,0,1,2 };\r\n    int right[4] = { 1,2,3,0 };\r\n    int x = 1;\r\n    int y = 1;\r\n    ans = 1;\r\n    int cnt = 0;\r\n    for (;;) {\r\n\r\n        /*\r\n        for (int i = 0; i &lt; N + 2; i++) {\r\n            for (int j = 0; j &lt; 102; j++) {\r\n                if (map[i][j] == -1) cout &lt;&lt; &quot;@&quot;;\r\n                else cout &lt;&lt; map[i][j];\r\n            }\r\n            cout &lt;&lt; &quot;inha_univ&quot;;\r\n        }\r\n\r\n        \r\n        */\r\n\r\n\r\n        x = x + dx[d];\r\n        y = y + dy[d];\r\n        if (map[y][x] == 2 || map[y][x] == -1) break;\r\n\r\n        //사과가 아닐때\r\n        if (map[y][x] == 0) {\r\n            int n_y = q.front().first;\r\n            int n_x = q.front().second;\r\n            map[n_y][n_x] = 0; // 꼬리 이동\r\n            q.pop();\r\n        }\r\n\r\n        map[y][x] = 2;\r\n        q.push({ y,x });\r\n\r\n        if (ans == X[cnt]) {\r\n            if (C[cnt] == &#39;L&#39;) d = left[d];\r\n            else if (C[cnt] == &#39;D&#39;) d = right[d];\r\n            cnt++;\r\n        }\r\n        ans++;\r\n\r\n        \r\n    }\r\n\r\n\r\n\r\n    return ans;\r\n}\r\n\r\n\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; K;\r\n\r\n\r\n    for (int i = 0; i &lt; 102; i++) {\r\n        for (int j = 0; j &lt; 102; j++) map[i][j] = -1;\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) map[i][j] = 0;\r\n    }\r\n\r\n    int r, c;\r\n    for (int i = 0; i &lt; K; i++) {\r\n        cin &gt;&gt; r &gt;&gt; c;\r\n        map[r][c] = 1;\r\n    }\r\n\r\n    cin &gt;&gt; L;\r\n\r\n\r\n    for (int i = 0; i &lt; L; i++) {\r\n        cin &gt;&gt; X[i];\r\n        cin &gt;&gt; C[i];\r\n    }\r\n\r\n    map[1][1] = 2;//지렁이\r\n    q.push({ 1,1 });\r\n    cout &lt;&lt; sol();\r\n    return 0;\r\n}','2020-11-07 15:19:38',249),(12181853,'BJ',11051,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define MAX 1001\r\n\r\nint N;\r\nint K;\r\nint DP[MAX][MAX];\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    cin &gt;&gt; K;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        DP[i][0] = 1;\r\n    }\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        DP[i][i] = 1;\r\n    }\r\n\r\n    for (int i = 1; i &lt; N; i++)\r\n    {\r\n        for (int j = 1; j &lt; N; j++)\r\n        {\r\n            DP[i + 1][j] = (DP[i][j - 1] + DP[i][j]) % 10007;\r\n        }\r\n    }\r\n\r\n    cout &lt;&lt; DP[N][K] &lt;&lt; endl;\r\n\r\n    return 0;\r\n}','2020-11-07 15:45:46',250),(12171820,'BJ',3190,'#include&lt;iostream&gt;\r\n#include&lt;deque&gt;\r\n\r\nusing namespace std;\r\ntypedef pair&lt;int, int&gt; pii;\r\n\r\ndeque&lt;pair&lt;int, int&gt;&gt; dq;\r\n\r\nint change[101][2];\r\nint key = 1;\r\nint map[100][100];\r\nint n;\r\nint k;\r\nint conv[256];\r\nint row[4] = { -1,0,1,0 };\r\nint col[4] = { 0,1,0,-1 };\r\n\r\n\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; n &gt;&gt; k;\r\n    conv[&#39;L&#39;] = -1;\r\n    conv[&#39;D&#39;] = 1;\r\n\r\n    int r = 0;\r\n    int c = 0;\r\n    \r\n    for(int i= 0; i&lt; k; k++)\r\n    { \r\n        int ar, ac;\r\n        cin &gt;&gt; ar &gt;&gt; ac;\r\n        ar--; ac--;\r\n\r\n        map[ar][ac] = 1;\r\n    }\r\n\r\n    int l;\r\n\r\n    cin &gt;&gt; l;\r\n\r\n    for (int i = 0; i &lt; l; i++) {\r\n        int x;\r\n        char t;\r\n        cin &gt;&gt; x &gt;&gt; t;\r\n        change[i][0] = x;\r\n        change[i][1] = conv[t];\r\n    }\r\n\r\n    int t = 0;\r\n\r\n    dq.push_back({ r,c });\r\n    map[r][c] = -1;\r\n\r\n    int tcnt = 0;\r\n\r\n    while (true) {\r\n        t++;\r\n        pii next = dq.front();\r\n\r\n        next.first += row[key];\r\n        next.second += col[key];\r\n\r\n        if (next.first &lt; 0 || next.second &lt; 0 || next.first &gt;= n || next.second &gt;= n)\r\n        {\r\n            break;\r\n        }\r\n\r\n        else if (map[next.first][next.second] == -1)\r\n            break;\r\n\r\n        else if (map[next.first][next.second] == 0) \r\n        {\r\n            pii tail = dq.back();\r\n            map[tail.first][tail.second] = 0;\r\n            dq.pop_back();\r\n        }\r\n\r\n        map[next.first][next.second] = -1;\r\n        dq.push_front(next);\r\n\r\n        if (change[tcnt][0] == t) {\r\n            key = (4 + key + change[tcnt++][1]) % 4;\r\n        }\r\n    }\r\n\r\n\r\n    cout &lt;&lt; t;\r\n\r\n    return 0;\r\n}','2020-11-07 15:58:07',251),(12161783,'BJ',10845,'//정답\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nint arr[1000];\r\nint ind = -1;\r\n\r\n\r\n\r\nvoid push(int x) {\r\n    arr[ind+1] = x;\r\n    ind++;\r\n}\r\n\r\nvoid pop() {\r\n    if (ind == -1) cout &lt;&lt; ind&lt;&lt;endl;\r\n    else if (ind == 0) {\r\n        cout &lt;&lt; arr[0] &lt;&lt; endl;\r\n        ind--;\r\n    }\r\n    else if (ind &gt; 0) {\r\n        cout &lt;&lt; arr[0] &lt;&lt; endl;\r\n        for (int i = 1; i &lt;= ind; i++) {\r\n            arr[i - 1] = arr[i];\r\n        }\r\n        ind--;\r\n    }\r\n}\r\n\r\nvoid size() {\r\n    cout &lt;&lt; ind+1&lt;&lt;endl;\r\n}\r\n\r\nvoid empty() {\r\n    if (ind == -1) cout &lt;&lt; 1 &lt;&lt; endl;\r\n    else cout &lt;&lt; 0 &lt;&lt; endl;\r\n\r\n}\r\n\r\nvoid front() {\r\n    if (ind == -1) cout &lt;&lt; ind &lt;&lt; endl;\r\n    else {\r\n        cout &lt;&lt; arr[0] &lt;&lt; endl;\r\n    }\r\n}\r\n\r\nvoid back() {\r\n    if (ind == -1) cout &lt;&lt; ind &lt;&lt; endl;\r\n    else {\r\n        cout &lt;&lt; arr[ind] &lt;&lt; endl;\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n\r\n    int N;\r\n    int n;\r\n    string st[10001];\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; st[i];\r\n        if (st[i] == &quot;push&quot;) {\r\n            cin &gt;&gt; n;\r\n            push(n);\r\n        }\r\n        else if (st[i] == &quot;pop&quot;) {\r\n            pop();\r\n        }\r\n        else if (st[i] == &quot;size&quot;) {\r\n            size();\r\n        }\r\n        else if (st[i] == &quot;empty&quot;) {\r\n            empty();\r\n        }\r\n        else if (st[i] == &quot;front&quot;) {\r\n            front();\r\n        }\r\n        else if (st[i] == &quot;back&quot;) {\r\n            back();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return 0;\r\n\r\n}','2020-11-09 16:31:58',252),(12181853,'BJ',2164,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint N; // 카드 개수\r\n\r\nqueue&lt;int&gt; CARD;\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N; \r\n    \r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        CARD.push(i);\r\n    }\r\n\r\n    while (CARD.size() != 1)\r\n    {\r\n        CARD.pop();\r\n\r\n        int top_card = CARD.front();\r\n\r\n        CARD.push(top_card);\r\n        CARD.pop();\r\n    }\r\n    \r\n    cout &lt;&lt; CARD.front();\r\n}','2020-11-11 22:13:32',253),(12161783,'BJ',2164,'#include&lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#include &lt;queue&gt;\r\n\r\n\r\nint N;\r\n\r\n\r\nint main() {\r\n\r\n    cin &gt;&gt; N;\r\n    queue&lt;int&gt; q;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        q.push(i);\r\n    }\r\n\r\n    for (;;) {\r\n        if (q.size() == 1) break;\r\n        else {\r\n            q.pop();\r\n            q.push(q.front());\r\n            q.pop();\r\n        }\r\n    }\r\n\r\n    cout &lt;&lt; q.front();\r\n\r\n\r\n    return 0;\r\n\r\n}','2020-11-12 10:47:28',254),(12161783,'BJ',1074,'#include&lt;iostream&gt;\r\n#include &lt;cmath&gt;\r\nusing namespace std;\r\n\r\n//int map[32768][32768];\r\n//2차원배열로 넣어서풀면 배열초과..\r\n// \r\n\r\n\r\n\r\n\r\nint ser(int r, int c, int n) {\r\n    if (n == 1) return 2 * r + c;\r\n    else {\r\n        //1구역에 있으면 n범위를 1내리고 다시서치\r\n        if ((pow(2, n) / 2 &gt; r) && (pow(2, n) / 2 &gt; c)) {\r\n            return    ser(r, c, n - 1);\r\n        }\r\n        //2구역에 있으면 1구역만큼더하고 n범위를 1내리고 그 구역에서 다시서치\r\n        else if ((pow(2, n) / 2 &gt; r) && (pow(2, n) / 2 &lt;= c)) {\r\n            return    pow(2, n - 1) * pow(2, n - 1) + ser(r, c - (pow(2, n) / 2), (n - 1));\r\n        }\r\n        //3구역 1+2구역\r\n        else if (((pow(2, n) / 2) &lt;= r) && ((pow(2, n) / 2) &gt; c)) {\r\n            return    2 * pow(2, n - 1) * pow(2, n - 1) + ser(r - (pow(2, n) / 2), c, (n - 1));\r\n        }\r\n        else //4구역 1+2+3구역\r\n        {\r\n            return    3 * pow(2, n - 1) * pow(2, n - 1) + ser(r - (pow(2, n) / 2), c - (pow(2, n) / 2), (n - 1));\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int N, r, c;\r\n\r\n    cin &gt;&gt; N;\r\n    cin &gt;&gt; r &gt;&gt; c;\r\n    cout &lt;&lt; ser(r, c, N);\r\n    return 0;\r\n}','2020-11-12 14:02:34',255),(12151601,'BJ',2164,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    queue&lt;int&gt; card;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        card.push(i);\r\n    }\r\n    while (N &gt; 1) {\r\n        card.pop();\r\n        card.push(card.front());\r\n        card.pop();\r\n        N--;\r\n    }\r\n    cout &lt;&lt; card.front() + 1;\r\n}\r\n','2020-11-17 17:47:28',256),(12151601,'BJ',10845,'#include &lt;iostream&gt;\r\n#include &lt;string.h&gt;\r\nusing namespace std;\r\n\r\nclass MyQueue {\r\nprivate:\r\n    int arr[10000];\r\n    int in = 0, out = 0;\r\npublic:\r\n    void push(int num) { arr[in++] = num; }\r\n\r\n    void pop() {\r\n        if (empty()) cout &lt;&lt; -1 &lt;&lt; endl;\r\n        else cout &lt;&lt; arr[out++] &lt;&lt; endl;\r\n    }\r\n\r\n    void size() { cout &lt;&lt; in - out &lt;&lt; endl; }\r\n\r\n    bool empty() { return in == out; }\r\n\r\n    void front() {\r\n        if (empty()) cout &lt;&lt; -1 &lt;&lt; endl;\r\n        else cout &lt;&lt; arr[out] &lt;&lt; endl;\r\n    }\r\n\r\n    void back() {\r\n        if (empty()) cout &lt;&lt; -1 &lt;&lt; endl;\r\n        else cout &lt;&lt; arr[in - 1] &lt;&lt; endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int N;\r\n    MyQueue myQueue;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        char str[15];\r\n        scanf(&quot;%s&quot;, &str);\r\n        if (strcmp(str, &quot;push&quot;) == 0) {\r\n            int n;\r\n            cin &gt;&gt; n;\r\n            myQueue.push(n);\r\n        }\r\n        else if (strcmp(str, &quot;pop&quot;) == 0) {\r\n            myQueue.pop();\r\n        }\r\n        else if (strcmp(str, &quot;size&quot;) == 0) {\r\n            myQueue.size();\r\n        }\r\n        else if (strcmp(str, &quot;empty&quot;) == 0) {\r\n            cout &lt;&lt; myQueue.empty() &lt;&lt; endl;\r\n        }\r\n        else if (strcmp(str, &quot;front&quot;) == 0) {\r\n            myQueue.front();\r\n        }\r\n        else if (strcmp(str, &quot;back&quot;) == 0) {\r\n            myQueue.back();\r\n        }\r\n    }\r\n}','2020-11-12 19:20:19',258),(12161777,'BJ',2164,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n\r\nusing namespace std;\r\n\r\n/*\r\n    N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.\r\n    이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.\r\n    예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. \r\n    마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.\r\n    N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.\r\n*/\r\n//#define N = 500000;\r\n\r\nint main() {\r\n    int N;\r\n    queue&lt;int&gt; card;\r\n    //scanf_s(&quot;# of card %d&quot;, N);\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++) { // 카드에 N개넣기\r\n        card.push(i);\r\n    }\r\n\r\n    // 한장 남을때까지 홀수의 시행에선 버리기, 짝수의 시행에선 맨 아래로 보내기\r\n    while (card.size()!=1) {\r\n        card.pop(); // 홀수번째 시행의 카드 제거\r\n\r\n        //if (card.size() == 1)break; //탈출조건 마지막 카드 1개남을때 까지\r\n\r\n        // 짝수번째 시행\r\n        int temp = card.front(); // 뒤로 보내기 위한 맨 앞 카드 임시저장\r\n        card.pop();                 // 앞 카드는 없애고\r\n        card.push(temp);         // queue 특성상 뒤로 push하여 맨앞 숫자를 넣음\r\n    }\r\n    printf(&quot;%dinha_univ&quot;, card.front());\r\n    return 0;\r\n}','2020-11-13 00:17:00',259),(12181853,'BJ',2688,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\n#define NMAX 10\r\n#define MAX 64\r\n\r\nint main()\r\n{\r\n    int T; // 테스트케이스 수\r\n    int N; // N자리 수\r\n    long long NUM[NMAX][MAX];\r\n    // NUM[i][j] -&gt; j자리 수에서 i로 시작하는 수\r\n\r\n    cin &gt;&gt; T;\r\n    \r\n    for (int t = 0; t &lt; T; t++)\r\n    {\r\n        cin &gt;&gt; N;\r\n\r\n        for (int i = 0; i &lt;= 9; i++)\r\n        {\r\n            for (int j = 1; j &lt;=  MAX; j++)\r\n            {\r\n                NUM[i][j] = 0;\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i &lt;= 9; i++)\r\n        {\r\n            NUM[i][1] = 1; // 한자리 수에서 줄어들지 않는 수는 10개\r\n        }\r\n\r\n        for (int i = 2; i &lt;= N; i++)\r\n        {\r\n            for (int j = 0; j &lt;= 9; j++)\r\n            {\r\n                for (int k = 0; k + j &lt;= 9; k++)\r\n                {\r\n                    NUM[j][i] += NUM[j + k][i - 1];\r\n                }\r\n            }\r\n        }\r\n\r\n        long long result = 0;\r\n\r\n        for (int i = 0; i &lt;= 9; i++)\r\n        {\r\n            result = result + NUM[i][N];\r\n        }\r\n\r\n        cout &lt;&lt; result &lt;&lt; endl;\r\n    }\r\n    return 0;\r\n}','2020-11-13 02:07:09',260),(12161777,'BJ',1074,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint N, r, c;\r\nint cnt = 0;\r\n\r\nvoid foo(int part,int row,int col) {    // N이 커질수록 z의 횟수 4배씩 증가 1 &gt; 4 &gt; 16 &gt; 64개의 z 생성\r\n    \r\n    if (part == 2) { // 가장 최소의 z 2x2 matrix인 경우 (반복하다가 최종으로 값을 뽑아낼 행렬)\r\n        if (row == r && col == c) {    // 1사분면\r\n            cout &lt;&lt; cnt &lt;&lt; endl;\r\n            return;\r\n        }\r\n        else cnt++;\r\n\r\n        if (row == r && col + 1 == c) { // 2사분면\r\n            cout &lt;&lt; cnt &lt;&lt; endl;\r\n            return;\r\n        }\r\n        else cnt++;\r\n\r\n        if (row + 1 == r && col == c) { // 3사분면\r\n            cout &lt;&lt; cnt &lt;&lt; endl;\r\n            return;\r\n        }\r\n        else cnt++;\r\n\r\n        if (row + 1 == r && col + 1 == c) { //4사분면\r\n            cout &lt;&lt; cnt &lt;&lt; endl;\r\n            return;\r\n        }\r\n        else cnt++;\r\n        \r\n        return; // r,c에 해당하지 않는 행렬이면 break\r\n    }\r\n    // 크게 4개로 나누어 각각의 경우에 대해 z 수행 (가로,세로로 2씩 나누어 z가 4배 되는 과정을 역으로 실행)\r\n    foo(part / 2, row, col);\r\n    foo(part / 2, row, col + part / 2);\r\n    foo(part / 2, row + part / 2, col);\r\n    foo(part / 2, row + part / 2, col + part / 2);\r\n}\r\n\r\nint main() {                // 크게 1,2,3,4분면으로 나누고 또 거기중에서도 1,2,3,4분면으로 갈리므로 재귀를 이용해야함\r\n    cin &gt;&gt; N &gt;&gt; r &gt;&gt; c; \r\n    \r\n    foo(1&lt;&lt;N, 0, 0);    // 0,0 부터 탐색\r\n    \r\n    return 0;\r\n}','2020-11-13 11:03:50',261),(12161777,'BJ',10845,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;string&gt;\r\n\r\nusing namespace std;\r\n\r\nqueue&lt;int&gt; q;\r\n\r\n\r\nint main() {                //6 가지 명령 수행\r\n    int N; // 명령수\r\n    cin &gt;&gt; N;\r\n    cin.ignore();\r\n\r\n    for(int i=0;i&lt;N;i++){\r\n        string s;\r\n        getline(cin, s);\r\n        if (s == &quot;pop&quot;) {\r\n            if (q.empty())cout &lt;&lt; -1 &lt;&lt; endl;\r\n            else{\r\n                cout &lt;&lt; q.front() &lt;&lt; endl;\r\n                q.pop();\r\n            }\r\n        }\r\n\r\n        else if (s == &quot;front&quot;) {\r\n            if (q.empty()) cout &lt;&lt; -1 &lt;&lt; endl;\r\n            else cout &lt;&lt; q.front() &lt;&lt; endl;\r\n        }\r\n\r\n        else if (s == &quot;back&quot;) {\r\n            if (q.empty()) cout &lt;&lt; -1 &lt;&lt; endl;\r\n            else cout &lt;&lt; q.back() &lt;&lt; endl;\r\n        }\r\n\r\n        else if (s == &quot;empty&quot;) {\r\n            if (q.empty()) cout &lt;&lt; 1 &lt;&lt; endl;\r\n            else cout &lt;&lt; 0 &lt;&lt; endl;\r\n        }\r\n\r\n        else if (s == &quot;size&quot;) {\r\n            cout &lt;&lt; q.size() &lt;&lt; endl;\r\n        }\r\n\r\n        else {  // push case (if로 하면 s==push x 를 구현하기 힘드므로 else로함)\r\n            s = s.erase(0, 5); // push + space까지 총 5개를 지워주고 숫자만 남긴다.\r\n            int x = stoi(s); // 잘라내고 남은 s인 숫자를 정수형으로 바꿔서 저장\r\n            q.push(x);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}','2020-11-13 13:02:53',262),(12181853,'BJ',10845,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nstruct Queue\r\n{\r\n    int data[10000];\r\n    int begin;\r\n    int end;\r\n\r\n    Queue()\r\n    {\r\n        begin = 0;\r\n        end = 0;\r\n    }\r\n\r\n    bool empty()\r\n    {\r\n        return (size() == 0) ? 1 : 0;\r\n    }\r\n\r\n    void push(int num)\r\n    {\r\n        data[end] = num;\r\n        end += 1;\r\n    }\r\n\r\n    int pop()\r\n    {\r\n        if (empty())\r\n        {\r\n            return -1;\r\n        }\r\n        else\r\n        {\r\n            begin += 1;\r\n            return data[begin - 1];\r\n        }\r\n    }\r\n\r\n    int size()\r\n    {\r\n        return end - begin;\r\n    }\r\n\r\n    int front()\r\n    {\r\n        if (empty())\r\n        {\r\n            return -1;\r\n        }\r\n        else\r\n        {\r\n            return data[begin];\r\n        }\r\n    }\r\n\r\n    int back()\r\n    {\r\n        if (empty())\r\n        {\r\n            return -1;\r\n        }\r\n        else\r\n        {\r\n            return data[end - 1];\r\n        }\r\n    }\r\n};\r\n\r\nint main(void)\r\n{\r\n    int N;\r\n    \r\n    cin &gt;&gt; N;\r\n\r\n    Queue Q;\r\n\r\n    while (N--)\r\n    {\r\n        string str;\r\n        cin &gt;&gt; str;\r\n\r\n        if (str == &quot;push&quot;)\r\n        {\r\n            int num;\r\n            cin &gt;&gt; num;\r\n            Q.push(num);\r\n        }\r\n        else if (str == &quot;pop&quot;)\r\n        {\r\n            cout &lt;&lt; Q.pop() &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;size&quot;)\r\n        {\r\n            cout &lt;&lt; Q.size() &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;empty&quot;)\r\n        {\r\n            cout &lt;&lt; Q.empty() &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;front&quot;)\r\n        {\r\n            cout &lt;&lt; Q.front() &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;back&quot;)\r\n        {\r\n            cout &lt;&lt; Q.back() &lt;&lt; endl;\r\n        }\r\n    }\r\n}','2020-11-13 15:47:29',263),(12181853,'BJ',10845,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N;\r\n    \r\n    cin &gt;&gt; N;\r\n\r\n    queue&lt;int&gt; Q;\r\n\r\n    int num;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        string str;\r\n        cin &gt;&gt; str;\r\n\r\n        if (str == &quot;push&quot;)\r\n        {\r\n            int data;\r\n            cin &gt;&gt; data;\r\n            Q.push(data);\r\n        }\r\n        else if (str == &quot;pop&quot;)\r\n        {\r\n            if (Q.size() != 0)\r\n            {\r\n                num = Q.front();\r\n                Q.pop();\r\n            }\r\n            else\r\n            {\r\n                num = -1;\r\n            }\r\n            cout &lt;&lt; num &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;size&quot;)\r\n        {\r\n            cout &lt;&lt; Q.size() &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;empty&quot;)\r\n        {\r\n            if (Q.size() == 0)\r\n            {\r\n                num = 1;\r\n            }\r\n            else\r\n            {\r\n                num = 0;\r\n            }\r\n            cout &lt;&lt; num &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;front&quot;)\r\n        {\r\n            if (Q.size() == 0)\r\n            {\r\n                num = -1;\r\n            }\r\n            else\r\n            {\r\n                num = Q.front();\r\n            }\r\n            cout &lt;&lt; num &lt;&lt; endl;\r\n        }\r\n        else if (str == &quot;back&quot;)\r\n        {\r\n            if (Q.size() == 0)\r\n            {\r\n                num = -1;\r\n            }\r\n            else\r\n            {\r\n                num = Q.back();\r\n            }\r\n            cout &lt;&lt; num &lt;&lt; endl;\r\n        }\r\n    }\r\n    return 0;\r\n}','2020-11-13 15:47:47',264),(12171820,'BJ',1074,'#include &lt;iostream&gt;\r\n#include &lt;cmath&gt;\r\nusing namespace std;\r\n\r\nint  N, r, c;\r\nint count;\r\n\r\nvoid divv(int x, int y, int len)\r\n{\r\n    if (y == r && x == c)\r\n    {\r\n        cout &lt;&lt; ::count &lt;&lt; endl;\r\n        return; // 전역변수를 의미\r\n    }\r\n\r\n    if (len == 1)\r\n    {\r\n        ::count++;\r\n        return;\r\n    }\r\n    if (!(y&lt;= r && r &lt; y + len && x &lt;= c && c &lt; x + len))\r\n    {\r\n        ::count += len*len;\r\n        return;\r\n    }\r\n    divv(x            , y             , len / 2);\r\n    divv(x + len / 2, y             , len / 2);\r\n    divv(x            , y + len /2 , len / 2);\r\n    divv(x + len / 2, y + len / 2, len / 2);\r\n\r\n\r\n\r\n\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N&gt;&gt; r&gt;&gt; c;\r\n    divv(0, 0, pow(2,N));\r\n\r\n}','2020-11-13 21:35:50',265),(12171820,'BJ',10845,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;queue&gt;\r\n\r\nusing namespace std;\r\nqueue &lt;int&gt; que;\r\n\r\nvoid push(int);\r\nvoid pop();\r\nint size();\r\nbool empty();\r\nint front();\r\nint back();\r\n\r\n\r\nint main()\r\n{\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    string s;\r\n\r\n\r\n    while (N != 0)\r\n    {\r\n\r\n        cin &gt;&gt; s;\r\n        if (s == &quot;push&quot;)\r\n        {\r\n            int x;\r\n            cin &gt;&gt; x;\r\n            push(x);\r\n        }\r\n        else if (s == &quot;pop&quot;)\r\n        {\r\n            if (empty())\r\n            {\r\n                cout &lt;&lt; -1 &lt;&lt; endl;\r\n            }\r\n            else {\r\n                cout &lt;&lt; que.front() &lt;&lt; endl;\r\n                pop();\r\n            }\r\n        }\r\n        else if (s == &quot;size&quot;)\r\n        {\r\n            cout &lt;&lt; size() &lt;&lt; endl;\r\n        }\r\n        else if (s == &quot;front&quot;)\r\n        {\r\n            if (empty())\r\n            {\r\n                cout &lt;&lt; -1 &lt;&lt; endl;\r\n            }\r\n            else\r\n                cout &lt;&lt; front() &lt;&lt; endl;\r\n        }\r\n        else if (s == &quot;back&quot;)\r\n        {\r\n            if (empty())\r\n            {\r\n                cout &lt;&lt; -1 &lt;&lt; endl;\r\n            }\r\n            else\r\n                cout &lt;&lt; back() &lt;&lt; endl;\r\n        }\r\n        else if (s == &quot;empty&quot;)\r\n        {\r\n            if (empty())\r\n            {\r\n                cout &lt;&lt; 1 &lt;&lt; endl;\r\n            }\r\n            else\r\n                cout &lt;&lt; 0 &lt;&lt; endl;\r\n        }\r\n\r\n        N--;\r\n    }\r\n\r\n\r\n\r\n}\r\nvoid push(int i)\r\n{\r\n    que.push(i);\r\n}\r\nvoid pop()\r\n{\r\n    que.pop();\r\n}\r\nint size()\r\n{\r\n    return que.size();\r\n}\r\nbool empty()\r\n{\r\n    if (que.empty())\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\nint front()\r\n{\r\n    return que.front();\r\n}\r\nint back()\r\n{\r\n    return que.back();\r\n}','2020-11-13 22:33:20',266),(12171820,'BJ',2164,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N; // N &lt;500000\r\n    cin &gt;&gt; N;\r\n    queue &lt;int&gt; q;\r\n\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        q.push(i);\r\n    }\r\n    while (q.size() != 1)\r\n    {\r\n        q.pop();\r\n        int temp = q.front();\r\n        q.pop();\r\n        q.push(temp);\r\n    }\r\n    cout &lt;&lt; q.front() &lt;&lt; endl;\r\n}','2020-11-13 22:44:37',267),(12171820,'BJ',2688,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\n//첫째 줄에 테스트 케이스의 개수 T(1 &lt;= T &lt;= 1,000)이 주어진다. 각 테스트 케이스는 숫자 하나 n으로 이루어져 있다. (1 &lt;= n &lt;= 64)\r\n\r\nlong long dp[65][10];\r\nlong long answer[65] = { 0 };\r\nint main()\r\n{\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    int* a = new int[T];\r\n\r\n    for (int i = 0; i &lt; T; i++)\r\n    {\r\n        cin &gt;&gt; a[i];\r\n    }\r\n\r\n    for (int i = 0; i &lt; 10; i++)\r\n    {\r\n        dp[1][i] = 1;\r\n\r\n    }\r\n    answer[1] = 10;\r\n    for (int i = 2; i &lt; 65; i++)\r\n    {\r\n        for (int j = 0; j &lt; 10; j++)\r\n        {\r\n            dp[i][j] = 0;\r\n            for (int k = 0; k &lt;= j; k++)\r\n            {\r\n                dp[i][j] += dp[i - 1][k];\r\n            }\r\n            answer[i] += dp[i][j];\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; T; i++)\r\n    {\r\n        cout &lt;&lt; answer[a[i]] &lt;&lt; endl;\r\n    }\r\n    \r\n    \r\n\r\n\r\n\r\n}','2020-11-14 15:44:39',268),(12151601,'BJ',1074,'#include &lt;iostream&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\n\r\n/*\r\n        |\r\n    1   |    2\r\n ㅡㅡㅡ(n,n)ㅡㅡㅡ\r\n    3   |    4\r\n        |\r\n*/\r\nint whereis(int n, int& r, int& c) {\r\n    if (r &lt; n && c &lt; n) return 1;\r\n    else if (r &lt; n && c &gt;= n) {\r\n        c -= n;\r\n        return 2;\r\n    }\r\n    else if (r &gt;= n && c &lt; n) {\r\n        r -= n;\r\n        return 3;\r\n    }\r\n    else if (r &gt;= n && c &gt;= n) {\r\n        r -= n, c -= n;\r\n        return 4;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int N, r, c;\r\n    cin &gt;&gt; N &gt;&gt; r &gt;&gt; c;\r\n    int n = pow(2, N - 1);\r\n    int ans = 0;\r\n    while (n) {\r\n        switch (whereis(n, r, c)) {\r\n        case 4:\r\n            ans += n * n;\r\n        case 3:\r\n            ans += n * n;\r\n        case 2:\r\n            ans += n * n;\r\n        }\r\n        n /= 2;\r\n    }\r\n    cout &lt;&lt; ans;\r\n}','2020-11-17 17:47:09',269),(12151601,'BJ',16234,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;math.h&gt;\r\n\r\nusing namespace std;\r\n\r\nint A[50][50];\r\nbool inUnion[50][50];\r\nint N, L, R;\r\n\r\nint dx[] = { 1,0,-1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\n\r\nbool move(int x, int y, bool inUnion[50][50]) {\r\n    bool movement = false;\r\n    int population = A[x][y];\r\n    vector&lt;pair&lt;int, int&gt;&gt; country;\r\n    queue&lt;pair&lt;int, int&gt;&gt; q;\r\n    country.push_back({ x,y });\r\n    q.push({ x, y });\r\n    while (!q.empty()) {\r\n        x = q.front().first, y = q.front().second;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = x + dx[i], ny = y + dy[i];\r\n            if (nx &gt;= N || nx &lt; 0 || ny &gt;= N || ny &lt; 0) continue;\r\n            if (inUnion[nx][ny]) continue;\r\n            int dif = abs(A[x][y] - A[nx][ny]);\r\n            if (dif &gt;= L && dif &lt;= R) {\r\n                country.push_back({ nx,ny });\r\n                q.push({ nx,ny });\r\n                inUnion[nx][ny] = true;\r\n                population += A[nx][ny];\r\n                movement = true;\r\n            }\r\n        }\r\n    }\r\n    population /= country.size();\r\n    for (int i = 0; i &lt; country.size(); i++) {\r\n        A[country[i].first][country[i].second] = population;\r\n    }\r\n    return movement;\r\n}\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    cin &gt;&gt; L &gt;&gt; R;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; A[i][j];\r\n        }\r\n    }\r\n    int cnt = 0;\r\n    while (1) {\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; N; j++) {\r\n                inUnion[i][j] = false;\r\n            }\r\n        }\r\n        bool moved = false;\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; N; j++) {\r\n                if (!inUnion[i][j]) {\r\n                    inUnion[i][j] = true;\r\n                    if (move(i, j, inUnion)) {\r\n                        moved = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (moved) cnt++;\r\n        else break;\r\n    }\r\n    cout &lt;&lt; cnt;\r\n}','2020-11-19 18:19:37',271),(12151601,'BJ',14889,'#include &lt;math.h&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint N, answer = 1000000;\r\nint status[20][20];\r\nbool team[20];\r\n\r\nint calculate(vector&lt;int&gt; teamStart, vector&lt;int&gt; teamLink) {\r\n    int start = 0, link = 0;\r\n    for (int i = 0; i &lt; N / 2; i++) {\r\n        for (int j = 0; j &lt; N / 2; j++) {\r\n            if (i == j) continue;\r\n            start += status[teamStart[i]][teamStart[j]];\r\n            link += status[teamLink[i]][teamLink[j]];\r\n        }\r\n    }\r\n    return abs(start - link);\r\n}\r\n\r\nvoid find(int n, int c) {\r\n    if (n == N / 2) {\r\n        vector&lt;int&gt; teamStart, teamLink;\r\n        for (int i = 0; i &lt; N; i++) {\r\n            if (team[i]) teamStart.push_back(i);\r\n            else teamLink.push_back(i);\r\n        }\r\n        int result = calculate(teamStart, teamLink);\r\n        answer = answer &lt; result ? answer : result;\r\n    }\r\n    else {\r\n        for (int i = c; i &lt; N; i++) {\r\n            team[i] = true;\r\n            find(n + 1, i + 1);\r\n            team[i] = false;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; status[i][j];\r\n        }\r\n    }\r\n    find(0, 0);\r\n    cout &lt;&lt; answer;\r\n}','2020-11-19 18:20:02',272),(12161783,'BJ',14889,'\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint map[21][21];\r\nint team[21]; // s =0 , l =1 \r\nint ans = 99999999;\r\n\r\nvoid stats() {\r\n    int s_stats = 0;\r\n    int l_stats = 0;\r\n\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            if (i != j) {\r\n                if (team[i] == 0 && team[j] == 0) s_stats += map[i][j];\r\n                else if (team[i] == 1 && team[j] == 1) l_stats += map[i][j];\r\n            }\r\n        }\r\n    }\r\n\r\n    //스탯 계산\r\n    if (s_stats &gt; l_stats) {\r\n        if (ans &gt; (s_stats - l_stats)) ans = s_stats - l_stats;\r\n    }\r\n    else {\r\n        if (ans &gt; (l_stats - s_stats)) ans = l_stats - s_stats;\r\n    }\r\n}\r\n\r\nvoid sol(int index, int s) {\r\n    if (index &gt; N)return;\r\n\r\n    if (s == (N / 2)) {\r\n        stats();\r\n        return;\r\n    }\r\n\r\n    \r\n    team[index] = 0;//s팀\r\n    sol(index + 1, s + 1);\r\n\r\n    team[index] = 1;//l팀\r\n    sol(index + 1, s);\r\n\r\n}\r\n\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++) {\r\n        for (int j = 1; j &lt;= N; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    for (int i = 1; i &lt;= N; i++)team[i] = 1;\r\n\r\n    sol(1, 0);\r\n\r\n    cout &lt;&lt; ans;\r\n}','2020-11-20 20:30:12',273),(12181853,'BJ',14889,'#include &lt;iostream&gt;\r\n#include &lt;string.h&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n#define MAX 21\r\n\r\nint N; // 축구를 하기위해 모인 사람, 짝수\r\n// 각각의 사람들을 Start팀에 넣을지, Link팀에 넣을지 두 선택 & 사람은 N명 -&gt; 즉 경우의 수 2^N\r\nint S[MAX][MAX]; // 능력치\r\nconst int INF = 987654321;\r\nint result;\r\n\r\nvoid Start_AND_Link(string bit, int startTeam, int linkTeam)\r\n{\r\n    if (bit.size() == N)\r\n    {\r\n        vector&lt;int&gt; start, link;\r\n\r\n        for (int i = 0; i &lt; bit.length(); i++)\r\n        {\r\n            if (bit[i] == &#39;1&#39;) // Start팀인 사람은 True, Link팀인 사람은 False\r\n                start.push_back(i);\r\n            else\r\n                link.push_back(i);\r\n        }\r\n\r\n        int startSum = 0;\r\n\r\n        for (int i = 0; i &lt; start.size(); i++)\r\n        {\r\n            for (int j = i + 1; j &lt; start.size(); j++)\r\n            {\r\n                startSum += (S[start[i]][start[j]] + S[start[j]][start[i]]);\r\n            }\r\n        }\r\n\r\n        int linkSum = 0;\r\n\r\n        for (int i = 0; i &lt; link.size(); i++)\r\n        {\r\n            for (int j = i + 1; j &lt; link.size(); j++)\r\n            {\r\n                linkSum += (S[link[i]][link[j]] + S[link[j]][link[i]]);\r\n            }\r\n        }\r\n\r\n        result = min(result, abs(startSum - linkSum));\r\n\r\n        return;\r\n    }\r\n\r\n    if (startTeam &lt; (N / 2))\r\n        Start_AND_Link(bit + &quot;1&quot;, startTeam + 1, linkTeam);\r\n    if (linkTeam &lt; (N / 2))\r\n        Start_AND_Link(bit + &quot;0&quot;, startTeam, linkTeam + 1);\r\n\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; N; j++)\r\n        {\r\n            cin &gt;&gt; S[j][i];\r\n        }\r\n    }\r\n\r\n    result = INF;\r\n\r\n    Start_AND_Link(&quot;&quot;, 0, 0);\r\n\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n    \r\n    return 0;\r\n}','2020-11-20 20:23:42',274),(12181751,'BJ',14889,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n#define MAX 21\r\nint N;\r\nint N_N[MAX][MAX] = { 0 };\r\nvector&lt;int&gt; team_1;\r\nvector&lt;int&gt; team_2;\r\nint miN = 987654321;\r\n\r\nvoid check(int half)\r\n{\r\n    int sum1 = 0, sum2 = 0;\r\n    for (int i = 0; i &lt; half; i++)\r\n    {\r\n        for (int j = 0; j &lt; half; j++)\r\n        {\r\n            if (i == j)\r\n                continue;\r\n            sum1+=N_N[team_1[i]][team_1[j]];\r\n            sum2 += N_N[team_2[i]][team_2[j]];\r\n        }\r\n    }\r\n    if (miN &gt; abs(sum1 - sum2))\r\n        miN = abs(sum1 - sum2);\r\n}\r\nint there(int j)\r\n{\r\n    for (int i = 0; i &lt; team_1.size(); i++)\r\n    {\r\n        if (j == team_1[i])\r\n            return 0;\r\n    }\r\n    return 1;\r\n}\r\n \r\nvoid team(int start, int half, int cnt)\r\n{\r\n    for (int i = start + 1; i &lt;= N; i++)\r\n    {\r\n        if (cnt == half-1)\r\n        {\r\n            for (int j = 1; j &lt;= N; j++)\r\n            {\r\n                if (there(j))\r\n                    team_2.push_back(j);\r\n            }\r\n            /*for (int x = 0; x &lt; team_1.size(); x++)\r\n                cout &lt;&lt; team_1[x] &lt;&lt; &quot; &quot;;\r\n            cout &lt;&lt; endl;\r\n            for (int x = 0; x &lt; team_2.size(); x++)\r\n                cout &lt;&lt; team_2[x] &lt;&lt; &quot; &quot;;\r\n            cout &lt;&lt; endl;*/\r\n            check(half);\r\n            for (int f = 0; f &lt; half; f++)\r\n                team_2.pop_back(); \r\n            return;\r\n        }\r\n        else\r\n        {\r\n            if (team_1.back() &gt;= i)\r\n                continue;\r\n            team_1.push_back(i);\r\n            team(start+1, half, cnt + 1);\r\n            team_1.pop_back();\r\n        } \r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    scanf(&quot;%d&quot;, &N);\r\n    int half = N / 2;\r\n    for (int y = 1; y &lt;= N; y++)\r\n    {\r\n        for (int x = 1; x &lt;= N; x++)\r\n        {\r\n            scanf(&quot;%d&quot;, &N_N[y][x]);\r\n        }\r\n    }\r\n    for (int i = 1; i &lt;= half; i++)\r\n    {\r\n        team_1.push_back(i);\r\n        team(i, half, 0);\r\n        team_1.pop_back();\r\n    }\r\n    cout &lt;&lt; miN &lt;&lt; endl;\r\n}','2020-11-20 22:26:37',275),(12181751,'BJ',16234,'// dfs 느낌으로 풀려고 했어요 하지만 dfs가 잘 기억나지 않아서......\r\n// 예제에서 2*2만 맞고 3*3에서 바로 틀렸어요... \r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n#define MAX 2001\r\n\r\nstruct twin {\r\n    int x, y;\r\n};\r\n\r\nint N, L, R;\r\nint N_N[MAX][MAX] = { 0 };\r\nvector &lt;twin&gt; v;\r\nint sum = 0;\r\nint visit[MAX][MAX] = { 0 };\r\nint cnt = 1;\r\nint answer = 0;\r\n\r\nvoid Find(int start_x,int start_y )\r\n{\r\n \r\n    for (int y = start_y; y &lt; N; y++) \r\n    {\r\n        for (int x = start_x; x &lt; N; x++)\r\n        {\r\n            if (x != N-1 && abs(N_N[x][y] - N_N[x + 1][y]) &gt;= L && abs(N_N[x][y] - N_N[x + 1][y]) &lt;= R)\r\n            {\r\n                if (visit[x + 1][y] == 0)\r\n                {\r\n                    sum += N_N[x + 1][y];\r\n                    visit[x + 1][y] = 1;\r\n                    cnt++;\r\n                    //cout &lt;&lt; N_N[x + 1][y]&lt;&lt;&quot; &quot;;\r\n                    Find(x + 1, y);\r\n                }\r\n            }\r\n            if (y != N - 1 && abs(N_N[x][y] - N_N[x][y + 1]) &gt;= L && abs(N_N[x][y] - N_N[x][y + 1]) &lt;= R)\r\n            {\r\n                if (visit[x][y + 1] == 0)\r\n                {\r\n                    sum += N_N[x][y + 1];\r\n                    visit[x][y + 1] = 1;\r\n                    //cout &lt;&lt; N_N[x][y+1] &lt;&lt; &quot; &quot;;\r\n                    cnt++;\r\n                    Find(x, y + 1);\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\nint main() \r\n{\r\n    cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; N; j++)\r\n        {\r\n            cin &gt;&gt; N_N[j][i];//xy\r\n        }\r\n    }\r\n    sum += N_N[0][0];\r\n    while(1)\r\n    {\r\n        \r\n        cnt = 1;\r\n        Find(0, 0);\r\n        if (cnt == 1) break;\r\n        answer++;\r\n        for (int y = 0; y &lt; N; y++)\r\n        {\r\n            for (int x = 0; x &lt; N; x++)\r\n            {\r\n                if (visit[x][y] == 1)\r\n                    N_N[x][y] = sum / cnt;\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2020-11-20 22:29:10',276),(12181853,'BJ',16234,'// 코드 완성을 못했습니다,, 뒤에 인구이동을 다시 할 수 있는지 파악하는 접근방법을 모르겠어요,,\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;cstring&gt;\r\n#include &lt;cmath&gt;\r\nusing namespace std;\r\n\r\n#define MAX 50\r\n\r\nint N;\r\nint L;\r\nint R;\r\nint A[MAX][MAX];\r\n\r\nint dx[4] = { 0, 0, -1, 1 };\r\nint dy[4] = { 1, -1, 0, 0 };\r\n// Right -&gt; Left -&gt; Up -&gt; Down\r\n\r\nbool check[MAX][MAX] = { 0 };\r\nint flag;\r\n\r\nbool movement(int x, int y)\r\n{\r\n    bool boundary = false;\r\n    int population = A[x][y];\r\n    vector&lt;pair&lt;int, int&gt;&gt; Union;\r\n    // first : x, second : y\r\n    queue&lt;pair&lt;int, int&gt;&gt; Temp;\r\n    // first : x, second : y \r\n\r\n    Union.push_back({ x, y });\r\n    Temp.push({ x, y });\r\n\r\n    while (!Temp.empty())\r\n    {\r\n        x = Temp.front().first;\r\n        y = Temp.front().second;\r\n        Temp.pop();\r\n\r\n        for (int i = 0; i &lt; 4; i++)\r\n        {\r\n            int nx = x + dx[i];\r\n            int ny = y + dy[i];\r\n\r\n            if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= N)\r\n            {\r\n                continue;\r\n            }\r\n            if (check[nx][ny])\r\n            {\r\n                continue;\r\n            }\r\n            if (A[nx][ny] &gt; A[x][y])\r\n            {\r\n                if (L &lt;= (A[nx][ny] - A[x][y]) &lt;= R)\r\n                {\r\n                    Union.push_back({ nx, ny });\r\n                    Temp.push({ nx, ny });\r\n                    boundary = true;\r\n                    check[nx][ny] = true;\r\n                    population += A[nx][ny];\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (L &lt;= (A[x][y] - A[nx][ny]) &lt;= R)\r\n                {\r\n                    Union.push_back({ nx, ny });\r\n                    Temp.push({ nx, ny });\r\n                    boundary = true;\r\n                    check[nx][ny] = true;\r\n                    population += A[nx][ny];\r\n                }\r\n            }\r\n        }\r\n        population /= Union.size();\r\n        for (int i = 0; (unsigned)i &lt; Union.size(); i++)\r\n        {\r\n            A[Union[i].first][Union[i].second] = population;\r\n        }\r\n    }\r\n    return boundary;\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; N; j++)\r\n        {\r\n            cin &gt;&gt; A[i][j];\r\n        }\r\n    }\r\n\r\n    int Count = 0;\r\n    while (flag)\r\n    {\r\n        flag = true;\r\n        for (int i = 0; i &lt; N; i++)\r\n        {\r\n            for (int j = 0; j &lt; N; j++)\r\n            {\r\n                if (check[i][j] == 0 && movement(i, j) == 0)\r\n                {\r\n                    movement(i, j);\r\n                    flag = true;\r\n                }\r\n            }\r\n        }\r\n        if (flag == true)\r\n        {\r\n            Count++;\r\n        }\r\n        memset(check, false, sizeof(check));\r\n    }\r\n    cout &lt;&lt; Count &lt;&lt; endl;\r\n}','2020-11-21 13:00:51',277),(12161777,'BJ',16234,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;math.h&gt;\r\n\r\nusing namespace std;\r\nint N, L, R, m[51][51];\r\nbool border[51][51]; // 방문했었나?\r\nint dx[4] = { 0,0,1,-1 };\r\nint dy[4] = { 1,-1,0,0 };\r\n\r\nqueue&lt;pair&lt;int,int&gt;&gt; q;\r\nbool updated = false;\r\nint Sum = 0;\r\nvector&lt;pair&lt;int, int&gt;&gt; v;\r\nvoid bfs(pair&lt;int, int&gt; start) {\r\n    q.push(start);\r\n    border[start.first][start.second] = true;\r\n\r\n    while (!q.empty()) {\r\n        pair&lt;int, int&gt;cur = q.front();\r\n        q.pop();\r\n\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = cur.first + dx[i];\r\n            int ny = cur.second + dy[i];\r\n            if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N || border[nx][ny])\r\n                continue;\r\n            if (abs(m[nx][ny] - m[cur.first][cur.second]) &gt;= L && abs(m[nx][ny] - m[cur.first][cur.second]) &lt;= R) {\r\n                q.push({ nx,ny });\r\n                border[nx][ny] = true;\r\n                v.push_back({ nx,ny });\r\n                Sum += m[nx][ny];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid init() {\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++)\r\n            border[i][j] = 0;\r\n}\r\n\r\nint main() {                \r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++)\r\n            cin &gt;&gt; m[i][j];\r\n    int res = 0;\r\n    while (1) {\r\n        updated = false;\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; N; j++) {\r\n                if (!border[i][j]) {\r\n                    v.clear();\r\n                    v.push_back({ i,j });\r\n                    Sum = m[i][j];\r\n                    bfs({ i,j });\r\n                }\r\n                // 국경이 열린날\r\n                if (v.size() &gt;= 2) {  // 연합국가 개수\r\n                    updated = true;\r\n                    int val = Sum / v.size();\r\n                    for (int i = 0; i &lt; v.size(); i++) {\r\n                        m[v[i].first][v[i].second] = val;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (updated)res++;\r\n        else break;\r\n        init();\r\n    }\r\n    cout &lt;&lt; res &lt;&lt; endl;\r\n    return 0;\r\n}','2020-11-21 13:34:14',278),(12171820,'BJ',14889,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\n#define MAX_SIZE 21\r\n\r\nint n;\r\nbool is_used[MAX_SIZE];\r\nint s[MAX_SIZE][MAX_SIZE];\r\nint ans = 987654321;\r\n\r\nvoid Dfs(int curr_player, int cnt)\r\n{\r\n  \r\n    if (cnt == n / 2)\r\n    {\r\n        vector&lt;int&gt; team_link, team_start;\r\n\r\n      \r\n        for (int i = 0; i &lt; n; i++)\r\n        {\r\n            if (is_used[i]) team_start.push_back(i);\r\n            else team_link.push_back(i);\r\n        }\r\n\r\n        int stat_start = 0, stat_link = 0;\r\n        for (int i = 0; i &lt; team_start.size(); i++)\r\n        {\r\n            for (int j = i+1; j &lt; team_start.size(); j++)\r\n            {\r\n                int start_x = team_start[i], start_y = team_start[j];\r\n                int link_x = team_link[i], link_y = team_link[j];\r\n                stat_start += s[start_x][start_y] + s[start_y][start_x];\r\n                stat_link += s[link_x][link_y] + s[link_y][link_x];\r\n            }\r\n        }\r\n\r\n        ans = min(ans, abs(stat_start - stat_link));\r\n        return;\r\n    }\r\n\r\n\r\n    for (int i = curr_player+1; i &lt; n; i++)\r\n    {\r\n        if (is_used[i] == false)\r\n        {\r\n            is_used[i] = true;\r\n            Dfs(i, cnt + 1);\r\n            is_used[i] = false;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0); cout.tie(0);\r\n\r\n    cin &gt;&gt; n;\r\n\r\n\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        for (int j = 0; j &lt; n; j++)\r\n        {\r\n            cin &gt;&gt; s[i][j];\r\n        }\r\n    }\r\n\r\n    Dfs(0,0);\r\n\r\n    cout &lt;&lt; ans &lt;&lt; &quot;inha_univ&quot;;\r\n\r\n    return 0;\r\n}','2020-11-24 21:02:18',279),(12151601,'BJ',17263,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int N, a, answer = 0;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; a;\r\n        answer = a &gt; answer ? a : answer;\r\n    }\r\n    cout &lt;&lt; answer;\r\n}','2020-12-28 22:29:11',280),(12181751,'BJ',17263,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint n;\r\nint num[500001] = { 0 };\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        cin &gt;&gt; num[i];\r\n    }\r\n    int max = num[0];\r\n    for (int i = 1; i &lt; n; i++)\r\n    {\r\n        if (max &lt; num[i])\r\n            max = num[i];\r\n    }\r\n    cout &lt;&lt; max &lt;&lt; endl;\r\n}','2020-12-31 15:12:43',281),(12181751,'BJ',17266,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint road;\r\nint light;\r\nint position[100001] = { 0 };\r\nint last = 0;\r\nint Max = 0;\r\nint main()\r\n{\r\n    cin &gt;&gt; road &gt;&gt; light;\r\n    for (int i = 0; i &lt; light; i++)\r\n        cin &gt;&gt; position[i];\r\n    position[light] = road;\r\n    for (int i = 0; i &lt;= light; i++)\r\n    {\r\n        if (i == 0 || i == light)\r\n        {\r\n            if (Max &lt; position[i] - last)\r\n                Max = position[i] - last;\r\n        }\r\n        else\r\n        {\r\n            if ((position[i] - last) % 2 == 1)\r\n            {\r\n                if (Max &lt; (position[i] - last) / 2 + 1)\r\n                    Max = (position[i] - last) / 2 + 1;\r\n            }\r\n            else\r\n            {\r\n                if (Max &lt; (position[i] - last) / 2)\r\n                    Max = ((position[i] - last) / 2);\r\n            }\r\n        }\r\n        last = position[i];\r\n    }\r\n    cout &lt;&lt; Max &lt;&lt; endl;\r\n}','2021-01-10 16:47:04',282),(12181853,'BJ',17264,'#include &lt;iostream&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nint N; // 총 게임 횟수\r\nint P; // 해킹을 통해 얻은 플레이어의 수\r\nint W; // 이긴 경우 획득 점수\r\nint L; // 졌을 때 떨어지는 점수\r\nint G; // IRON 티어에서 벗어나기 위한 점수s\r\nstring Name[1001]; // 플레이어의 이름\r\nstring Player_Name[1001];\r\nchar Info[1001];\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; P;\r\n    cin &gt;&gt; W &gt;&gt; L &gt;&gt; G;\r\n    for (int i = 0; i &lt; P; i++)\r\n    {\r\n        cin &gt;&gt; Name[i] &gt;&gt; Info[i];\r\n    }\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; Player_Name[i];\r\n    }\r\n\r\n    int score = 0;\r\n    int flag = false;\r\n    int cnt = 0;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cnt = 0;\r\n        for (int j = 0; j &lt; P; j++)\r\n        {\r\n            if (Player_Name[i] == Name[j])\r\n            {\r\n                if (Info[j] == &#39;W&#39;)\r\n                {\r\n                    score += W;\r\n                }\r\n                else if (Info[j] == &#39;L&#39;) {\r\n                    score -= L;\r\n                }\r\n                if (score &lt; 0) score = 0;\r\n                if (score &gt;= G) flag = true;\r\n                break;\r\n            }\r\n            else if (Player_Name[i] != Name[j])\r\n            {\r\n                cnt++;\r\n            }\r\n\r\n            if (cnt == P)\r\n            {\r\n                score -= L;\r\n            }\r\n\r\n            if (score &lt; 0) score = 0;\r\n        }\r\n    }\r\n    if (flag)\r\n    {\r\n        printf(&quot;I AM NOT IRONMAN!!&quot;);\r\n        cout &lt;&lt; endl;\r\n    }\r\n    else\r\n    {\r\n        printf(&quot;I AM IRONMAN!!&quot;);\r\n        cout &lt;&lt; endl;\r\n    }\r\n\r\n    return 0;\r\n}','2021-01-02 16:00:02',283),(12181853,'BJ',17263,'//\r\n// Created by 홍지인 on 2021/01/02.\r\n//\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint A[500001];\r\n\r\nvector&lt;int&gt; sorting;\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; A[i];\r\n        sorting.push_back(A[i]);\r\n    }\r\n    sort(sorting.begin(), sorting.end());\r\n    cout &lt;&lt; sorting[N - 1];\r\n    return 0;\r\n}\r\n','2021-01-02 16:20:19',284),(12171820,'BJ',17263,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N;\r\n    int* a;\r\n    cin &gt;&gt; N;\r\n    a = new int[N];\r\n    int top = 0;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; a[i];\r\n        if (top &lt; a[i])\r\n        {\r\n            top = a[i];\r\n        }\r\n    }\r\n    cout &lt;&lt; top;\r\n}','2021-01-04 01:09:07',285),(12171820,'BJ',17264,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\n//첫 번째 줄에는 총 게임 횟수 N과 해킹을 통해 얻은 플레이어 정보의 수 P가 주어진다. (N과 P는 1, 000이하의 자연수)\r\n//\r\n//그리고 두 번째 줄에는 이긴 경우 획득 점수 W와 졌을 때 떨어지는 점수 L, 그리고 IRON 티어에서 벗어나기 위한 점수 G가 주어진다.  (0 ≤ W, L  ≤ 100, 1 ≤ G  ≤ 100, 000, 이 때, W, L, G는 정수)\r\n//\r\n//그리고 다음 P개의 줄에는 플레이어의 이름과 무조건 이길 수 있는 경우 W, 무조건 지는 경우 L이라는 단어가 플레이어 이름과 쌍으로 나온다.\r\n//\r\n//그리고 그 다음 N개의 줄에는 같이 게임을 하는 플레이어의 이름이 나온다.\r\n//\r\n//플레이어 이름은 반드시 대문자로 나오며 길이는 20이 넘지 않는다.\r\nstring player_name[1001];\r\n\r\nchar c[1001];\r\n\r\nstring name[1001];\r\nint main()\r\n{\r\n    int N; // 총 게임 횟수\r\n    int P; // 플레이어의 정보 수\r\n    int W; // 이긴순간 획득 점수\r\n    int L;//  진순간의 획득 점수\r\n    int G = 0; // 빠져나오기 위한 점수\r\n    cin &gt;&gt; N &gt;&gt; P;\r\n    cin &gt;&gt; W &gt;&gt; L &gt;&gt; G;\r\n    \r\n    \r\n    \r\n    for (int i = 0; i &lt; P; i++)\r\n    {\r\n        cin &gt;&gt; player_name[i] &gt;&gt; c[i];\r\n\r\n    }\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; name[i];\r\n    }\r\n    int sum = 0;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        if (G &lt;= sum)\r\n        {\r\n            cout &lt;&lt; &quot;I AM NOT IRONMAN&quot;;\r\n            break;\r\n        }\r\n        for (int j = 0; j &lt; P; j++)\r\n        {\r\n            \r\n            if (name[i] == player_name[j])\r\n            {\r\n                if (c[j] == &#39;W&#39;)\r\n                {\r\n                    sum += W;\r\n                    break;\r\n                }\r\n                else if (c[j] == &#39;L&#39;)\r\n                {\r\n                    sum -= L;\r\n                    if (sum &lt; 0)\r\n                    {\r\n                        sum = 0;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n            }\r\n            else if( j==P-1)\r\n            {\r\n                sum -= L;\r\n                if (sum &lt; 0)\r\n                {\r\n                    sum = 0;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (G &gt; sum)\r\n    {\r\n        cout &lt;&lt; &quot;I AM IRONMAN&quot;;\r\n    }\r\n\r\n}','2021-01-04 01:59:06',286),(12181751,'BJ',17264,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nstruct ha\r\n{\r\n    string name;\r\n    char info;\r\n};\r\n\r\nint game,player;\r\nint Win, Loose, Iron;\r\nha information[1001];\r\nstring play[1001];\r\nvector&lt;string&gt; can_win;\r\nint answer = 0;\r\nbool theend = false;\r\nint main()\r\n{\r\n    cin &gt;&gt; game &gt;&gt; player;\r\n    cin &gt;&gt; Win &gt;&gt; Loose &gt;&gt; Iron;\r\n    for (int i = 0; i &lt; player; i++)\r\n    {\r\n        cin &gt;&gt; information[i].name &gt;&gt; information[i].info;\r\n        if (information[i].info == &#39;W&#39;)\r\n            can_win.push_back(information[i].name);\r\n    }\r\n    bool check = false;\r\n    for (int i = 0; i &lt; game; i++)\r\n    {\r\n        cin &gt;&gt; play[i];\r\n        check = false;\r\n        for (int ww = 0; ww &lt; can_win.size(); ww++)\r\n        {\r\n            if (play[i] == can_win.at(ww))\r\n            {\r\n                answer += Win;\r\n                check = true;\r\n            }\r\n        }\r\n        if (check == false)\r\n        {\r\n            answer -= Loose;\r\n            if (answer &lt; 0)\r\n                answer = 0;\r\n        }\r\n        if (answer &gt;= Iron)\r\n        {\r\n            cout &lt;&lt; &quot;I AM NOT IRONMAN!!&quot; &lt;&lt; endl;\r\n            theend = true;\r\n            break;\r\n        }\r\n    }\r\n    if(!theend)\r\n        cout &lt;&lt; &quot;I AM IRONMAN!!&quot; &lt;&lt; endl;\r\n}','2021-01-04 18:08:15',287),(12181853,'BJ',17265,'//\r\n// Created by 홍지인 on 2021/01/02.\r\n//\r\n\r\n#define MAX 6\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n// 세현이는 자신의 집 (1, 1)에서 학교 (N, N)까지 최단 경로로 이동 -&gt; 오른쪽과 아래로만 이동 가능\r\n// 숫자 -&gt; 연산자 -&gt; 숫자 순\r\n// *, +, - 연산자만 주어짐\r\n\r\nint N;\r\nchar Road[MAX][MAX];\r\n// 순서대로 우 -&gt; 하\r\nint dx[] = {0, 1};\r\nint dy[] = {1, 0};\r\n\r\nint answer;\r\n\r\nint BIG = -1000000;\r\nint SMALL = 1000000;\r\n\r\nvoid solve(int x, int y, char op, int result)\r\n{\r\n    for (int i = 0; i &lt; 2; i++)\r\n    {\r\n        int nx = x + dx[i];\r\n        int ny = y + dy[i];\r\n\r\n        if (nx &lt; 1 || nx &gt; N || ny &lt; 1 || ny &gt; N) continue;\r\n\r\n        if (Road[nx][ny] == &#39;+&#39;)\r\n        {\r\n            solve(nx, ny, &#39;+&#39;, result);\r\n        }\r\n        else if (Road[nx][ny] == &#39;*&#39;)\r\n        {\r\n            solve(nx, ny, &#39;*&#39;, result);\r\n        }\r\n        else if (Road[nx][ny] == &#39;-&#39;)\r\n        {\r\n            solve(nx, ny, &#39;-&#39;, result);\r\n        }\r\n        else\r\n        {\r\n            if (op == &#39;+&#39;)\r\n            {\r\n                answer = result + (Road[nx][ny] - &#39;0&#39;);\r\n            }\r\n            else if (op == &#39;*&#39;)\r\n            {\r\n                answer = result * (Road[nx][ny] - &#39;0&#39;);\r\n            }\r\n            else if (op == &#39;-&#39;)\r\n            {\r\n                answer = result - (Road[nx][ny] - &#39;0&#39;);\r\n            }\r\n\r\n            if (nx == N && ny == N)\r\n            {\r\n                BIG = max(BIG, answer);\r\n                SMALL = min(SMALL, answer);\r\n                return;\r\n            }\r\n\r\n            solve(nx, ny, Road[nx][ny], answer);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        for (int j = 1; j &lt;= N; j++)\r\n        {\r\n            cin &gt;&gt; Road[i][j];\r\n        }\r\n    }\r\n\r\n    solve(1, 1, Road[1][1], Road[1][1] - &#39;0&#39;);\r\n\r\n    cout &lt;&lt; BIG &lt;&lt; &quot; &quot; &lt;&lt; SMALL;\r\n}','2021-01-04 19:15:15',288),(12181853,'BJ',17266,'//\r\n// Created by 홍지인 on 2021/01/04.\r\n//\r\n\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N; // 굴다리의 길이\r\nint M; // 가로등의 개\r\nint X; // 설치할 수 있는 가로등의 위치\r\n\r\nstruct Bridge\r\n{\r\n    int H;\r\n    int Flag = false; // 이전 가로등이 없을 경우 false\r\n};\r\n\r\nstruct Bridge B;\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    cin &gt;&gt; M;\r\n\r\n    while(M--)\r\n    {\r\n        cin &gt;&gt; X;\r\n        if (!B.Flag) // 처음 설치된 가로등이므로\r\n        {\r\n            B.Flag = X;\r\n            B.H = X;\r\n        }\r\n        else\r\n        {\r\n            B.H = max(B.H, (X - B.Flag + 1) / 2); // 이전 높이와 가로등 사이 높이의 절반과 비\r\n            B.Flag = X; // 다시 이전의 가로등 위치를 업데이트\r\n        }\r\n    }\r\n    B.H = max(B.H, N - X);\r\n\r\n    cout &lt;&lt; B.H &lt;&lt; endl;\r\n\r\n}','2021-01-04 20:19:12',289),(12151601,'BJ',17264,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;map&gt;\r\nusing namespace std;\r\n\r\nint main(){\r\n    int N, P, W, L, G, score = 0;\r\n    map&lt;string, char&gt; win;\r\n    string name;\r\n    bool iron = true;\r\n    char victory;\r\n    cin&gt;&gt;N&gt;&gt;P;\r\n    cin&gt;&gt;W&gt;&gt;L&gt;&gt;G;\r\n    for(int i=0;i&lt;P;i++){\r\n        cin&gt;&gt;name&gt;&gt;victory;\r\n        if(victory==&#39;W&#39;){\r\n            win[name] = victory;\r\n        }\r\n    }\r\n    for(int i=0;i&lt;N;i++){\r\n        if(!iron) continue;\r\n        cin&gt;&gt;name;\r\n        if(win[name]){\r\n            score += W;\r\n            if(score&gt;=G){\r\n                iron = false;\r\n            }\r\n        }\r\n        else {\r\n            score = score &gt; L ? score - L : 0;\r\n        }\r\n    }\r\n\r\n    if(iron) cout&lt;&lt;&quot;I AM IRONMAN!!&quot;;\r\n    else cout&lt;&lt;&quot;I AM NOT IRONMAN!!&quot;;\r\n    return 0;\r\n}','2021-01-04 20:46:17',290),(12151601,'BJ',17265,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint block[5][5];\r\nint N, maxres = -10000, minres = 10000;\r\n\r\nint dx[] = { 1,0 };\r\nint dy[] = { 0,1 };\r\n\r\nint calc(int res, int x, int y, int opr) {\r\n    int num = block[x][y];\r\n    switch (opr) {\r\n    case -5:\r\n        res += num;\r\n        break;\r\n    case -3:\r\n        res -= num;\r\n        break;\r\n    case -6:\r\n        res *= num;\r\n        break;\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid find(int x, int y, int res) {\r\n    if (x == N - 1 && y == N - 1) {\r\n        maxres = maxres &gt; res ? maxres : res;\r\n        minres = minres &lt; res ? minres : res;\r\n    }\r\n    else {\r\n        for (int i = 0; i &lt; 2; i++) {\r\n            int nx = x + dx[i], ny = y + dy[i];\r\n            if (nx &gt;= N || nx &lt; 0 || ny &gt;= N || ny &lt; 0) continue;\r\n            for (int j = 0; j &lt; 2; j++) {\r\n                int nnx = nx + dx[j], nny = ny + dy[j];\r\n                if (nnx &gt;= N || nnx &lt; 0 || nny &gt;= N || nny &lt; 0) continue;\r\n                find(nnx, nny, calc(res, nnx, nny, block[nx][ny]));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            char input;\r\n            cin &gt;&gt; input;\r\n            block[i][j] = input - &#39;0&#39;;\r\n        }\r\n    }\r\n\r\n    find(0, 0, block[0][0]);\r\n    cout &lt;&lt; maxres &lt;&lt; &#39; &#39; &lt;&lt; minres;\r\n}','2021-01-04 20:47:01',291),(12151601,'BJ',17266,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int N, M, answer;\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    int px = 0, nx, edgeDistance = 0, distance = 0;\r\n\r\n    for (int i = 0; i &lt; M; i++) {\r\n        cin &gt;&gt; nx;\r\n        if (i == 0) {\r\n            edgeDistance = edgeDistance &gt; nx ? edgeDistance : nx;\r\n            px = nx;\r\n        }\r\n        if (i == M - 1) {\r\n            edgeDistance = edgeDistance &gt; N - nx ? edgeDistance : N - nx;\r\n        }\r\n        distance = distance &gt; nx - px ? distance : nx - px;\r\n        px = nx;\r\n    }\r\n    answer = edgeDistance &gt; (distance + 1) / 2 ? edgeDistance : (distance + 1) / 2;;\r\n    cout &lt;&lt; answer;    \r\n}','2021-01-04 20:47:19',292),(12151601,'BJ',17267,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nstruct Yeongjo {\r\n    int x, y, l, r;\r\n};\r\n\r\nint map[1000][1000];\r\nint N, M, L, R, answer = 1;\r\nqueue&lt;Yeongjo&gt; land;\r\n\r\nvoid updown(Yeongjo yj) {\r\n    int nx = yj.x;\r\n    nx++;\r\n    while (map[nx][yj.y] == 0 && nx &lt; N) {\r\n        map[nx][yj.y] = 2;\r\n        land.push({ nx++, yj.y, yj.l, yj.r });\r\n        answer++;\r\n    }\r\n    nx = yj.x;\r\n    nx--;\r\n    while (map[nx][yj.y] == 0 && nx &gt;= 0) {\r\n        map[nx][yj.y] = 2;\r\n        land.push({ nx--, yj.y, yj.l, yj.r });\r\n        answer++;\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    cin &gt;&gt; L &gt;&gt; R;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            scanf(&quot;%1d&quot;, &map[i][j]);\r\n            if (map[i][j] == 2) {\r\n                land.push({ i,j,L,R });\r\n            }\r\n        }\r\n    }\r\n    while (!land.empty()) {\r\n        Yeongjo YJ = land.front();\r\n        land.pop();\r\n        updown(YJ);\r\n        if (YJ.y - 1 &gt;= 0 && YJ.l && map[YJ.x][YJ.y - 1] == 0) {\r\n            map[YJ.x][YJ.y - 1] = 2;\r\n            land.push({ YJ.x, YJ.y - 1, YJ.l - 1, YJ.r });\r\n            answer++;\r\n        }\r\n        if (YJ.y + 1 &lt; M && YJ.r && map[YJ.x][YJ.y + 1] == 0) {\r\n            map[YJ.x][YJ.y + 1] = 2;\r\n            land.push({ YJ.x, YJ.y + 1, YJ.l, YJ.r - 1 });\r\n            answer++;\r\n        }\r\n    }\r\n    cout &lt;&lt; answer;\r\n}','2021-01-04 20:47:41',293),(12181751,'BJ',17265,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint n;\r\nchar num[6][6];\r\nint ans[6][6] = { 0 };\r\nint minans[6][6] = { 0 };\r\nint dir_x[] = { 1,0};\r\nint dir_y[] = { 0,1 };\r\nvoid maxbfs(int x,int y)\r\n{\r\n    queue&lt;pair&lt;int, int&gt;&gt;q;\r\n    q.push({ y,x });\r\n    ans[0][0] = num[y][x] - &#39;0&#39;;\r\n    while(!q.empty())\r\n    {\r\n        int nowx = q.front().second; int nowy = q.front().first;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 2; i++)\r\n        {\r\n            int xx = nowx + dir_x[i]; int yy = nowy + dir_y[i];\r\n            if (xx &lt; 0 || yy &lt; 0 || xx &gt;= n || yy &gt;= n)\r\n                continue;\r\n            if (num[yy][xx] &gt;= 48 && num[yy][xx] &lt;= 57)\r\n            {\r\n                if (num[nowy][nowx] == &#39;+&#39;)\r\n                    ans[yy][xx] = ans[yy][xx] &gt; ans[nowy][nowx] + (num[yy][xx] - &#39;0&#39;) ? ans[yy][xx] : ans[nowy][nowx] + (num[yy][xx] - &#39;0&#39;);\r\n                else if (num[nowy][nowx] == &#39;-&#39;)\r\n                    ans[yy][xx] = ans[yy][xx] &gt; ans[nowy][nowx] - (num[yy][xx] - &#39;0&#39;) ? ans[yy][xx] : ans[nowy][nowx] - (num[yy][xx] - &#39;0&#39;);\r\n                else if (num[nowy][nowx] == &#39;*&#39;)\r\n                    ans[yy][xx] = ans[yy][xx] &gt; ans[nowy][nowx] * (num[yy][xx] - &#39;0&#39;) ? ans[yy][xx] : ans[nowy][nowx] * (num[yy][xx] - &#39;0&#39;);\r\n            }\r\n            else\r\n            {\r\n\r\n                ans[yy][xx] = ans[yy][xx]&gt;ans[nowy][nowx]?ans[yy][xx]:ans[nowy][nowx];\r\n            }\r\n            q.push({ yy,xx });\r\n        }\r\n\r\n    }\r\n}\r\n\r\nvoid minbfs(int x, int y)\r\n{\r\n    queue&lt;pair&lt;int, int&gt;&gt;q;\r\n    q.push({ y,x });\r\n    minans[0][0] = num[y][x] - &#39;0&#39;;\r\n    while (!q.empty())\r\n    {\r\n        int nowx = q.front().second; int nowy = q.front().first;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 2; i++)\r\n        {\r\n            int xx = nowx + dir_x[i]; int yy = nowy + dir_y[i];\r\n            if (xx &lt; 0 || yy &lt; 0 || xx &gt;= n || yy &gt;= n)\r\n                continue;\r\n            if (num[yy][xx] &gt;= 48 && num[yy][xx] &lt;= 57)\r\n            {\r\n                if (num[nowy][nowx] == &#39;+&#39;)\r\n                    minans[yy][xx] = minans[yy][xx] &lt; minans[nowy][nowx] + (num[yy][xx] - &#39;0&#39;) ? minans[yy][xx] : minans[nowy][nowx] + (num[yy][xx] - &#39;0&#39;);\r\n                else if (num[nowy][nowx] == &#39;-&#39;)\r\n                    minans[yy][xx] = minans[yy][xx] &lt; minans[nowy][nowx] - (num[yy][xx] - &#39;0&#39;) ? minans[yy][xx] : minans[nowy][nowx] - (num[yy][xx] - &#39;0&#39;);\r\n                else if (num[nowy][nowx] == &#39;*&#39;)\r\n                    minans[yy][xx] = minans[yy][xx] &lt; minans[nowy][nowx] * (num[yy][xx] - &#39;0&#39;) ? minans[yy][xx] : minans[nowy][nowx] * (num[yy][xx] - &#39;0&#39;);\r\n            }\r\n            else\r\n            {\r\n                    minans[yy][xx] = minans[yy][xx] &lt; minans[nowy][nowx] ? minans[yy][xx] : minans[nowy][nowx];\r\n            }\r\n            q.push({ yy,xx });\r\n        }\r\n\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    for (int y = 0; y &lt; n; y++)\r\n    {\r\n        for (int x = 0; x &lt; n; x++)\r\n        {\r\n            cin &gt;&gt; num[y][x];\r\n            minans[y][x] = 999999999;\r\n            ans[y][x] = -999999999;\r\n        }\r\n    }\r\n    maxbfs(0, 0);\r\n    minbfs(0, 0);\r\n    cout &lt;&lt; ans[n - 1][n - 1] &lt;&lt; &quot; &quot; &lt;&lt; minans[n - 1][n - 1] &lt;&lt; endl;\r\n\r\n}','2021-01-15 00:36:39',294),(12171820,'BJ',17266,'//틀렸습니다...\r\n\r\n#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n//\r\n//첫 번째 줄에 굴다리의 길이 N 이 주어진다. (1 ≤ N ≤ 100, 000)\r\n//\r\n//두 번째 줄에 가로등의 개수 M 이 주어진다. (1 ≤ M ≤ N)\r\n//\r\n//다음 줄에 M 개의 설치할 수 있는 가로등의 위치 x 가 주어진다. (0 ≤ x ≤ N)\r\n//\r\n//가로등의 위치 x는 오름차순으로 입력받으며 가로등의 위치는 중복되지 않으며, 정수이다.\r\nint load[100002];//굴다리의 밝음을 보관할 장소\r\nint Number[100001];//가로등의 위치들을 보관할 배열\r\nint N; //굴다리의 길이\r\nint M; //굴다리에 설치될 가로등의 개수\r\nint count_low(int i, int j)\r\n{\r\n    //높이가 i이고 j가 해당 배열을 찾을것\r\n    if (Number[j] - i &lt;= 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else\r\n        return (Number[j] - i);\r\n}\r\nint count_high(int i, int j)\r\n{\r\n    //높이가 i이고 j가 해당 배열을 찾을것\r\n    if ((Number[j] + i) &gt;= (N))\r\n    {\r\n        return N;\r\n    }\r\n    else\r\n        return (Number[j] + i);\r\n}\r\nint main()\r\n{\r\n    \r\n\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    int cnt = 0;\r\n    for (int i = 0; i &lt; M; i++)\r\n    {\r\n        cin &gt;&gt; Number[i];\r\n    }\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; M; j++)\r\n        {\r\n            for (int k = count_low(i, j); k &lt; count_high(i, j); k++)\r\n            {\r\n                load[k] += 1;\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; M; i++)\r\n        {\r\n            if (load[i] == 0)\r\n            {\r\n                cnt++;\r\n            }\r\n            \r\n        }\r\n        if (cnt != 0)\r\n        {\r\n            cnt = 0;\r\n        }\r\n        else if(cnt == 0)\r\n        {\r\n            cout &lt;&lt; i &lt;&lt; endl;\r\n            break;\r\n        }\r\n    }\r\n}','2021-01-04 21:10:04',295),(12151636,'BJ',1182,'from itertools import combinations\r\ndef check(combi,S):\r\n    cnt = 0\r\n    for i in combi:\r\n        if sum(list(i)) == S:\r\n            cnt = cnt + 1\r\n    return cnt\r\n\r\nword = input() #첫번째 줄\r\nsentence = input() #두번째 줄\r\narr = []\r\nN = int(word.split(&quot; &quot;)[0])\r\nS = int(word.split(&quot; &quot;)[1])\r\nfor i in range(N):\r\n    arr.append(int(sentence.split(&quot; &quot;)[i]))\r\ntotal = 0\r\nfor i in range(1,N+1):\r\n    combi = combinations(arr,i)\r\n    total_cnt = check(combi,S)\r\n    total = total + total_cnt\r\nprint(total)','2021-01-05 14:37:50',296),(12151636,'BJ',1987,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\nchar map[21][21];\r\nint alpha[26];\r\nint R, C;\r\nint total_cnt;\r\nint dx[] = { -1,1,0,0 };\r\nint dy[] = { 0,0,-1,1 };\r\nvoid check(int row,int col,int cnt) {\r\n    if (total_cnt &lt; cnt)\r\n        total_cnt = cnt;\r\n\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        int x = row + dx[i];\r\n        int y = col + dy[i];\r\n        if (x &gt;= 0 && x &lt; R && y &gt;= 0 && y &lt; C) {\r\n            if (alpha[map[x][y] - &#39;A&#39;] == 0) {\r\n                alpha[map[x][y] - &#39;A&#39;] = 1;\r\n                check(x, y, cnt + 1);\r\n                alpha[map[x][y] - &#39;A&#39;] = 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; R &gt;&gt; C;\r\n    for (int i = 0; i &lt; R; i++)\r\n        for (int j = 0; j &lt; C; j++)\r\n            cin &gt;&gt; map[i][j];\r\n    alpha[map[0][0] - &#39;A&#39;] = 1;\r\n    check(0,0,1);\r\n    cout &lt;&lt; total_cnt &lt;&lt; endl;\r\n}','2021-01-05 17:23:05',297),(12151636,'BJ',9095,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nint N;\r\nint cnt = 0;\r\nvoid check(int sum,int number) {\r\n    if (sum == number) {\r\n        cnt = cnt + 1;\r\n    }\r\n    else {\r\n        for (int i = 1; i &lt; 4; i++) {\r\n            if (sum + i &lt;= number) {\r\n                sum = sum + i;\r\n                check(sum, number);\r\n                sum = sum - i;\r\n            }\r\n        }\r\n    }\r\n}\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    vector&lt;int&gt; v;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        int number;\r\n        cin &gt;&gt; number;\r\n        v.push_back(number);\r\n    }\r\n    for (int i = 0; i &lt; v.size(); i++) {\r\n        cnt = 0;\r\n        check(0, v[i]);\r\n        cout &lt;&lt; cnt &lt;&lt; endl;\r\n    }\r\n}','2021-01-05 17:37:30',298),(12151601,'BJ',1182,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint N, S, num[20], answer;\r\n\r\nvoid find(int n, int sum) {\r\n    if (sum == S && n) answer++;\r\n    for (int i = n; i &lt; N; i++) {\r\n        find(i + 1, sum + num[i]);\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; S;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; num[i];\r\n    }\r\n    find(0, 0);\r\n    cout &lt;&lt; answer;\r\n}','2021-01-06 12:51:43',299),(12181751,'BJ',1182,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint N, S;\r\nint N_arr[21] = { 0 };\r\nint arr[200] = { 0 };\r\nint answer = 0;\r\nint index = -1;\r\nvoid re(int start,int cnt, int num)\r\n{\r\n    if (cnt == num)\r\n    {\r\n        int sum = 0;\r\n        index = -1;\r\n        for (int i = 1; i &lt;= num; i++)\r\n            sum += arr[i];\r\n        if (sum == S)\r\n            answer++;\r\n        return;\r\n    }\r\n    else \r\n    {\r\n        for (int i = start; i &lt; N; i++)\r\n        {\r\n            if (index == i)\r\n                continue;\r\n            arr[cnt+1] = N_arr[i];\r\n            index = i;\r\n            re(i, cnt + 1,num);\r\n        }\r\n\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; S;\r\n    for (int i = 0; i &lt; N; i++)\r\n        cin &gt;&gt; N_arr[i];\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        re(0, 0, i);\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2021-01-07 20:40:20',300),(12181751,'BJ',9095,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint T;\r\nint n[12] = { 0 };\r\nint answer[12] = { 0 };\r\nint last[12] = { 0 };\r\n\r\nvoid one_23(int go, int sum,int num,int cnt) {\r\n    if (sum &gt;= go)\r\n    {\r\n        if (sum == go)\r\n        {\r\n            answer[num]++;\r\n        }\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        for (int i = 3; i &gt;= 1; i--)\r\n        {\r\n            sum += i;\r\n            last[cnt] = i;\r\n            one_23(go, sum, num,cnt+1);\r\n            sum -= last[cnt];\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; T;\r\n    for (int i = 0; i &lt; T; i++)\r\n        cin &gt;&gt; n[i];\r\n    for (int i = 0; i &lt; T; i++)\r\n        one_23(n[i], 0, i,0);\r\n    for (int i = 0; i &lt; T; i++)\r\n        cout &lt;&lt; answer[i] &lt;&lt; endl;\r\n}','2021-01-08 02:48:40',302),(12151636,'BJ',12205,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint dp = 999999999;\r\nlong long load[100001];\r\nlong long prices[100001];\r\n\r\nint N;\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    long long sum = 0;\r\n    for (int i = 1; i &lt; N; i++)\r\n        cin &gt;&gt; load[i];\r\n    for (int i = 1; i &lt;= N; i++)\r\n        cin &gt;&gt; prices[i];\r\n    for (int i = 1; i &lt;=N-1; i++) {\r\n        if (dp &gt; prices[i])\r\n            dp = prices[i];\r\n        sum = sum + (load[i] * dp);\r\n    }\r\n    cout &lt;&lt; sum &lt;&lt; endl;\r\n}','2021-01-08 16:32:49',303),(12151636,'BJ',16234,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint map[101][101];\r\nint visit[101][101];\r\npair&lt;int, int&gt; calcul[10201]; //101 * 101\r\nint L, R, N, sum, cnt;\r\nint total_cnt = 0;\r\nint dx[] = { -1,1,0,0 };\r\nint dy[] = { 0,0,1,-1 };\r\n\r\nvoid dfs(int x, int y, int value) {\r\n    visit[x][y] = value;\r\n    sum = sum + map[x][y];\r\n    cnt = cnt + 1;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        int nextx = x + dx[i];\r\n        int nexty = y + dy[i];\r\n        if (nextx &gt;= 0 && nextx &lt; N && nexty &gt;= 0 && nexty &lt; N) {\r\n            if (abs(map[nextx][nexty] - map[x][y]) &gt;= L && abs(map[nextx][nexty] - map[x][y]) &lt;= R) {\r\n                if (visit[nextx][nexty] == 0)\r\n                    dfs(nextx, nexty, value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid cal(int value) {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            map[i][j] = (calcul[visit[i][j]].first) / (calcul[visit[i][j]].second);\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++)\r\n            cin &gt;&gt; map[i][j];\r\n    while (1) {\r\n        int value = 0;\r\n        for (int i = 0; i &lt; N; i++)\r\n            for (int j = 0; j &lt; N; j++)\r\n                visit[i][j] = 0;\r\n\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; N; j++) {\r\n                if (visit[i][j] == 0) {\r\n                    value = value + 1;\r\n                    cnt = 0;\r\n                    sum = 0;\r\n                    dfs(i, j, value);\r\n                    calcul[value] = make_pair(sum, cnt);\r\n                }\r\n            }\r\n        }\r\n        if (value == N*N)\r\n            break;\r\n        else {\r\n            total_cnt = total_cnt + 1;\r\n            cal(value);\r\n        }\r\n    }\r\n    cout &lt;&lt; total_cnt &lt;&lt;endl;\r\n\r\n}','2021-01-08 17:35:03',304),(12181751,'BJ',12205,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint city;\r\nlong long width[100001] = { 0 };\r\nlong long price[100001] = { 0 };\r\nint mins = 10000000001;\r\nlong long answer = 0;\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; city;\r\n    for (int i = 0; i &lt; city - 1; i++)\r\n        cin &gt;&gt; width[i];\r\n    for (int i = 0; i &lt; city; i++)\r\n    {\r\n        cin &gt;&gt; price[i];\r\n        if (mins &gt; price[i] && i != city-1)\r\n        {\r\n            mins = price[i];\r\n        }\r\n        answer += mins * width[i];\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n    return 0;\r\n}','2021-01-08 18:29:04',305),(12181751,'BJ',1987,'#define _CRT_SECURE_NO_WARNINGS\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint h, v;\r\nchar alpha[21][21];\r\nint dir_x[] = { -1,1,0,0 };\r\nint dir_y[] = { 0,0,-1,1 };\r\nint visited[30] = { 0 };\r\nint answer = 1;\r\nvoid recur(int nowy,int nowx,int ans)\r\n{\r\n    bool flag = false;\r\n    for (int i = 0; i &lt; 4; i++)\r\n    {\r\n        int x = dir_x[i] + nowx;\r\n        int y = dir_y[i] + nowy;\r\n        if (x &lt; 0 || x &gt;= h || y &lt; 0 || y &gt;= v)\r\n            continue;\r\n        if (visited[alpha[y][x] - 65] == 1)\r\n            continue;\r\n        flag = true;\r\n        visited[alpha[y][x] - 65] = 1;\r\n        ans += 1;\r\n        recur(y, x, ans);\r\n        flag = false;\r\n        ans -= 1;\r\n        visited[alpha[y][x] - 65] = 0;\r\n    }\r\n    if (!flag)\r\n    {\r\n        if (answer &lt; ans)\r\n            answer = ans;\r\n        return;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; v &gt;&gt; h;\r\n    for (int ver = 0; ver &lt; v; ver++)\r\n    {\r\n        scanf(&quot;%s&quot;,&alpha[ver]);\r\n        \r\n    }\r\n    visited[alpha[0][0] - 65] = 1;\r\n    recur(0, 0, 1);\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2021-01-09 13:33:33',306),(12151636,'BJ',17263,'#include &lt;iostream&gt;\r\nusing namespace std;\r\nint max_value = 0;\r\nint main(){\r\n    int N;\r\n    cin&gt;&gt;N;\r\n    for(int i = 0; i&lt;N; i++){\r\n        int number;\r\n        cin &gt;&gt;number;\r\n        if(number &gt; max_value)\r\n            max_value = number;\r\n    }\r\n    cout&lt;&lt;max_value&lt;&lt;endl;\r\n}','2021-01-10 15:40:22',307),(12151636,'BJ',17264,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nint N, P;\r\nvector&lt;pair&lt;string, char&gt;&gt; player;\r\nvector&lt;int&gt; scores;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; P;\r\n    int answer = 0;\r\n    bool flag = false;\r\n    for (int i = 0; i &lt; 3; i++) {\r\n        int score;\r\n        cin &gt;&gt; score;\r\n        scores.push_back(score);\r\n    }\r\n    for (int i = 0; i &lt; P; i++) {\r\n        string name;\r\n        char win;\r\n        cin &gt;&gt; name &gt;&gt; win;\r\n        player.push_back(make_pair(name, win));\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        string name;\r\n        cin &gt;&gt; name;\r\n        bool find = false;\r\n        for (int j = 0; j &lt; player.size(); j++) {\r\n            if (player[j].first == name) {\r\n                if (player[j].second == &#39;W&#39;)\r\n                    answer = answer + scores[0];\r\n                else {\r\n                    if (answer  &gt;= scores[1])\r\n                        answer = answer - scores[1];\r\n                    else\r\n                        answer = 0;\r\n                }\r\n                find = true;\r\n                break;\r\n            }\r\n        }\r\n        if (find == false) {\r\n            if (answer &gt;= scores[1])\r\n                answer = answer - scores[1];\r\n            else\r\n                answer = 0;\r\n        }\r\n        if (answer &gt;= scores[2])\r\n            flag = true;\r\n    }\r\n    if (flag == true)\r\n        cout &lt;&lt; &quot;I AM NOT IRONMAN!!&quot;;\r\n    else\r\n        cout &lt;&lt; &quot;I AM IRONMAN!!&quot;;\r\n}','2021-01-10 16:12:37',308),(12151636,'BJ',17266,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nint map[100001];\r\nint N, M, x;\r\nint pos = 0;\r\nint load = 0;\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; M; i++) {\r\n        cin &gt;&gt; x;\r\n        if (i == 0) {\r\n            if (load &lt; x - pos)\r\n                load = x - pos;\r\n        }\r\n        if (i == M - 1) {\r\n            if (load &lt; N - x)\r\n                load = N - x;\r\n        }\r\n        if ((x - pos) % 2 == 1) {\r\n            if (load &lt; ((x - pos) / 2) + 1)\r\n                load = ((x - pos) / 2) + 1;\r\n        }\r\n        else {\r\n            if (load &lt; ((x - pos) / 2))\r\n                load = ((x - pos) / 2);\r\n        }\r\n        pos = x;\r\n    }\r\n    cout &lt;&lt; load &lt;&lt; endl;\r\n}','2021-01-10 17:51:33',309),(12151636,'BJ',17265,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint max_array[6][6];\r\nint min_array[6][6];\r\nchar map[6][6];\r\nint N;\r\nint dx[] = { 1,0 };\r\nint dy[] = { 0,1 };\r\nstruct cal{\r\n    int x;\r\n    int y;\r\n};\r\nvoid max_bfs() {\r\n    queue&lt;cal&gt; q;\r\n    cal c;\r\n    c.x = 0; c.y = 0;\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++)\r\n            max_array[i][j] = -999999999;\r\n\r\n    q.push(c);\r\n    max_array[0][0] = map[0][0] - &#39;0&#39;;\r\n    while (!q.empty()) {\r\n        for (int i = 0; i &lt; 2; i++) {\r\n            int x = q.front().x + dx[i];\r\n            int y = q.front().y + dy[i];\r\n            if (x &gt;= 0 && x &lt; N && y &gt;= 0 && y &lt; N) {\r\n                if (map[x][y] == &#39;+&#39; || map[x][y] == &#39;-&#39; || map[x][y] == &#39;*&#39;) {\r\n                    if (max_array[x][y] &lt; max_array[q.front().x][q.front().y]) {\r\n                        max_array[x][y] = max_array[q.front().x][q.front().y];\r\n                        c.x = x; c.y = y;\r\n                        q.push(c);\r\n                    }\r\n                }\r\n                else {\r\n                    int value;\r\n                    if (map[q.front().x][q.front().y] == &#39;+&#39;)\r\n                        value = max_array[q.front().x][q.front().y] + (map[x][y] - &#39;0&#39;);\r\n                    else if (map[q.front().x][q.front().y] == &#39;-&#39;)\r\n                        value = max_array[q.front().x][q.front().y] - (map[x][y] - &#39;0&#39;);\r\n                    else if (map[q.front().x][q.front().y] == &#39;*&#39;)\r\n                        value = max_array[q.front().x][q.front().y] * (map[x][y] - &#39;0&#39;);\r\n                    if (max_array[x][y] &lt; value) {\r\n                        max_array[x][y] = value;\r\n                        c.x = x; c.y = y;\r\n                        q.push(c);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        q.pop();\r\n    }\r\n}\r\n\r\nvoid min_bfs() {\r\n    queue&lt;cal&gt; q;\r\n    cal c;\r\n    c.x = 0; c.y = 0;\r\n    q.push(c);\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++)\r\n            min_array[i][j] = 999999999;\r\n\r\n    min_array[0][0] = map[0][0] - &#39;0&#39;;\r\n    while (!q.empty()) {\r\n        for (int i = 0; i &lt; 2; i++) {\r\n            int x = q.front().x + dx[i];\r\n            int y = q.front().y + dy[i];\r\n            if (x &gt;= 0 && x &lt; N && y &gt;= 0 && y &lt; N) {\r\n                if (map[x][y] == &#39;+&#39; || map[x][y] == &#39;-&#39; || map[x][y] == &#39;*&#39;) {\r\n                    if (min_array[x][y] &gt; min_array[q.front().x][q.front().y]) {\r\n                        min_array[x][y] = min_array[q.front().x][q.front().y];\r\n                        c.x = x; c.y = y;\r\n                        q.push(c);\r\n                    }\r\n                }\r\n                else {\r\n                    int value;\r\n                    if (map[q.front().x][q.front().y] == &#39;+&#39;)\r\n                        value = min_array[q.front().x][q.front().y] + (map[x][y] - &#39;0&#39;);\r\n                    else if (map[q.front().x][q.front().y] == &#39;-&#39;)\r\n                        value = min_array[q.front().x][q.front().y] - (map[x][y] - &#39;0&#39;);\r\n                    else if (map[q.front().x][q.front().y] == &#39;*&#39;)\r\n                        value = min_array[q.front().x][q.front().y] * (map[x][y] - &#39;0&#39;);\r\n                    if (min_array[x][y] &gt; value) {\r\n                        min_array[x][y] = value;\r\n                        c.x = x; c.y = y;\r\n                        q.push(c);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        q.pop();\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; N; j++)\r\n            cin &gt;&gt; map[i][j];\r\n    max_bfs();\r\n    min_bfs();\r\n    cout &lt;&lt; max_array[N - 1][N - 1] &lt;&lt; &quot; &quot; &lt;&lt; min_array[N - 1][N - 1] &lt;&lt; endl;\r\n}','2021-01-10 18:34:19',310),(12181853,'BJ',1182,'//\r\n// Created by 홍지인 on 2021/01/04.\r\n//\r\n#include &lt;stdio.h&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;cstdio&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint S;\r\nint cnt = 0;\r\nint arr[20];\r\n\r\nvoid dfs(int Idx, int sum) {\r\n    if (Idx == N) return;\r\n    if (sum + arr[Idx] == S) cnt++;\r\n\r\n    dfs(Idx + 1, sum);\r\n    dfs(Idx + 1, sum + arr[i]);\r\n}\r\n\r\nint main() {\r\n\r\n    cin &gt;&gt; N &gt;&gt; S;\r\n    for (int i = 0; i &lt; N; i++) scanf(&quot;%d&quot;, &arr[i]);\r\n\r\n    dfs(0, 0);\r\n\r\n    cout &lt;&lt; cnt &lt;&lt; endl;\r\n\r\n    return 0;\r\n}\r\n','2021-01-10 23:11:42',311),(12181853,'BJ',1987,'//\r\n// Created by 홍지인 on 2021/01/10.\r\n//\r\n\r\n#define MAX 21\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint r;\r\nint c;\r\nchar board[MAX][MAX];\r\nbool Flag[26];\r\nint result;\r\n\r\nint dx[] = { 0, 0, 1, -1 };\r\nint dy[] = { 1, -1, 0, 0 };\r\n\r\nvoid moving(int x, int y, int cnt)\r\n{\r\n    result = max(result, cnt);\r\n\r\n    for (int i = 0; i &lt; 4; i++)\r\n    {\r\n        int nx = x + dx[i];\r\n        int ny = y + dy[i];\r\n\r\n        if (nx &lt; 0 || nx &gt;= r || ny &lt; 0 || ny &gt;= c) continue;\r\n\r\n        if (!Flag[board[nx][ny] - 65])\r\n        {\r\n            Flag[board[nx][ny] - 65] = true;\r\n            moving(nx, ny, cnt + 1);\r\n            Flag[board[nx][ny] - 65] = false;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; r &gt;&gt; c;\r\n\r\n    for (int i = 0; i &lt; r; i++)\r\n    {\r\n        for (int j = 0; j &lt; c; j++)\r\n        {\r\n            cin &gt;&gt; board[i][j];\r\n        }\r\n    }\r\n\r\n    Flag[board[0][0] - 65] = true;\r\n\r\n    moving(0, 0, 1);\r\n\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n\r\n}','2021-01-10 23:08:12',312),(12181751,'BJ',1914,'#include &lt;iostream&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nint n;\r\nlong long answer = 0;\r\nint ans[410] = { 0 };\r\nint index = 0;\r\n\r\nvoid recur(int num, int from, int use, int to)\r\n{\r\n    if (num == 1)\r\n    {\r\n        ans[index] = from;\r\n        index++;\r\n        ans[index] = to;\r\n        index++;\r\n    }\r\n    else {\r\n        recur(num - 1, from, to, use);\r\n        ans[index] = from;\r\n        index++;\r\n        ans[index] = to;\r\n        index++;\r\n        recur(num - 1, use, from, to);\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    if(n&lt;=20)\r\n        recur(n, 1, 2, 3);\r\n    answer = pow(n,2) - 1;\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n    if (n &lt;= 20)\r\n    {\r\n        for (int i = 0; i &lt; index; i += 2)\r\n            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[i + 1] &lt;&lt; endl;\r\n    }\r\n    return 0;\r\n}','2021-01-11 00:52:31',313),(12171820,'BJ',9095,'#include &lt;cstdio&gt;\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    int T, n, i, j, cnt;\r\n    int DP[11];\r\n\r\n    DP[1] = 1;\r\n    DP[2] = 2;\r\n    DP[3] = 4;\r\n\r\n    scanf(&quot;%d&quot;, &T);\r\n\r\n    for(i = 0; i &lt; T; i++) {\r\n        scanf(&quot;%d&quot;, &n);\r\n        for(j = 4; j &lt;= n; j++) {\r\n            DP[j] = DP[j-1] + DP[j-2] + DP[j-3];\r\n        }\r\n        printf(&quot;%dinha_univ&quot;, DP[n]);\r\n    }\r\n\r\n    return 0;\r\n}','2021-01-11 18:53:52',314),(12171820,'BJ',1182,'#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint N, S;\r\nint arr[20];\r\nint result = 0;\r\n\r\n \r\n\r\nvoid summ(int idx, int sum)\r\n\r\n{\r\n        sum += arr[idx]; \r\n\r\n\r\n        if (idx &gt;= N)\r\n                 return;\r\n\r\n  \r\n\r\n        if (sum == S)\r\n                 result++;\r\n\r\n \r\n        summ(idx + 1, sum - arr[idx]);\r\n\r\n\r\n       summ(idx + 1, sum);\r\n\r\n}\r\n\r\n \r\n\r\nint main(void)\r\n\r\n{\r\n        cin &gt;&gt; N &gt;&gt; S;\r\n \r\n        for (int i = 0; i &lt; N; i++)\r\n\r\n                 cin &gt;&gt; arr[i];\r\n\r\n \r\n        summ(0, 0);\r\n\r\n \r\n\r\n        cout &lt;&lt; result &lt;&lt; endl;\r\n\r\n        return 0;\r\n\r\n}','2021-01-11 23:08:56',315),(12181853,'BJ',9095,'//\r\n// Created by 홍지인 on 2021/01/11.\r\n//\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;stdio.h&gt;\r\nusing namespace std;\r\n\r\nint t;\r\nint n;\r\nint dp[11];\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; t;\r\n\r\n    dp[1] = 1;\r\n    dp[2] = 2;\r\n    dp[3] = 4;\r\n    dp[4] = 7;\r\n\r\n    for (int i = 0; i &lt; t; i++)\r\n    {\r\n        cin &gt;&gt; n;\r\n\r\n        for (int j = 5; j &lt;= n; j++)\r\n        {\r\n            dp[j] = dp[j - 1] + dp[j - 2] + dp[j - 3];\r\n        }\r\n        cout &lt;&lt; dp[n] &lt;&lt; endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n','2021-01-11 23:50:29',316),(12151601,'BJ',1914,'#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nint N;\r\n/*\r\n* 모든 경우를 전부 셀 경우 시간초과가 납니다. 2^100만큼 돌아야 하기 때문.\r\n*\r\nvoid loooongInt() {\r\n    bool flag = false;\r\n    for (int i = 3; i &gt;= 0; i--) {\r\n        if (!flag && cnt[i]) {\r\n            printf(&quot;%d&quot;, cnt[i]);\r\n            flag = true;\r\n            continue;\r\n        }\r\n        if(flag) printf(&quot;%09d&quot;, cnt[i]);\r\n    }\r\n}\r\n\r\nvoid move(int src, int route) {\r\n    cnt[0]++;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        if (cnt[i] && cnt[i] % tenten == 0) {\r\n            cnt[i + 1]++;\r\n            cnt[i] = 0;\r\n        }\r\n    }\r\n    if (N &lt;= 20) printf(&quot;%d %dinha_univ&quot;, src, route);\r\n}\r\n*/\r\n\r\nvoid hanoi(int n, int src, int route, int dest) {\r\n    if (n == 1) {\r\n        printf(&quot;%d %dinha_univ&quot;, src, dest);\r\n        //move(src, dest);\r\n    }\r\n    else {\r\n        hanoi(n - 1, src, dest, route);\r\n        printf(&quot;%d %dinha_univ&quot;, src, dest);\r\n        //move(src, dest);\r\n        hanoi(n - 1, route, src, dest);\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    string answer = to_string(pow(2, N));\r\n    answer = answer.substr(0, answer.find(&quot;.&quot;));\r\n    answer[answer.length() - 1] -= 1;\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n    if (N &lt;= 20) hanoi(N, 1, 2, 3);\r\n}','2021-01-12 00:02:54',317),(12151601,'BJ',1987,'#include &lt;iostream&gt;\r\n#include &lt;map&gt;\r\n\r\nusing namespace std;\r\n\r\nint R, C, answer;\r\nchar board[20][20];\r\nbool visit[20][20];\r\nmap&lt;char, bool&gt; havebeen;\r\n\r\nint dx[] = { 0, 1, 0, -1 };\r\nint dy[] = { -1, 0, 1, 0 };\r\n\r\nvoid find(int x, int y, int cnt) {\r\n    answer = cnt &gt; answer ? cnt : answer;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        int nx = x + dx[i], ny = y + dy[i];\r\n        if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue;\r\n        if (visit[nx][ny] || havebeen[board[nx][ny]]) continue;\r\n        visit[nx][ny] = havebeen[board[nx][ny]] = true;\r\n        find(nx, ny, cnt + 1);\r\n        visit[nx][ny] = havebeen[board[nx][ny]] = false;\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; R &gt;&gt; C;\r\n    for (int i = 0; i &lt; R; i++) {\r\n        scanf(&quot;%s&quot;, board[i]);\r\n    }\r\n    visit[0][0] = havebeen[board[0][0]] = true;\r\n    find(0, 0, 1);\r\n    cout &lt;&lt; answer;\r\n}\r\n\r\n','2021-01-12 00:03:37',318),(12171820,'BJ',1914,'#include &lt;iostream&gt; \r\n#include &lt;cstdio&gt;  \r\n#include &lt;cmath&gt; \r\n#include &lt;string&gt; \r\nusing namespace std;\r\nvoid HanoiTower(int num, int from, int by, int to) \r\n{ \r\n        if (num == 1)\r\n            cout &lt;&lt; from &lt;&lt; &quot; &quot; &lt;&lt; to &lt;&lt; endl;\r\n        else\r\n{         HanoiTower(num - 1, from, to, by); \r\n        cout &lt;&lt; from &lt;&lt; &quot; &quot; &lt;&lt; to&lt;&lt; endl;\r\n         HanoiTower(num - 1, by, from, to);\r\n} \r\n} int main(void)\r\n{\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    int answer = pow(2, N);\r\n    cout &lt;&lt; (answer-1)&lt;&lt; endl; \r\n    if (N &lt;= 20)\r\n        HanoiTower(N, 1, 2, 3);\r\n\r\n\r\n\r\n\r\n    return 0;\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n    \r\n\r\n','2021-01-12 00:03:43',319),(12151601,'BJ',9095,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint main() {\r\n    int T, n, i = 3;\r\n    int d[11] = { 1, 2, 4 };\r\n    cin &gt;&gt; T;\r\n    while (T--) {\r\n        cin &gt;&gt; n;\r\n        if (n &gt; i) {\r\n            for (int j = i; j &lt; n; j++, i++) {\r\n                d[i] = d[i - 1] + d[i - 2] + d[i - 3];\r\n            }\r\n        }\r\n        cout &lt;&lt; d[n - 1] &lt;&lt; endl;\r\n    }\r\n}','2021-01-12 00:03:55',320),(12151601,'BJ',12205,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nlong long oil[100000], road[100000], answer = 0;\r\n\r\nint main(){\r\n    int N;\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N - 1; i++) {\r\n        cin &gt;&gt; road[i];\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; oil[i];\r\n    }\r\n    int cheap = 2000000000;\r\n    for (int i = 0; i &lt; N - 1; i++) {\r\n        if(cheap &gt; oil[i]) cheap = oil[i];\r\n        answer += road[i] * cheap;\r\n    }\r\n    cout&lt;&lt;answer;\r\n}','2021-01-12 00:04:09',321),(12181853,'BJ',12205,'//\r\n// Created by 홍지인 on 2021/01/11.\r\n//\r\n\r\n#define MAX 100002\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;cstdio&gt;\r\nusing namespace std;\r\n\r\nlong long dist[MAX];\r\nlong long point[MAX];\r\nlong long sub;\r\nlong long base;\r\nlong long result;\r\n\r\nint n;\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n\r\n    for (int i = 0; i &lt; n - 1; i++)\r\n    {\r\n        cin &gt;&gt; dist[i];\r\n    }\r\n\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        cin &gt;&gt; point[i];\r\n    }\r\n\r\n    base = point[0];\r\n    sub = dist[0];\r\n\r\n    for (int i = 1; i &lt; n; i++)\r\n    {\r\n        if (point[i] &lt;= base)\r\n        {\r\n            result += base * sub;\r\n            base = point[i];\r\n            sub = dist[i];\r\n        }\r\n        else\r\n        {\r\n            sub += dist[i];\r\n        }\r\n    }\r\n\r\n    if (sub)\r\n    {\r\n        result += base * sub;\r\n    }\r\n\r\n    cout &lt;&lt; result &lt;&lt; endl;\r\n\r\n    return 0;\r\n}\r\n','2021-01-12 00:30:24',322),(12181853,'BJ',1914,'//\r\n// Created by 홍지인 on 2021/01/10.\r\n//\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint N;\r\nint K;\r\n\r\nvector&lt;pair&lt;int, int&gt;&gt; v;\r\n\r\nvoid Hanoi(int n, int from, int by, int to)\r\n{\r\n    if (n == 1)\r\n        v.push_back(make_pair(from, to));\r\n    else\r\n    {\r\n        Hanoi(n - 1, from, to, by);\r\n        v.push_back(make_pair(from, to));\r\n        Hanoi(n - 1, by, from, to);\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n\r\n    Hanoi(N, 1, 2, 3);\r\n\r\n    cout &lt;&lt; v.size() &lt;&lt; endl;\r\n\r\n    for (int i = 0; i &lt; v.size(); i++)\r\n    {\r\n        cout &lt;&lt; v[i].first &lt;&lt; v[i].second &lt;&lt; endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n','2021-01-12 01:11:21',323),(12151636,'BJ',15683,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nint dx[] = { -1,1,0,0 };\r\nint dy[] = { 0,0,1,-1 };\r\nint camera2[2][2] = { {0,1},{2,3} }; //cctv2의 궤도를 dx dy의 index를 이용하여 만듬.\r\nint camera3[4][2] = { {0,2},{2,1},{3,1},{0,3} }; //cctv3의 궤도를 dx dy의 index를 이용하여 만듬.\r\nint camera4[4][3] = { {0,2,3},{0,1,2},{1,2,3},{0,1,3} }; //cctv4의 궤도를 dx dy의 index를 이용하여 만듬.\r\nint map[8][8];\r\nint temp[8][8]; //map을 저장할 배열\r\nvector&lt;pair&lt;int, int&gt;&gt; v; //cctv의 위치 정보를 저장할 vector\r\nint N, M, camera;\r\nint max_value;\r\nvoid search(int cnt) {\r\n    if (cnt == camera) { //모든 cctv의 상태를 지정해뒀을 때 빈 공간 확인\r\n        int count = 0;\r\n        for (int i = 0; i &lt; N; i++)\r\n            for (int j = 0; j &lt; M; j++) {\r\n                if (temp[i][j] == 0)\r\n                    count = count + 1;\r\n            }\r\n        if (count &lt; max_value)\r\n            max_value = count;\r\n        return;\r\n    }\r\n    else {\r\n        int tmp[8][8]; //전의 상태를 저장하기 위한 배열\r\n        for (int index1 = 0; index1 &lt; N; index1++)\r\n            for (int index2 = 0; index2 &lt; M; index2++)\r\n                tmp[index1][index2] = temp[index1][index2]; //tmp 배열에 temp를 복사하여 최신 상태를 갱신\r\n\r\n        int i = v[cnt].first; //cctv의 x좌표\r\n        int j = v[cnt].second; //cctv의 y좌표\r\n        if (temp[i][j] == 1) { //1번 cctv일 때\r\n            for (int k = 0; k &lt; 4; k++) {\r\n                int nx = i + dx[k];\r\n                int ny = j + dy[k];\r\n                while (1) {\r\n                    if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= M || map[nx][ny] == 6)  //벽이거나 map을 넘어가면 break\r\n                        break;\r\n                    if ( map[nx][ny] == 0) //그렇지 않으면 계속 진행\r\n                        temp[nx][ny] = -1;\r\n                    nx = nx + dx[k];\r\n                    ny = ny + dy[k];\r\n                }\r\n                search(cnt + 1);\r\n                for (int index1 = 0; index1 &lt; N; index1++)\r\n                    for (int index2 = 0; index2 &lt; M; index2++)\r\n                        temp[index1][index2] = tmp[index1][index2];  //temp에 tmp 정보를 copy하여 그 전 상태로 돌리기\r\n            }\r\n        }\r\n        else if (temp[i][j] == 2) { //2번 cctv일 때\r\n            for (int k = 0; k &lt; 2; k++) {\r\n                for (int l = 0; l &lt; 2; l++) {\r\n                    int nx = i + dx[camera2[k][l]];\r\n                    int ny = j + dy[camera2[k][l]];\r\n                    while (1) {\r\n                        if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= M || map[nx][ny] == 6)\r\n                            break;\r\n                        if (map[nx][ny] == 0)\r\n                            temp[nx][ny] = -1;\r\n                        nx = nx + dx[camera2[k][l]];\r\n                        ny = ny + dy[camera2[k][l]];\r\n                    }\r\n                }\r\n                search(cnt + 1);\r\n                for (int index1 = 0; index1 &lt; N; index1++)\r\n                    for (int index2 = 0; index2 &lt; M; index2++)\r\n                        temp[index1][index2] = tmp[index1][index2];\r\n            }\r\n        }\r\n        else if (temp[i][j] == 3) { //3번 cctv일 때\r\n            for (int k = 0; k &lt; 4; k++) {\r\n                for (int l = 0; l &lt; 2; l++) {\r\n                    int nx = i + dx[camera3[k][l]];\r\n                    int ny = j + dy[camera3[k][l]];\r\n                    while (1) {\r\n                        if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= M || map[nx][ny] == 6)\r\n                            break;\r\n                        if (map[nx][ny] == 0)\r\n                            temp[nx][ny] = -1;\r\n                        nx = nx + dx[camera3[k][l]];\r\n                        ny = ny + dy[camera3[k][l]];\r\n                    }\r\n                }\r\n                search(cnt + 1);\r\n                for (int index1 = 0; index1 &lt; N; index1++)\r\n                    for (int index2 = 0; index2 &lt; M; index2++)\r\n                        temp[index1][index2] = tmp[index1][index2];\r\n            }\r\n\r\n        }\r\n        else if (temp[i][j] == 4) { //4번 cctv일 때\r\n            for (int k = 0; k &lt; 4; k++) {\r\n                for (int l = 0; l &lt; 3; l++) {\r\n                    int nx = i + dx[camera4[k][l]];\r\n                    int ny = j + dy[camera4[k][l]];\r\n                    while (1) {\r\n                        if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= M || map[nx][ny] == 6)\r\n                            break;\r\n                        if (map[nx][ny] == 0)\r\n                            temp[nx][ny] = -1;\r\n                        nx = nx + dx[camera4[k][l]];\r\n                        ny = ny + dy[camera4[k][l]];\r\n                    }\r\n                }\r\n                search(cnt + 1);\r\n                for (int index1 = 0; index1 &lt; N; index1++)\r\n                    for (int index2 = 0; index2 &lt; M; index2++)\r\n                        temp[index1][index2] = tmp[index1][index2];\r\n            }\r\n        }\r\n        else if (temp[i][j] == 5) { //5번 cctv일 때\r\n            for (int k = 0; k &lt; 4; k++) {\r\n                int nx = i + dx[k];\r\n                int ny = j + dy[k];\r\n                while (1) {\r\n                    if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= M || map[nx][ny] == 6)\r\n                        break;\r\n                    if (map[nx][ny] == 0)\r\n                        temp[nx][ny] = -1;\r\n                    nx = nx + dx[k];\r\n                    ny = ny + dy[k];\r\n                }\r\n            }\r\n            search(cnt + 1);\r\n            for (int index1 = 0; index1 &lt; N; index1++)\r\n                for (int index2 = 0; index2 &lt; M; index2++)\r\n                    temp[index1][index2] = tmp[index1][index2];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    max_value = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            cin &gt;&gt; map[i][j];\r\n            temp[i][j] = map[i][j];\r\n            if (map[i][j] &gt; 0 && map[i][j] &lt; 6) {\r\n                camera = camera + 1; //cctv의 갯수\r\n                v.push_back(make_pair(i, j)); //cctv의 위치 정보 저장\r\n            }\r\n            if (map[i][j] == 0)\r\n                max_value = max_value + 1;\r\n        }\r\n    }\r\n    search(0);\r\n    cout &lt;&lt; max_value &lt;&lt; endl;\r\n}','2021-01-16 01:02:16',324),(12151636,'BJ',3055,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nstruct position {\r\n    int x;\r\n    int y;\r\n    int days;\r\n};\r\nint visit[51][51];\r\nchar map[51][51];\r\nqueue&lt;position&gt; water;\r\nqueue&lt;position&gt; animal;\r\nint N, M, final_x, final_y;\r\nint dx[] = { -1,1,0,0 };\r\nint dy[] = { 0,0,1,-1 };\r\nvoid bfs() {\r\n    int cnt = -1;\r\n    int flag = false;\r\n    while (1) {\r\n        //물 움직이기\r\n        while(1) {\r\n            if (water.size() == 0)\r\n                break;\r\n            if (water.front().days != cnt) \r\n//날짜가 다를 때까지 진행하기 위해서 cnt 변수가 필요 ex) 1일을 통해 물이 찬 영역을 전부 pop하기 위함(2일차 때 찬 애들은 cnt가 2일 때 처리)\r\n                break;\r\n            int water_x = water.front().x;\r\n            int water_y = water.front().y;\r\n            int water_cnt = water.front().days;\r\n            water.pop();\r\n            for (int i = 0; i &lt; 4; i++) {\r\n                int nwater_x = water_x + dx[i];\r\n                int nwater_y = water_y + dy[i];\r\n                if (nwater_x &gt;= 0 && nwater_y &gt;= 0 && nwater_x &lt; N && nwater_y &lt; M && visit[nwater_x][nwater_y] != -1 && visit[nwater_x][nwater_y] != -2) {\r\n                    if (nwater_x != final_x || nwater_y != final_y) {\r\n                        visit[nwater_x][nwater_y] = -1;\r\n                        position p;\r\n                        p.x = nwater_x; p.y = nwater_y; p.days = water_cnt + 1;\r\n                        water.push(p);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //고슴도치 움직이기\r\n        while (1) {\r\n            if (animal.size() == 0) {\r\n                flag = true;\r\n                break;\r\n            }\r\n            if (animal.front().days != cnt)\r\n//날짜가 다를 때까지 진행하기 위해서 cnt 변수가 필요 ex) 1일을 통해 고슴도치의 영역을 전부 pop하기 위함(2일차 때 애들은 cnt가 2일 때 처리)\r\n                break;\r\n            int animal_x = animal.front().x;\r\n            int animal_y = animal.front().y;\r\n            int animal_cnt = animal.front().days;\r\n            animal.pop();\r\n            for (int i = 0; i &lt; 4; i++) {\r\n                int nanimal_x = animal_x + dx[i];\r\n                int nanimal_y = animal_y + dy[i];\r\n                if (nanimal_x &gt;= 0 && nanimal_y &gt;= 0 && nanimal_x &lt; N && nanimal_y &lt; M) {\r\n                    if (visit[nanimal_x][nanimal_y] == 0) {\r\n                        visit[nanimal_x][nanimal_y] = animal_cnt + 1; //기존 시간에  +1 해서 이동한 위치에 저장\r\n                        position p;\r\n                        p.x = nanimal_x; p.y = nanimal_y; p.days = animal_cnt + 1;\r\n                        animal.push(p);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        cnt = cnt + 1; //날짜 지나기\r\n        if (flag == true)\r\n            break;\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++)\r\n        for (int j = 0; j &lt; M; j++) {\r\n            position p;\r\n            cin &gt;&gt; map[i][j];\r\n            if (map[i][j] == &#39;*&#39;) {\r\n                p.x = i; p.y = j; p.days = 0;\r\n                visit[i][j] = -1;\r\n                water.push(p);\r\n            }\r\n            else if (map[i][j] == &#39;S&#39;) {\r\n                p.x = i; p.y = j; p.days = 0;\r\n                visit[i][j] = 1;\r\n                animal.push(p);\r\n            }\r\n            else if (map[i][j] == &#39;D&#39;) {\r\n                final_x = i;\r\n                final_y = j;\r\n            }\r\n            else if (map[i][j] == &#39;X&#39;)\r\n                visit[i][j] = -2;\r\n        }\r\n    bfs();\r\n    if (visit[final_x][final_y] == 0)\r\n        cout &lt;&lt; &quot;KAKTUS&quot; &lt;&lt; endl;\r\n    else\r\n        cout &lt;&lt; visit[final_x][final_y] &lt;&lt; endl;\r\n}','2021-01-14 16:20:57',325),(12181751,'BJ',3055,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n\r\nusing namespace std;\r\nstruct hel {\r\n    int y, x, num;\r\n};\r\nint n, m;\r\nchar nest[51][51];\r\nint answer[51][51];\r\nint visited[51][51] = { 0 };\r\nqueue&lt;hel&gt;q;\r\nint dir_x[] = { -1,1,0,0 };\r\nint dir_y[] = { 0,0,-1,1 };\r\nint ans = 0;\r\nint last = 2;\r\nint bfs()\r\n{\r\n    int nowx = 0; int nowy = 0;\r\n    while (!q.empty())\r\n    {\r\n        int num = q.front().num;\r\n        if (last &lt; num)//고슴도치가 갈곳을 다 가면 즉 저 밑의 for문을 다 돌면 원래 자기 자신을 .으로\r\n            nest[nowy][nowx] = &#39;.&#39;;\r\n        nowx = q.front().x; nowy = q.front().y; \r\n        last = num;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 4; i++)\r\n        {\r\n            int x = nowx + dir_x[i]; int y = nowy + dir_y[i];\r\n            if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n)\r\n                continue;\r\n            if (nest[y][x] == &#39;X&#39;|| nest[y][x]==&#39;*&#39;)\r\n                continue;\r\n            if (num == 2 && nest[y][x] == &#39;D&#39;)\r\n                continue;\r\n            else if (num == 1 && nest[nowy][nowx] == &#39;*&#39;)\r\n                continue;\r\n            \r\n            if (num==1)//고슴도치 이동시\r\n            {\r\n                if (visited[y][x] == 0)\r\n                {\r\n                    visited[y][x] = 1;\r\n                    answer[y][x] = answer[y][x] &gt; answer[nowy][nowx] + 1 ? answer[nowy][nowx] + 1 : answer[y][x];//최소값 찾기\r\n                    if (nest[nowy][nowx]==&#39;S&#39; && nest[y][x] == &#39;D&#39;)//목적지 도착시 return true\r\n                        return true;\r\n                    nest[y][x] = &#39;S&#39;;\r\n                    q.push({ y,x,1 });\r\n                }\r\n            }\r\n            else if (num==2)\r\n            {\r\n                if (visited[y][x] == 1 || visited[y][x] == 0)\r\n                {\r\n                    visited[y][x] = 2;\r\n                    nest[y][x] = &#39;*&#39;;\r\n                    q.push({ y,x,2 });\r\n\r\n                }\r\n            }\r\n            \r\n        }\r\n    }\r\n    return false;\r\n}\r\nint main()\r\n{\r\n    cin &gt;&gt; n &gt;&gt; m;\r\n    for (int y = 0; y &lt; n; y++)\r\n    {\r\n        for (int x = 0; x &lt; m; x++)\r\n        {\r\n            cin &gt;&gt; nest[y][x];\r\n            answer[y][x] = 999999999;\r\n            if (nest[y][x] == &#39;S&#39;)//q에 고슴도치 먼저 이동할 수 있도록 한다\r\n            {\r\n                q.push({ y,x,1 });\r\n                answer[y][x] = 0;\r\n                visited[y][x] = 1;\r\n            }\r\n        }\r\n    }\r\n    int dx=0, dy=0;\r\n    for (int y = 0; y &lt; n; y++)\r\n    {\r\n        for (int x = 0; x &lt; m; x++)\r\n        {\r\n            if (nest[y][x] == &#39;*&#39;)//물이 고슴도치 이동 후에 움직이도록 한다.\r\n            {\r\n                q.push({ y,x,2 });\r\n                visited[y][x] = 2;\r\n            }\r\n            if (nest[y][x] == 68)//목적지 그냥 찾을 라고\r\n            {\r\n                dx = x; dy = y;\r\n            }\r\n        }\r\n    }\r\n    if (bfs())\r\n        cout &lt;&lt; answer[dy][dx] &lt;&lt; endl;\r\n    else\r\n        cout &lt;&lt; &quot;KAKTUS&quot; &lt;&lt; endl;\r\n\r\n}','2021-01-16 02:13:52',326),(12151601,'BJ',15683,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\n\r\nint N, M, answer = 100, room[8][8];\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\nvector&lt;pair&lt;int, int&gt;&gt; cctv;\r\n\r\nvoid copy(int from[][8], int to[][8]) {\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            to[i][j] = from[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint count() {\r\n    int cnt = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            if (room[i][j] == 0) cnt++;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\nvoid monitor(int x, int y, int direction) {\r\n    direction %= 4;\r\n    while (1) {\r\n        x += dx[direction], y += dy[direction];\r\n        if (x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M) return;\r\n        if (room[x][y] == 6) return;\r\n        if (room[x][y] == 0) room[x][y] = -1;\r\n    }\r\n}\r\n\r\nvoid camera(int n, int direction) {\r\n    int x = cctv[n].first, y = cctv[n].second;\r\n    switch (room[x][y]) {\r\n    case 1:\r\n        monitor(x, y, direction);\r\n        break;\r\n    case 2:\r\n        monitor(x, y, direction);\r\n        monitor(x, y, direction + 2);\r\n        break;\r\n    case 3:\r\n        monitor(x, y, direction);\r\n        monitor(x, y, direction + 1);\r\n        break;\r\n    case 4:\r\n        monitor(x, y, direction);\r\n        monitor(x, y, direction + 1);\r\n        monitor(x, y, direction + 3);\r\n        break;\r\n    case 5:\r\n        monitor(x, y, direction);\r\n        monitor(x, y, direction + 1);\r\n        monitor(x, y, direction + 2);\r\n        monitor(x, y, direction + 3);\r\n        break;\r\n    }\r\n}\r\n\r\nvoid find(int n) {\r\n    if (n == cctv.size()) {\r\n        answer = min(count(), answer);\r\n    }\r\n    else {\r\n        int copy_room[8][8];\r\n        copy(room, copy_room);\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            camera(n, i);\r\n            find(n + 1);\r\n            copy(copy_room, room);\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            cin &gt;&gt; room[i][j];\r\n            if (room[i][j] != 0 && room[i][j] != 6) cctv.push_back({ i,j });\r\n        }\r\n    }\r\n    find(0);\r\n    cout &lt;&lt; answer;\r\n}','2021-01-17 16:07:03',327),(12151601,'BJ',3273,'#include &lt;iostream&gt;\r\n#include &lt;bitset&gt;\r\nusing namespace std;\r\n\r\nbitset&lt;1000001&gt; bit;\r\nint n, answer, a[100000], x;\r\n\r\nint main() {\r\n    cin.tie(NULL);\r\n    ios::sync_with_stdio(false);\r\n\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        cin &gt;&gt; a[i];\r\n        bit.set(a[i]);\r\n    }\r\n    cin &gt;&gt; x;\r\n    for (int i = 0; i &lt; n; i++) {\r\n        int num = x - a[i];\r\n        if (num &lt;= 0 || num &gt; 100000) continue;\r\n        if (bit[num]) answer++;\r\n    }\r\n    cout &lt;&lt; answer / 2;\r\n}','2021-01-17 16:48:24',328),(12181751,'BJ',3273,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint n;\r\nint number[100001] = {0};\r\nint num;\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; n; i++)\r\n        cin &gt;&gt; number[i];\r\n    cin &gt;&gt; num;\r\n    sort(number, number + n);\r\n    int answer = 0; \r\n    int left = 0; int right = n - 1;\r\n\r\n    while(left&lt;right)\r\n    {\r\n        if (number[left] + number[right] == num)\r\n        {\r\n            answer++;\r\n            right--;\r\n        }\r\n        else if (number[left] + number[right] &gt; num)\r\n        {\r\n             right--;\r\n        }\r\n        else if(number[left]+number[right] &lt; num)\r\n        {\r\n            left++;\r\n        }\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2021-01-17 21:41:41',329),(12181751,'BJ',2470,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\nint n;\r\nlong long num[100001] = { 0 };\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        cin &gt;&gt; num[i];\r\n    }\r\n    sort(num, num + n);\r\n    int left = 0; int right = n - 1;\r\n    long long sum = 0; long long min = 9999999999;\r\n    long long answer1 = 0,answer2 = 0;\r\n    bool check = false;\r\n    while (left &lt; right)\r\n    {\r\n        sum = num[left] + num[right];\r\n        if (min &gt; abs(sum-0))\r\n        {\r\n            min = abs(sum);\r\n            answer1 = num[left];\r\n            answer2 = num[right];\r\n        }\r\n        if (sum - 0 &gt; 0 )\r\n            right--;\r\n        else if (sum - 0 &lt; 0)\r\n            left++;\r\n        else if (sum - 0 == 0)\r\n            break;\r\n    }\r\n    cout &lt;&lt; answer1 &lt;&lt; &quot; &quot; &lt;&lt; answer2&lt;&lt;endl;\r\n}','2021-01-18 00:14:29',330),(12181751,'BJ',1600,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nstruct go {\r\n    int y, x, cnt, horse;\r\n};\r\nint k, w,h;\r\nint num[201][201] = { 0 };\r\nint horse_x[] = { -2,-1, 1, 2,-2,-1,1,2 };\r\nint horse_y[] = { -1,-2,-2,-1,1,2,2,1 };\r\nint monkey_x[] = { -1,1,0,0 };\r\nint monkey_y[] = { 0,0,-1,1 };\r\nint visited[201][201][201] = { 0 };\r\n\r\nvoid bfs()\r\n{\r\n    queue&lt;go&gt; q;\r\n    q.push({ 0,0 ,0,0});//y,x,cnt(목적지까지 가면서 들린 경로),horse(내가 사용한 말 수)\r\n    //어떤거는 말로 갈 수도 원숭이로도 갈 수 가 있으니까\r\n    while (!q.empty())\r\n    {\r\n        int nowx = q.front().x; int nowy = q.front().y; int Cnt = q.front().cnt; int Horse = q.front().horse;\r\n        q.pop();\r\n        if (nowx == w - 1 && nowy == h - 1)\r\n        {\r\n            cout &lt;&lt; Cnt &lt;&lt; endl;//그냥 가장 먼저 도착하는 경우에서 cnt출력하고 return(가장 최단경로가 됨)\r\n            return;\r\n        }\r\n\r\n        if (Horse &lt; k)//말로 가는 경우\r\n        {\r\n            for (int i = 0; i &lt; 8; i++)\r\n            {\r\n                int x = nowx + horse_x[i]; int y = nowy + horse_y[i];\r\n                if (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h)\r\n                    continue;\r\n                if (num[y][x] == 1)\r\n                    continue;\r\n                if (visited[y][x][Horse+1] == 1)//내가 지금 q에 집어넣을 사용한 horse가 같은 경우가 visited라면 q에 넣으면 중복됨\r\n                    continue;\r\n                visited[y][x][Horse+1] = 1;\r\n                q.push({ y,x,Cnt + 1,Horse + 1 });\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; 4; i++)//말로 갔든 말든 원숭이로는 언제든 갈 수 있으니까 원숭이로 가는 경우\r\n        {\r\n            int x = nowx + monkey_x[i]; int y = nowy + monkey_y[i];\r\n            if (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h)\r\n                continue;\r\n            if (num[y][x] == 1)\r\n                continue;\r\n            if (visited[y][x][Horse] == 1)\r\n                continue;\r\n            visited[y][x][Horse] = 1;\r\n            q.push({ y,x,Cnt + 1,Horse});\r\n        }\r\n        if (q.empty())\r\n            cout &lt;&lt; -1 &lt;&lt; endl;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; k;\r\n    cin &gt;&gt; w &gt;&gt; h;\r\n    for (int y = 0; y &lt; h; y++)\r\n        for (int x = 0; x &lt; w; x++)\r\n            cin &gt;&gt; num[y][x];\r\n\r\n    bfs();\r\n}','2021-01-19 16:29:56',331),(12181751,'BJ',15683,'//아직 못...하겠...\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nstruct xynum {\r\n   int y, x, num;\r\n};\r\nint n, m;\r\nchar cam[9][9];\r\nint visited[9][9] = { 0 };\r\nvector&lt;pair&lt;int, int&gt;&gt; v;\r\nvector &lt;xynum&gt; arr[12871];\r\nint index = 0;\r\nvoid solve(int start ,int cnt)\r\n{\r\n   cout &lt;&lt;index&lt;&lt;&quot; &quot;&lt;&lt; cnt &lt;&lt; endl;\r\n   if (cnt != 0 && arr[index].size()==v.size())\r\n   {\r\n      for (int i = 0; i&lt;arr[index].size(); i++)\r\n         //arr[index + 1].push_back(arr[index].at(i));\r\n      index++;\r\n      return;\r\n   }\r\n   for (int i = start; i &lt; v.size(); i++)\r\n   {\r\n      int y = v.at(i).first; int x = v.at(i).second;\r\n   \r\n      if (cam[y][x] == 49 || cam[y][x] == 51 || cam[y][x] == 52)\r\n      {\r\n         \r\n         for (int j = 1; j &lt;= 4; j++)\r\n         {\r\n            arr[index].push_back({ y,x,j });\r\n            solve(i+1,cnt+1);\r\n            if (arr[index].empty() && index - 1 &gt;= 0)\r\n            {\r\n               for (int k = 0; k &lt; arr[index - 1].size(); k++)\r\n               {\r\n                  if (arr[index - 1].at(k).y == y && arr[index - 1].at(k).x==x)\r\n                     break;\r\n                  else\r\n                     arr[index].push_back(arr[index - 1].at(k));\r\n               }\r\n            }\r\n         }\r\n         return;\r\n      }\r\n      else if (cam[y][x] == 50)\r\n      {\r\n         for (int j = 1; j &lt;= 2; j++)\r\n         {\r\n            arr[index].push_back({ y,x,j });\r\n\r\n            solve(i+1,cnt + 1);\r\n            if (arr[index].empty() && index - 1 &gt;= 0)\r\n            {\r\n               for (int k = 0; k &lt; arr[index - 1].size(); k++)\r\n               {\r\n                  if (arr[index - 1].at(k).y == y && arr[index - 1].at(k).x==x)\r\n                     break;\r\n                  else\r\n                     arr[index].push_back(arr[index - 1].at(k));\r\n               }\r\n            }\r\n         }\r\n         return;\r\n      }\r\n      else if (cam[y][x] == 53)\r\n      {\r\n         arr[index].push_back({ y,x,1 });\r\n\r\n         solve(i+1,cnt + 1);\r\n         if (arr[index].empty()&&index - 1 &gt;= 0)\r\n         {\r\n            for (int k = 0; k &lt; arr[index - 1].size(); k++)\r\n            {\r\n               if (arr[index - 1].at(k+1).y == y && arr[index - 1].at(k+1).x == x)\r\n                  break;\r\n               else\r\n                  arr[index].push_back(arr[index - 1].at(k));\r\n            }\r\n         }\r\n      }\r\n      return;\r\n   }\r\n   \r\n}\r\n\r\nint main()\r\n{\r\n   cin &gt;&gt; n &gt;&gt; m;\r\n   for (int y = 0; y &lt; n; y++)\r\n   {\r\n      for (int x = 0; x &lt; m; x++)\r\n      {\r\n         cin &gt;&gt; cam[y][x];\r\n         if(cam[y][x] &gt;= 49 && cam[y][x] &lt;= 53)\r\n            v.push_back({ y,x });\r\n      }\r\n   }\r\n   //cout &lt;&lt; v.size() &lt;&lt; endl;\r\n   solve(0,0);\r\n   for (int j = 0; j &lt; index; j++)\r\n   {\r\n      for (int i = 0; i &lt; arr[j].size(); i++)\r\n         cout &lt;&lt; arr[j].at(i).y &lt;&lt; &quot; &quot; &lt;&lt; arr[j].at(i).x &lt;&lt; &quot; &quot; &lt;&lt; arr[j].at(i).num &lt;&lt; endl;\r\n      cout &lt;&lt; endl;\r\n   }\r\n}','2021-01-18 23:02:15',332),(12151601,'BJ',2470,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint N, value[100000], answer;\r\nint minsum = 2111111111;\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        cin &gt;&gt; value[i];\r\n    }\r\n    sort(value, value + N);\r\n\r\n    int i = 0, j = N - 1;\r\n    pair&lt;int, int&gt; minpair;\r\n    while (i != j) {\r\n        int small = value[i], big = value[j];\r\n        int sum = abs(big + small);\r\n        if (sum &lt; minsum) {\r\n            minpair = { value[i], value[j] };\r\n            minsum = sum;\r\n        }\r\n\r\n        int left = abs(small), right = abs(big);\r\n        if (left &gt; right) i++;\r\n        else if (left &lt; right) j--;\r\n        else if (left == right) {\r\n            if (value[i] == -value[j]) {\r\n                minpair = { value[i], value[j] };\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; minpair.first &lt;&lt; &quot; &quot; &lt;&lt; minpair.second;\r\n}','2021-01-19 21:06:52',333),(12151601,'BJ',3055,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint R, C, answer, destx, desty;\r\nint forest[50][50];\r\n\r\nqueue&lt;pair&lt;int, int&gt;&gt; water, hedgehog;\r\n\r\n\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\n\r\nvoid bfs(queue&lt;pair&lt;int, int&gt;&gt; &q, bool flood, int n) {\r\n    while (!q.empty()) {\r\n        int x = q.front().first, y = q.front().second;\r\n        if ((flood && forest[x][y] &lt; -n - 1) || (!flood && forest[x][y] &gt; n)) return;\r\n        q.pop();\r\n        \r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = x + dx[i], ny = y + dy[i];\r\n            if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue;\r\n            if (flood) {\r\n                if (nx == destx && ny == desty) continue;\r\n                if (forest[nx][ny] &gt;= 0) {\r\n                    forest[nx][ny] = -n - 2;\r\n                    q.push({ nx, ny });\r\n                }\r\n            }\r\n            else {\r\n                \r\n                if (forest[nx][ny] == 0) {\r\n                    forest[nx][ny] = n + 1;\r\n                    if (nx == destx && ny == desty) return;\r\n                    q.push({ nx, ny });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid toBeaver() {\r\n    int n = 1;\r\n    while (!hedgehog.empty() && !forest[destx][desty]) {\r\n        bfs(water, true, n);\r\n        bfs(hedgehog, false, n);\r\n        n++;\r\n    }\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n\r\n    cin &gt;&gt; R &gt;&gt; C;\r\n    char* str = new char[C];\r\n\r\n    for (int i = 0; i &lt; R; i++) {\r\n        cin &gt;&gt; str;\r\n        for (int j = 0; j &lt; C; j++) {\r\n            if (str[j] == &#39;D&#39;) destx = i, desty = j;\r\n            else if (str[j] == &#39;*&#39;) {\r\n                water.push({ i,j });\r\n                forest[i][j] = -2;\r\n            }\r\n            else if (str[j] == &#39;X&#39;) forest[i][j] = -1;\r\n            else if (str[j] == &#39;S&#39;) {\r\n                hedgehog.push({ i,j });\r\n                forest[i][j] = 1;\r\n            }\r\n        }\r\n    }\r\n    toBeaver();\r\n    if (forest[destx][desty] &gt; 0) cout &lt;&lt; forest[destx][desty] - 1;\r\n    else cout &lt;&lt; &quot;KAKTUS&quot;;\r\n}','2021-01-19 21:07:51',334),(12151601,'BJ',1600,'// 맨 밑에있는 입력 오답\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint K, W, H, answer;\r\nint board[200][200];\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\nint horsedx[] = { -2, -1, 1, 2, 2, 1, -1, -2 };\r\nint horsedy[] = { 1, 2, 2, 1, -1, -2, -2, -1 };\r\n\r\n\r\n\r\nstruct status {\r\n    int k, x, y;\r\n};\r\n\r\nbool outOfRange(int x, int y) {\r\n    return (x &lt; 0 || x &gt;= H || y &lt; 0 || y &gt;= W) || (board[x][y] == -1);\r\n}\r\n\r\nvoid bfs() {\r\n    queue&lt;status&gt; monkey;\r\n    monkey.push({ K,0,0 });\r\n    while (!monkey.empty()) {\r\n        status cur = monkey.front();\r\n        monkey.pop();\r\n        int k = cur.k, y = cur.y, x = cur.x;\r\n        int nx, ny;\r\n        if (k) {\r\n            for (int i = 0; i &lt; 8; i++) {\r\n                nx = x + horsedx[i], ny = y + horsedy[i];\r\n                if (outOfRange(nx, ny)) continue;\r\n                if (board[nx][ny]==0) {\r\n                    monkey.push({ k - 1, nx, ny });\r\n                    board[nx][ny] = board[x][y] + 1;\r\n                }\r\n                else if (board[nx][ny] &gt;= board[x][y] + 1) {\r\n                    monkey.push({ k - 1, nx, ny });\r\n                    board[nx][ny] = board[x][y] + 1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i &lt; 4; i++) {\r\n                nx = x + dx[i], ny = y + dy[i];\r\n                if (outOfRange(nx, ny)) continue;\r\n                if (board[nx][ny] == 0) {\r\n                    monkey.push({ k, nx, ny });\r\n                    board[nx][ny] = board[x][y] + 1;\r\n                }\r\n                else if (board[nx][ny] &gt;= board[x][y] + 1) {\r\n                    monkey.push({ k, nx, ny });\r\n                    board[nx][ny] = board[x][y] + 1;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n\r\n    cin &gt;&gt; K;\r\n    cin &gt;&gt; W &gt;&gt; H;\r\n    for (int i = 0; i &lt; H; i++) {\r\n        for (int j = 0; j &lt; W; j++) {\r\n            cin &gt;&gt; board[i][j];\r\n            if (board[i][j]) board[i][j] != board[i][j];\r\n        }\r\n    }\r\n    bfs();\r\n    if (board[H - 1][W - 1])\r\n        cout &lt;&lt; board[H - 1][W - 1];\r\n    else cout &lt;&lt; -1;\r\n}\r\n\r\n/*\r\n\r\n1\r\n4 4\r\n0 1 1 1\r\n0 1 1 1\r\n0 0 1 1\r\n1 1 1 0\r\n\r\n*/','2021-01-19 21:11:46',335),(12181853,'BJ',3273,'//\r\n// Created by 홍지인 on 2021/01/19.\r\n//\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;stdlib.h&gt;\r\nusing namespace std;\r\n\r\nint n;\r\nint x;\r\nint a[100001];\r\nint sum = 0;\r\n\r\nint find(int num) {\r\n    int i = 0;\r\n    int j = n;\r\n\r\n    while (i &lt; j) {\r\n        int mid = (i + j) / 2;\r\n\r\n        if (a[mid] &lt; num) i = mid + 1;\r\n        else if (a[mid] &gt; num) j = mid - 1;\r\n        else return 1;\r\n    }\r\n\r\n    if (a[i] == num) return 1;\r\n\r\n    return 0;\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; n;\r\n\r\n    for (int i = 0; i &lt; n; i++) {\r\n        cin &gt;&gt; a[i];\r\n    }\r\n\r\n    cin &gt;&gt; x;\r\n\r\n    sort(a, a + n);\r\n\r\n    for (int i = 0; i &lt; n; i++) {\r\n        if (a[i] * 2 == x) continue; // 서로 다른 양의 정수이므로\r\n        sum += find(x - a[i]);\r\n    }\r\n\r\n    cout &lt;&lt; sum / 2 &lt;&lt; endl;\r\n\r\n    return 0;\r\n}\r\n','2021-01-19 21:55:58',336),(12181853,'BJ',2470,'//\r\n// Created by 홍지인 on 2021/01/19.\r\n//\r\n\r\n#define MAX 100000\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint n;\r\nint idx1;\r\nint idx2;\r\nlong long minim;\r\nlong long liquid[MAX];\r\nlong long sum;\r\n\r\nvoid two_liquid(void)\r\n{\r\n    int i = 0;\r\n    int j = n - 1;\r\n\r\n    while (i &lt; j)\r\n    {\r\n        sum = liquid[i] + liquid[j];\r\n        if (llabs(sum) &lt; minim) {\r\n            minim = llabs(sum);\r\n\r\n            idx1 = i;\r\n            idx2 = j;\r\n        }\r\n\r\n        if (sum &lt; 0) i++;\r\n        else j--;\r\n    }\r\n    cout &lt;&lt; liquid[idx1] &lt;&lt; &quot; &quot; &lt;&lt; liquid[idx2] &lt;&lt; endl;\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; n;\r\n\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        cin &gt;&gt; liquid[i];\r\n    }\r\n\r\n    sort(liquid, liquid + n);\r\n\r\n    minim = 9999999999;\r\n\r\n    two_liquid();\r\n\r\n    return 0;\r\n}\r\n\r\n','2021-01-19 23:08:29',337),(12181751,'BJ',2468,'#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\nint n;\r\nint num[101][101] = { 0 };\r\nint dir_x[] = { 0,0,-1,1 };\r\nint dir_y[] = { -1,1,0,0 };\r\nint maxans = 0;\r\nbool visited[101][101] = { 0 };\r\nvoid bfs(int starty,int startx,int N)\r\n{\r\n    queue&lt;pair&lt;int, int&gt;&gt; q;\r\n    q.push({ starty,startx });\r\n    visited[starty][startx] = true;\r\n    while (!q.empty())\r\n    {\r\n        int nowx = q.front().second; int nowy = q.front().first;\r\n\r\n        q.pop();\r\n        for (int i = 0; i &lt; 4; i++)\r\n        {\r\n            int x = nowx + dir_x[i]; int y = nowy + dir_y[i];\r\n            if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= n || visited[y][x]==true)\r\n                continue;\r\n            if (num[y][x] &lt;= N)\r\n                continue;\r\n            visited[y][x] = true;\r\n            q.push({ y,x });\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    for (int y = 0; y &lt; n; y++)\r\n    {\r\n        for (int x = 0; x &lt; n; x++)\r\n        {\r\n            cin &gt;&gt; num[y][x];\r\n            maxans = maxans &lt; num[y][x] ? num[y][x] : maxans;\r\n        }\r\n    }\r\n    int answer = 0; int last = 0;\r\n    for (int i = 0; i &lt;=maxans ; i++)//0부터 num배열의 max값 까지 다 돌려보면서 해당 값 미만의 경우로 하나하나 확인해봄\r\n    {\r\n        last = 0;\r\n        for (int y = 0; y &lt; n; y++)\r\n        {\r\n            for (int x = 0; x &lt; n; x++)\r\n            {\r\n                visited[y][x] = false;\r\n            }\r\n        }\r\n        for (int y = 0; y &lt; n; y++)\r\n        {\r\n            for (int x = 0; x &lt; n; x++)\r\n            {\r\n                if (num[y][x] &lt;= i || visited[y][x]==true)\r\n                    continue;\r\n                bfs(y, x, i);\r\n                last++;\r\n            }\r\n        }\r\n        answer = answer &gt; last ? answer : last;\r\n    }\r\n    cout &lt;&lt; answer &lt;&lt; endl;\r\n}','2021-01-22 16:19:49',338),(12171820,'BJ',1806,'// 시간초과가 뜹니다...ㅠ\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\n// 첫째 줄에 N(10 ≤ N &lt; 100, 000)과 S(0 &lt; S ≤ 100, 000, 000)가 주어진다.\r\n//    둘째 줄에는 수열이 주어진다.수열의 각 원소는 공백으로 구분되어져 있으며, 10, 000이하의 자연수이다.\r\n\r\nint N; // 들어갈 숫자\r\nint S; //이것보다 커야 count\r\nlong long num[100001]; // 숫자가 들어갈 배열로 10000보다 작아야함\r\nlong long dp[100001]; // 각 수의 위치에서 가자 작은 수\r\nlong long NUM_count[100001] = { {1 }, };\r\nlong long  Min=100000001;// 가장 길이가 작은 수\r\n\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N &gt;&gt; S;\r\n\r\n\r\n    fill_n(NUM_count, 10001, 1);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; num[i];\r\n        dp[i] += num[i];\r\n        for (int j = i+1; j &lt;= N; j++)\r\n        {\r\n            if (dp[i] &gt;= S)\r\n            {\r\n                Min = min(Min, NUM_count[i]);\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                dp[i] += num[j];\r\n                NUM_count[i]++;\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; Min;\r\n    \r\n}','2021-01-22 19:34:18',339),(12181751,'BJ',14891,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nint n;\r\nint roll[5][9] = { 0 };\r\nint rent[5][9] = { 0 };\r\n\r\nvector&lt;pair&lt;int,int&gt;&gt;v;\r\n\r\nvoid ori()\r\n{\r\n    for (int i = 0; i &lt; 4; i++)\r\n    {\r\n        for (int j = 0; j &lt; 8; j++)\r\n        {\r\n            roll[i][j] = rent[i][j];\r\n        }\r\n    }\r\n}\r\nvoid turn(int num,int n)\r\n{\r\n    if (n == -1)\r\n    {\r\n        for (int i = 1; i &lt; 8; i++)\r\n        {\r\n            rent[num][i-1] = roll[num][i];\r\n        }\r\n        rent[num][7] = roll[num][0];\r\n    }\r\n    else if (n == 1)\r\n    {\r\n        for (int i = 0; i &lt; 7; i++)\r\n        {\r\n            rent[num][i + 1] = roll[num][i];\r\n        }\r\n        rent[num][0] = roll[num][7];\r\n    }\r\n    ori();\r\n}\r\nvoid solve(int a, int b)\r\n{\r\n    int c = a; int d = b; int c1 = a; int d1 = b;\r\n    for (int i = 0; i &lt; 3; i++)\r\n    {\r\n        if (c - 1 &gt;= 0)//계속 왼쪽 확인\r\n        {\r\n            if (roll[c - 1][2] != roll[c][6])\r\n            {\r\n                v.push_back({ c - 1,d * (-1) });\r\n                c = c - 1; d = d * (-1);\r\n            }\r\n        }\r\n        if (c1 + 1 &lt; 4)//계속 오른쪽 확인\r\n        {\r\n            if (roll[c1 + 1][6] != roll[c1][2])\r\n            {\r\n                v.push_back({ c1 + 1,d1 * (-1) });\r\n                c1 = c1 + 1; d1 = d1 * (-1);\r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    for (int i = 0; i &lt; v.size(); i++)\r\n    {\r\n        turn(v.at(i).first, v.at(i).second);\r\n    }\r\n    v.clear();\r\n    \r\n}\r\nint main()\r\n{\r\n    int a1, b1;\r\n    for (int i = 0; i &lt; 4; i++)\r\n    {\r\n        for (int j = 0; j &lt; 8; j++)\r\n        {\r\n            scanf(&quot;%1d&quot;,&roll[i][j]);\r\n            rent[i][j] = roll[i][j];\r\n        }\r\n    }\r\n\r\n    cin &gt;&gt; n;\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        cin &gt;&gt; a1 &gt;&gt; b1;\r\n        v.push_back({ a1 - 1,b1 });\r\n        solve(a1-1, b1);\r\n    }\r\n    cout &lt;&lt; roll[0][0] + (roll[1][0]*2) + (roll[2][0]*4) + (roll[3][0]*8) &lt;&lt; endl;\r\n}','2021-01-25 20:33:47',340),(12151601,'BJ',1806,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint N, S;\r\nint* num;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cin &gt;&gt; N &gt;&gt; S;\r\n\r\n    num = new int[N];\r\n    for (int i = 0; i &lt; N; i++) cin &gt;&gt; num[i];\r\n\r\n    int sum = 0, i = 0, j = 0, answer = 100001;\r\n    while (j &lt; N) {\r\n        sum += num[j++];\r\n        while (sum &gt;= S) {\r\n            answer = min(answer, j - i);\r\n            sum -= num[i++];\r\n        }\r\n    }\r\n    if (answer == 100001) cout &lt;&lt; 0;\r\n    else cout &lt;&lt; answer;\r\n}','2021-01-24 15:33:24',341),(12181751,'BJ',1806,'#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint n, s;\r\nint num[100001] = { 0 };\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; n &gt;&gt; s;\r\n    for (int i = 0; i &lt; n; i++)\r\n        cin &gt;&gt; num[i];\r\n\r\n    int left = 0; int right = 0; int ans = 0; int cnt = 9999999999; bool check = false;\r\n    while (right &lt;= n && left &lt;= n)\r\n    {\r\n        if (s - ans &lt;= 0) // s &gt;= ans 인 경우cnt에 right-left(연속 숫자의 간격)와의 값과 최소인걸로 갱신 \r\n        {\r\n            cnt = cnt &gt; abs(right - left) ? abs(right - left) : cnt;\r\n            check = true;//출력할떄 갱신이 이뤄진적이 있는지 없는지 확인\r\n            ans -= num[left];//s&gt;=ans 이니까 이제껏 쌓았던거 하나 삭제\r\n            left++;\r\n        }\r\n        else if (s - ans &gt; 0)\r\n        {\r\n            ans += num[right]; //s&lt;ans이니까 앞으로 하나 더 쌓음\r\n            right++;\r\n        }\r\n    }\r\n    if (!check)\r\n        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;\r\n    else\r\n        cout &lt;&lt; cnt &lt;&lt; endl;\r\n}','2021-01-24 18:47:29',342),(12151601,'BJ',2468,'#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint N, answer, area[100][100];\r\nbool safe[100][100];\r\n\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\n\r\nvoid bfs(int x, int y, int high) {\r\n    queue&lt;pair&lt;int, int&gt;&gt; q;\r\n    q.push({ x, y });\r\n    safe[x][y] = true;\r\n    while (!q.empty()) {\r\n        x = q.front().first, y = q.front().second;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = x + dx[i], ny = y + dy[i];\r\n            if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= N) continue;\r\n            if (safe[nx][ny] || area[nx][ny] &lt;= high) continue;\r\n            q.push({ nx, ny });\r\n            safe[nx][ny] = true;\r\n        }\r\n    }\r\n}\r\n\r\nint safetyArea(int high) {\r\n    int cnt = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            if (!safe[i][j] && area[i][j] &gt; high) {\r\n                bfs(i, j, high);\r\n                cnt++;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            if (safe[i][j]) safe[i][j] = false;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cin &gt;&gt; N;\r\n    int highest = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; N; j++) {\r\n            cin &gt;&gt; area[i][j];\r\n            highest = highest &lt; area[i][j] ? area[i][j] : highest;\r\n        }\r\n    }\r\n    for (int h = 0; h &lt; highest; h++) {\r\n        answer = max(safetyArea(h), answer);\r\n    }\r\n    cout &lt;&lt; answer;\r\n}','2021-01-24 20:51:14',343),(12151601,'BJ',14502,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint N, M, answer, lab[8][8];\r\nvector&lt;pair&lt;int, int&gt;&gt; virus;\r\n\r\nint dx[] = { -1,0,1,0 };\r\nint dy[] = { 0,1,0,-1 };\r\n\r\nint countSafety() {\r\n    int copy_lab[8][8];\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            copy_lab[i][j] = lab[i][j];\r\n        }\r\n    }\r\n    queue&lt;pair&lt;int, int&gt;&gt; q;\r\n    for (int i = 0; i &lt; virus.size(); i++) q.push(virus[i]);\r\n    while (!q.empty()) {\r\n        int x = q.front().first, y = q.front().second;\r\n        q.pop();\r\n        for (int i = 0; i &lt; 4; i++) {\r\n            int nx = x + dx[i], ny = y + dy[i];\r\n            if (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= M) continue;\r\n            if (copy_lab[nx][ny] == 0) {\r\n                q.push({ nx, ny });\r\n                copy_lab[nx][ny] = 2;\r\n            }\r\n        }\r\n    }\r\n    int cnt = 0;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            if (copy_lab[i][j] == 0) cnt++;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\nvoid find(int n) {\r\n    if (n == 3) {\r\n        answer = max(answer, countSafety());\r\n    }\r\n    else {\r\n        for (int i = 0; i &lt; N; i++) {\r\n            for (int j = 0; j &lt; M; j++) {\r\n                if (lab[i][j] == 0) {\r\n                    lab[i][j] = 1;\r\n                    find(n + 1);\r\n                    lab[i][j] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin.tie(NULL);\r\n    ios::sync_with_stdio(false);\r\n\r\n    cin &gt;&gt; N &gt;&gt; M;\r\n    for (int i = 0; i &lt; N; i++) {\r\n        for (int j = 0; j &lt; M; j++) {\r\n            cin &gt;&gt; lab[i][j];\r\n            if (lab[i][j] == 2) virus.push_back({ i,j });\r\n        }\r\n    }\r\n    find(0);\r\n    cout &lt;&lt; answer;\r\n}','2021-01-24 21:28:20',344),(12171820,'BJ',2468,'#include &lt;iostream&gt;\r\n#include &lt;cstring&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n//첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다.\r\n//N은 2 이상 100 이하의 정수이다.\r\n//둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다.\r\n//각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다.\r\n//높이는 1이상 100 이하의 정수이다.\r\n\r\nint N; // 입력받을 배열의 크기 N*N\r\nint arr[100][100] = { 0 }; // 앞이 행이되고 뒤에가 열이된다. \r\nint visited[100][100] = { 0 };\r\n\r\nint max_height = 1;\r\nint ans = 1; // 정답\r\nint dy[4] = { 1,-1,0,0 };\r\nint dx[4] = { 0,0,1,-1 };\r\n\r\nvoid dfs(int y_i, int x_j, int height) {\r\n\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        int ny = y_i + dy[i];\r\n        int nx = x_j + dx[i];\r\n\r\n        if (ny &lt; 0 || ny &gt;= N || nx &lt; 0 || nx &gt;= N)\r\n            continue;\r\n        \r\n\r\n        if (arr[ny][nx] &lt;= height || visited[ny][nx])\r\n            continue;\r\n\r\n        visited[ny][nx]++;\r\n        dfs(ny, nx, height);\r\n    }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; N; j++)\r\n        {\r\n            cin &gt;&gt; arr[i][j];\r\n            max_height = max(arr[i][j], max_height);\r\n        \r\n        }\r\n    }\r\n    for (int height = 1; height &lt; max_height; height++)\r\n    {\r\n        memset(visited, 0, sizeof(visited)); // 매 회차마다 초기화 해줘야함\r\n        int cnt = 0;\r\n        for (int i = 0; i &lt; N; i++)\r\n        {\r\n            for (int j = 0; j &lt; N; j++)\r\n            {\r\n                if (arr[i][j] &gt; height && !visited[i][j])\r\n                {\r\n                    visited[i][j] ++;\r\n                    cnt++;\r\n                    dfs(i, j, height);\r\n                }\r\n\r\n            }\r\n        }\r\n        ans = max(ans, cnt);\r\n\r\n    }\r\n    cout &lt;&lt; ans;\r\nreturn 0;\r\n}\r\n','2021-01-25 17:45:21',345),(12181751,'BJ',1644,'//시간초과 해결 못하게뜸...시간초과만 문제가 맞겠죠?ㅎㅎ\r\n#include &lt;iostream&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\nint n;\r\nint num[4000001] = { 0 };\r\nint index = 0;\r\n\r\nvoid sosu_arr()\r\n{\r\n    for (int sosu = 2; sosu &lt;= n; sosu++)\r\n    {\r\n        bool check = false;\r\n        for (int i = 2; i &lt;= sqrt(sosu);i++)\r\n        {\r\n            if (sosu % i == 0)\r\n            {\r\n                check = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!check)\r\n        {\r\n            num[index] = sosu;\r\n            index++;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; n;\r\n    sosu_arr();\r\n    int left = 0; int right = 0; int ans = 0; int cnt = 0; bool check = false;\r\n    while (right &lt;= index && left &lt;= index)\r\n    {\r\n        if (n - ans == 0 && !check)\r\n        {\r\n            cnt++;\r\n            check = true;\r\n        }\r\n        else if (n - ans &gt; 0 || check)\r\n        {\r\n            ans += num[right];\r\n            right++;\r\n            check = false;\r\n        }\r\n        else if (n - ans &lt; 0)\r\n        {\r\n            ans -= num[left];\r\n            left++;\r\n        }\r\n    }\r\n    cout &lt;&lt; cnt &lt;&lt; endl;\r\n}','2021-01-25 18:09:24',346),(12171820,'BJ',1806,'#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nusing namespace std;\r\n\r\n//첫째 줄에 N(10 ≤ N &lt; 100, 000)과 S(0 &lt; S ≤ 100, 000, 000)가 주어진다.둘째 줄에는 수열이 주어진다.수열의 각 원소는 공백으로 구분되어져 있으며, 10, 000이하의 자연수이다.\r\nconst int INF = 999999999;\r\nint arr[100001];\r\nint N; // 숫자의 개수\r\nint S; // 넘어야 하는 값\r\nint low = 0; // 두개의 포인터가 될예정\r\nint high = 0; // 두개가 동시에 이동함\r\n\r\nint main(void)\r\n{\r\n   \r\n  \r\n    int result = INF;\r\n\r\n    cin &gt;&gt; N &gt;&gt; S;\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; arr[i];\r\n    }\r\n\r\n    int sum = arr[0];\r\n\r\n\r\n    while (low &lt;= high && high &lt; N)\r\n    {\r\n        if (sum &lt; S)\r\n        {\r\n            high++; // 커서를 하나씩 옮기면서 sum에 더해준다.\r\n            sum += arr[high];\r\n        }\r\n        else if(sum == S)\r\n        {\r\n            result = min(result, (high - low + 1)); // 길이를 잰다\r\n            high++;\r\n            sum += arr[high];\r\n        }\r\n        else if(sum &gt; S)\r\n        {\r\n            result = min(result, (high - low + 1)); // 길이를 잰다\r\n            sum -= arr[low];\r\n            low++;\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    if (result == INF) // 만약 다 더해도 S를 못넘기면 0을 출력해야 함\r\n    {\r\n        cout &lt;&lt; 0;\r\n    }\r\n    else {\r\n        cout &lt;&lt; result;\r\n    }\r\n\r\n    return 0;\r\n\r\n}\r\n','2021-01-25 18:13:40',347),(12151601,'BJ',1644,'#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;bitset&gt;\r\n\r\nusing namespace std;\r\n\r\nint N, answer;\r\nvector&lt;int&gt; prime;\r\nbitset&lt;4000001&gt; notPrime;\r\n\r\n\r\nvoid findPrime(int n) {\r\n    for (int i = 2; i &lt;= sqrt(n); i++) {\r\n        if (notPrime[i]) continue;\r\n        for (int j = i * 2; j &lt;= n; j += i) {\r\n            notPrime.set(j);\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    cin &gt;&gt; N;\r\n    int l = 0, r = 0, sum = 0, answer = 0;\r\n    findPrime(N);\r\n    for (int i = 2; i &lt;= N; i++) {\r\n        if (!notPrime[i]) {\r\n            prime.push_back(i);\r\n            sum += prime[r++];\r\n            while (sum &gt;= N) {\r\n                if (sum == N) answer++;\r\n                sum -= prime[l++];\r\n            }\r\n        }\r\n    }\r\n    cout &lt;&lt; answer;\r\n}','2021-01-25 19:14:27',348),(12151601,'BJ',14891,'#include &lt;iostream&gt;\r\n#include &lt;memory.h&gt;\r\n#include &lt;math.h&gt;\r\nusing namespace std;\r\n\r\nbool gear[4][8];\r\nbool visit[4];\r\n\r\nvoid rotate(int n, int d) {\r\n    int temp;\r\n    switch (d) {\r\n    case 1:\r\n        temp = gear[n][7];\r\n        for (int i = 7; i &gt; 0; i--) {\r\n            gear[n][i] = gear[n][i - 1];\r\n        }\r\n        gear[n][0] = temp;\r\n        break;\r\n\r\n    case -1:\r\n        temp = gear[n][0];\r\n        for (int i = 0; i &lt; 7; i++) {\r\n            gear[n][i] = gear[n][i + 1];\r\n        }\r\n        gear[n][7] = temp;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid move(int n, int d) {\r\n    visit[n] = true;\r\n    bool left = false, right = false;\r\n\r\n    if (n - 1 &gt;= 0 && !visit[n - 1])\r\n        if (gear[n - 1][2] != gear[n][6])\r\n            left = true;\r\n\r\n    if (n + 1 &lt;= 3 && !visit[n + 1])\r\n        if (gear[n][2] != gear[n + 1][6])\r\n            right = true;\r\n\r\n    rotate(n, d);\r\n\r\n    if (left)\r\n        move(n - 1, d * -1);\r\n\r\n    if (right)\r\n        move(n + 1, d * -1);\r\n}\r\n\r\nint main() {\r\n    int ans = 0;\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        for (int j = 0; j &lt; 8; j++) {\r\n            scanf(&quot;%1d&quot;, &gear[i][j]);\r\n        }\r\n    }\r\n    int K, n, d;\r\n    cin &gt;&gt; K;\r\n    for (int i = 0; i &lt; K; i++) {\r\n        memset(visit, false, sizeof(visit));\r\n        cin &gt;&gt; n &gt;&gt; d;\r\n        move(n - 1, d);\r\n    }\r\n    for (int i = 0; i &lt; 4; i++) {\r\n        if (gear[i][0]) {\r\n            ans += pow(2, i);\r\n        }\r\n    }\r\n    cout &lt;&lt; ans;\r\n}','2021-01-25 19:21:21',349),(12181751,'BJ',14502,'//아직\r\n#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\n#include &lt;vector&gt;\r\nusing namespace std;\r\nstruct go {\r\n    int y, x, cnt;\r\n};\r\nint h, w;\r\nint num[9][9] = { 0 };\r\nint rent[9][9] = { 0 };\r\nbool visited[9][9] = { 0 };\r\nbool visited1[9][9] = { 0 };\r\nint dir_x[] = { -1,1,0,0 };\r\nint dir_y[] = { 0,0,-1,1 };\r\nint answer = 0;\r\nvoid bfs()\r\n{\r\n    queue&lt;go&gt; q;\r\n    if (rent[0][0] == 2)\r\n        q.push({ 0,0,1 });\r\n    else\r\n        q.push({ 0,0,0 });\r\n    visited1[0][0] = true;\r\n    while (!q.empty())\r\n    {\r\n        int nowy = q.front().y; int nowx = q.front().x; int Cnt = q.front().cnt;\r\n        q.pop();\r\n        if (nowy == h - 1 && nowx == w - 1)\r\n        {\r\n            answer = answer &gt; Cnt ? answer : Cnt;\r\n        }\r\n        for (int i = 0; i &lt; 4; i++)\r\n        {\r\n            int x = nowx + dir_x[i]; int y = nowy + dir_y[i];\r\n            if (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h || visited1[y][x])\r\n                continue;\r\n            visited1[y][x] = true;\r\n            if (rent[nowy][nowx] == 2)\r\n            {\r\n                rent[y][x] = 2;\r\n                q.push({ y,x,Cnt + 1 });\r\n            }\r\n            else\r\n                q.push({ y,x,Cnt });\r\n            \r\n        }\r\n    }\r\n}\r\nvoid dfs(int nowy,int nowx,int cnt)\r\n{\r\n    if (cnt == 3)\r\n    {\r\n        bfs();\r\n        cout&lt;&lt;answer&lt;&lt;endl;\r\n        for (int y = 0; y &lt; h; y++)\r\n        {\r\n            for (int x = 0; x &lt; w; x++)\r\n            {\r\n                visited1[y][x] = false;\r\n                rent[y][x] = num[y][x];\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    for (int i = 0; i &lt; 4; i++)\r\n    {\r\n        int x = nowx + dir_x[i]; int y = nowy + dir_y[i];\r\n        if (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h || visited[y][x])\r\n            continue;\r\n        if (rent[y][x] == 0)\r\n        {\r\n            rent[y][x] = 1;\r\n            visited[y][x] = true;\r\n            dfs(y, x, cnt + 1);\r\n            rent[y][x] = 0;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin &gt;&gt; h &gt;&gt; w;\r\n    int one = 0;\r\n    for (int y = 0; y &lt; h; y++)\r\n    {\r\n        for (int x = 0; x &lt; w; x++)\r\n        {\r\n            cin &gt;&gt; num[y][x];\r\n            if (num[y][x] == 1)\r\n                one++;\r\n            rent[y][x] = num[y][x];\r\n        }\r\n    }\r\n    for (int y = 0; y &lt; h; y++)\r\n    {\r\n        for (int x = 0; x &lt; w; w++)\r\n        {\r\n            if (!visited[y][x] && rent[y][x] == 0)\r\n            {\r\n                visited[y][x] = true;\r\n                dfs(y, x, 0);\r\n\r\n            }\r\n        }\r\n    }\r\n    int ans = w * h - answer - one - 3;\r\n    cout &lt;&lt; ans &lt;&lt; endl;\r\n}','2021-01-25 20:27:30',350);
/*!40000 ALTER TABLE `SOLVE` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `USER`
--

DROP TABLE IF EXISTS `USER`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `USER` (
  `id` int(11) NOT NULL,
  `name` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `passwd` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `class` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `USER`
--

LOCK TABLES `USER` WRITE;
/*!40000 ALTER TABLE `USER` DISABLE KEYS */;
INSERT INTO `USER` VALUES (12151526,'김범수','long',1),(12151536,'김욱찬','12151536',1),(12151551,'라찬엽','12151551',1),(12151601,'이유노','p12151601',1),(12151616,'전수현','p12151616',1),(12151629,'주현성','12151629',1),(12151636,'최진우','p12151636',1),(12161746,'안유정','960701',2),(12161777,'이호준','dlghwns1!',2),(12161783,'전민규','in1472',2),(12171820,'이성인','12171820',2),(12181751,'김용주','12181751',2),(12181853,'홍지인','990706',2);
/*!40000 ALTER TABLE `USER` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-01-25 22:00:56
